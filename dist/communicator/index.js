var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __pow = Math.pow;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream2(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error2(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error2(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream2;
  }
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/node-gyp-build/index.js
var require_node_gyp_build = __commonJS({
  "node_modules/node-gyp-build/index.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? "electron" : "node";
    var arch = os.arch();
    var platform = os.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
    var uv = (process.versions.uv || "").split(".")[0];
    module2.exports = load;
    function load(dir) {
      return runtimeRequire(load.path(dir));
    }
    load.path = function(dir) {
      dir = path.resolve(dir || ".");
      try {
        var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
        if (process.env[name + "_PREBUILD"])
          dir = process.env[name + "_PREBUILD"];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path.join(dir, "build/Release"), matchBuild);
        if (release)
          return release;
        var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
        if (debug)
          return debug;
      }
      var prebuild = resolve(dir);
      if (prebuild)
        return prebuild;
      var nearby = resolve(path.dirname(process.execPath));
      if (nearby)
        return nearby;
      var target = [
        "platform=" + platform,
        "arch=" + arch,
        "runtime=" + runtime,
        "abi=" + abi,
        "uv=" + uv,
        armv ? "armv=" + armv : "",
        "libc=" + libc,
        "node=" + process.versions.node,
        process.versions.electron ? "electron=" + process.versions.electron : "",
        typeof __webpack_require__ === "function" ? "webpack=true" : ""
      ].filter(Boolean).join(" ");
      throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
      function resolve(dir2) {
        var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
        var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple)
          return;
        var prebuilds = path.join(dir2, "prebuilds", tuple.name);
        var parsed = readdirSync(prebuilds).map(parseTags);
        var candidates = parsed.filter(matchTags(runtime, abi));
        var winner = candidates.sort(compareTags(runtime))[0];
        if (winner)
          return path.join(prebuilds, winner.file);
      }
    };
    function readdirSync(dir) {
      try {
        return fs.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }
    function getFirst(dir, filter) {
      var files = readdirSync(dir).filter(filter);
      return files[0] && path.join(dir, files[0]);
    }
    function matchBuild(name) {
      return /\.node$/.test(name);
    }
    function parseTuple(name) {
      var arr = name.split("-");
      if (arr.length !== 2)
        return;
      var platform2 = arr[0];
      var architectures = arr[1].split("+");
      if (!platform2)
        return;
      if (!architectures.length)
        return;
      if (!architectures.every(Boolean))
        return;
      return { name, platform: platform2, architectures };
    }
    function matchTuple(platform2, arch2) {
      return function(tuple) {
        if (tuple == null)
          return false;
        if (tuple.platform !== platform2)
          return false;
        return tuple.architectures.includes(arch2);
      };
    }
    function compareTuples(a, b) {
      return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
      var arr = file.split(".");
      var extension = arr.pop();
      var tags = { file, specificity: 0 };
      if (extension !== "node")
        return;
      for (var i = 0; i < arr.length; i++) {
        var tag = arr[i];
        if (tag === "node" || tag === "electron" || tag === "node-webkit") {
          tags.runtime = tag;
        } else if (tag === "napi") {
          tags.napi = true;
        } else if (tag.slice(0, 3) === "abi") {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === "uv") {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === "armv") {
          tags.armv = tag.slice(4);
        } else if (tag === "glibc" || tag === "musl") {
          tags.libc = tag;
        } else {
          continue;
        }
        tags.specificity++;
      }
      return tags;
    }
    function matchTags(runtime2, abi2) {
      return function(tags) {
        if (tags == null)
          return false;
        if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
          return false;
        if (tags.abi !== abi2 && !tags.napi)
          return false;
        if (tags.uv && tags.uv !== uv)
          return false;
        if (tags.armv && tags.armv !== armv)
          return false;
        if (tags.libc && tags.libc !== libc)
          return false;
        return true;
      };
    }
    function runtimeAgnostic(tags) {
      return tags.runtime === "node" && tags.napi;
    }
    function compareTags(runtime2) {
      return function(a, b) {
        if (a.runtime !== b.runtime) {
          return a.runtime === runtime2 ? -1 : 1;
        } else if (a.abi !== b.abi) {
          return a.abi ? -1 : 1;
        } else if (a.specificity !== b.specificity) {
          return a.specificity > b.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }
    function isElectron() {
      if (process.versions && process.versions.electron)
        return true;
      if (process.env.ELECTRON_RUN_AS_NODE)
        return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    function isAlpine(platform2) {
      return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
    }
    load.parseTags = parseTags;
    load.matchTags = matchTags;
    load.compareTags = compareTags;
    load.parseTuple = parseTuple;
    load.matchTuple = matchTuple;
    load.compareTuples = compareTuples;
  }
});

// node_modules/bufferutil/fallback.js
var require_fallback = __commonJS({
  "node_modules/bufferutil/fallback.js"(exports2, module2) {
    "use strict";
    var mask = (source, mask2, output, offset, length) => {
      for (var i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask2[i & 3];
      }
    };
    var unmask = (buffer, mask2) => {
      const length = buffer.length;
      for (var i = 0; i < length; i++) {
        buffer[i] ^= mask2[i & 3];
      }
    };
    module2.exports = { mask, unmask };
  }
});

// node_modules/bufferutil/index.js
var require_bufferutil = __commonJS({
  "node_modules/bufferutil/index.js"(exports2, module2) {
    "use strict";
    try {
      module2.exports = require_node_gyp_build()(__dirname);
    } catch (e) {
      module2.exports = require_fallback();
    }
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = require_bufferutil();
      module2.exports = {
        concat,
        mask(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error("The deflate stream was closed while data was being processed"));
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/utf-8-validate/fallback.js
var require_fallback2 = __commonJS({
  "node_modules/utf-8-validate/fallback.js"(exports2, module2) {
    "use strict";
    function isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = isValidUTF8;
  }
});

// node_modules/utf-8-validate/index.js
var require_utf_8_validate = __commonJS({
  "node_modules/utf-8-validate/index.js"(exports2, module2) {
    "use strict";
    try {
      module2.exports = require_node_gyp_build()(__dirname);
    } catch (e) {
      module2.exports = require_fallback2();
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      const isValidUTF8 = require_utf_8_validate();
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        },
        tokenChars
      };
    } catch (e) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8,
        tokenChars
      };
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver2 = class extends Writable {
      constructor(options = {}) {
        super();
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error2(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error2(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error2(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (!this._fragmented) {
            this._loop = false;
            return error2(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error2(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error2(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          }
          if (compressed) {
            this._loop = false;
            return error2(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error2(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          }
        } else {
          this._loop = false;
          return error2(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error2(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          }
        } else if (this._masked) {
          this._loop = false;
          return error2(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error2(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error2(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked)
            unmask(data, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error2(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error2(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else if (data.length === 1) {
            return error2(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error2(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            }
            const buf = data.slice(2);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error2(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver2;
    function error2(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, error2);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var mask = Buffer.alloc(4);
    var Sender2 = class {
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options) {
        const merge = options.mask && options.readOnly;
        let offset = options.mask ? 6 : 2;
        let payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(data.length, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge) {
          applyMask(data, mask, target, offset, data.length);
          return [target];
        }
        applyMask(data, mask, data, 0, data.length);
        return [target, data];
      }
      close(code, data, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      doClose(data, mask2, cb) {
        this.sendFrame(Sender2.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 8,
          mask: mask2,
          readOnly: false
        }), cb);
      }
      ping(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPing(data, mask2, readOnly, cb) {
        this.sendFrame(Sender2.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 9,
          mask: mask2,
          readOnly
        }), cb);
      }
      pong(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPong(data, mask2, readOnly, cb) {
        this.sendFrame(Sender2.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 10,
          mask: mask2,
          readOnly
        }), cb);
      }
      send(data, options, cb) {
        const buf = toBuffer(data);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options.fin,
            rsv1,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender2.frame(buf, {
            fin: options.fin,
            rsv1: false,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          }), cb);
        }
      }
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender2.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += data.length;
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while data was being compressed");
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const callback = this._queue[i][4];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= data.length;
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender2.frame(buf, options), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event2 = class {
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      get target() {
        return this[kTarget];
      }
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event2.prototype, "target", { enumerable: true });
    Object.defineProperty(Event2.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event2 {
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      get code() {
        return this[kCode];
      }
      get reason() {
        return this[kReason];
      }
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent2 = class extends Event2 {
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      get error() {
        return this[kError];
      }
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent2.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent2.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event2 {
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      addEventListener(type, listener, options = {}) {
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error2) {
            const event = new ErrorEvent2("error", {
              error: error2,
              message: error2.message
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event2("open");
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = listener;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent: ErrorEvent2,
      Event: Event2,
      EventTarget,
      MessageEvent
    };
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = Object.create(null);
      let params = Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format2(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(Object.keys(params).map((k) => {
            let values = params[k];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format: format2, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable } = require("stream");
    var { URL } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener: addEventListener2, removeEventListener: removeEventListener2 }
    } = require_event_target();
    var { format: format2, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket2 = class extends EventEmitter2 {
      constructor(address2, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket2.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address2 !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address2, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get isPaused() {
        return this._paused;
      }
      get onclose() {
        return null;
      }
      get onerror() {
        return null;
      }
      get onopen() {
        return null;
      }
      get onmessage() {
        return null;
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, options) {
        const receiver = new Receiver2({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender2(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket2.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket2.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket2.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket2.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket2.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }
      pause() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      ping(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      resume() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      send(data, options, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket2.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener2;
    WebSocket2.prototype.removeEventListener = removeEventListener2;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address2, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      let parsedUrl;
      if (address2 instanceof URL) {
        parsedUrl = address2;
        websocket._url = address2.href;
      } else {
        try {
          parsedUrl = new URL(address2);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address2}`);
        }
        websocket._url = address2;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      let invalidURLMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isUnixSocket) {
        invalidURLMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isUnixSocket && !parsedUrl.pathname) {
        invalidURLMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidURLMessage = "The URL contains a fragment identifier";
      }
      if (invalidURLMessage) {
        const err = new SyntaxError(invalidURLMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const get = isSecure ? https.get : http.get;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = format2({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError("An invalid or duplicated subprotocol was specified");
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req = websocket._req = get(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted)
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL(location, address2);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING)
          return;
        req = websocket._req = null;
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var http = require("http");
    var https = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer2 = class extends EventEmitter2 {
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options.port, options.host, options.backlog, callback);
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"] : false;
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new WebSocket2(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer2;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http.STATUS_CODES[code];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports2, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports3) {
          factory(createExporter(root, createExporter(exports3)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports3, previous) {
        if (exports3 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports3, "__esModule", { value: true });
          } else {
            exports3.__esModule = true;
          }
        }
        return function(id, v) {
          return exports3[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __exportStar = function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !exports3.hasOwnProperty(p))
            exports3[p] = m[p];
      };
      __values = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error2) {
          e = { error: error2 };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result[k] = mod[k];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@sentry/types/dist/loglevel.js
var require_loglevel = __commonJS({
  "node_modules/@sentry/types/dist/loglevel.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var LogLevel;
    (function(LogLevel2) {
      LogLevel2[LogLevel2["None"] = 0] = "None";
      LogLevel2[LogLevel2["Error"] = 1] = "Error";
      LogLevel2[LogLevel2["Debug"] = 2] = "Debug";
      LogLevel2[LogLevel2["Verbose"] = 3] = "Verbose";
    })(LogLevel = exports2.LogLevel || (exports2.LogLevel = {}));
  }
});

// node_modules/@sentry/types/dist/session.js
var require_session = __commonJS({
  "node_modules/@sentry/types/dist/session.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var SessionStatus;
    (function(SessionStatus2) {
      SessionStatus2["Ok"] = "ok";
      SessionStatus2["Exited"] = "exited";
      SessionStatus2["Crashed"] = "crashed";
      SessionStatus2["Abnormal"] = "abnormal";
    })(SessionStatus = exports2.SessionStatus || (exports2.SessionStatus = {}));
    var RequestSessionStatus;
    (function(RequestSessionStatus2) {
      RequestSessionStatus2["Ok"] = "ok";
      RequestSessionStatus2["Errored"] = "errored";
      RequestSessionStatus2["Crashed"] = "crashed";
    })(RequestSessionStatus = exports2.RequestSessionStatus || (exports2.RequestSessionStatus = {}));
  }
});

// node_modules/@sentry/types/dist/severity.js
var require_severity = __commonJS({
  "node_modules/@sentry/types/dist/severity.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Severity;
    (function(Severity2) {
      Severity2["Fatal"] = "fatal";
      Severity2["Error"] = "error";
      Severity2["Warning"] = "warning";
      Severity2["Log"] = "log";
      Severity2["Info"] = "info";
      Severity2["Debug"] = "debug";
      Severity2["Critical"] = "critical";
    })(Severity = exports2.Severity || (exports2.Severity = {}));
    (function(Severity2) {
      function fromString(level) {
        switch (level) {
          case "debug":
            return Severity2.Debug;
          case "info":
            return Severity2.Info;
          case "warn":
          case "warning":
            return Severity2.Warning;
          case "error":
            return Severity2.Error;
          case "fatal":
            return Severity2.Fatal;
          case "critical":
            return Severity2.Critical;
          case "log":
          default:
            return Severity2.Log;
        }
      }
      Severity2.fromString = fromString;
    })(Severity = exports2.Severity || (exports2.Severity = {}));
  }
});

// node_modules/@sentry/types/dist/status.js
var require_status = __commonJS({
  "node_modules/@sentry/types/dist/status.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Status;
    (function(Status2) {
      Status2["Unknown"] = "unknown";
      Status2["Skipped"] = "skipped";
      Status2["Success"] = "success";
      Status2["RateLimit"] = "rate_limit";
      Status2["Invalid"] = "invalid";
      Status2["Failed"] = "failed";
    })(Status = exports2.Status || (exports2.Status = {}));
    (function(Status2) {
      function fromHttpCode(code) {
        if (code >= 200 && code < 300) {
          return Status2.Success;
        }
        if (code === 429) {
          return Status2.RateLimit;
        }
        if (code >= 400 && code < 500) {
          return Status2.Invalid;
        }
        if (code >= 500) {
          return Status2.Failed;
        }
        return Status2.Unknown;
      }
      Status2.fromHttpCode = fromHttpCode;
    })(Status = exports2.Status || (exports2.Status = {}));
  }
});

// node_modules/@sentry/types/dist/transaction.js
var require_transaction = __commonJS({
  "node_modules/@sentry/types/dist/transaction.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var TransactionSamplingMethod;
    (function(TransactionSamplingMethod2) {
      TransactionSamplingMethod2["Explicit"] = "explicitly_set";
      TransactionSamplingMethod2["Sampler"] = "client_sampler";
      TransactionSamplingMethod2["Rate"] = "client_rate";
      TransactionSamplingMethod2["Inheritance"] = "inheritance";
    })(TransactionSamplingMethod = exports2.TransactionSamplingMethod || (exports2.TransactionSamplingMethod = {}));
  }
});

// node_modules/@sentry/types/dist/transport.js
var require_transport = __commonJS({
  "node_modules/@sentry/types/dist/transport.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Outcome;
    (function(Outcome2) {
      Outcome2["BeforeSend"] = "before_send";
      Outcome2["EventProcessor"] = "event_processor";
      Outcome2["NetworkError"] = "network_error";
      Outcome2["QueueOverflow"] = "queue_overflow";
      Outcome2["RateLimitBackoff"] = "ratelimit_backoff";
      Outcome2["SampleRate"] = "sample_rate";
    })(Outcome = exports2.Outcome || (exports2.Outcome = {}));
  }
});

// node_modules/@sentry/types/dist/index.js
var require_dist = __commonJS({
  "node_modules/@sentry/types/dist/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var loglevel_1 = require_loglevel();
    exports2.LogLevel = loglevel_1.LogLevel;
    var session_1 = require_session();
    exports2.SessionStatus = session_1.SessionStatus;
    exports2.RequestSessionStatus = session_1.RequestSessionStatus;
    var severity_1 = require_severity();
    exports2.Severity = severity_1.Severity;
    var status_1 = require_status();
    exports2.Status = status_1.Status;
    var transaction_1 = require_transaction();
    exports2.TransactionSamplingMethod = transaction_1.TransactionSamplingMethod;
    var transport_1 = require_transport();
    exports2.Outcome = transport_1.Outcome;
  }
});

// node_modules/@sentry/utils/dist/async.js
var require_async = __commonJS({
  "node_modules/@sentry/utils/dist/async.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    function forget(promise) {
      void promise.then(null, function(e) {
        console.error(e);
      });
    }
    exports2.forget = forget;
  }
});

// node_modules/@sentry/utils/dist/node.js
var require_node = __commonJS({
  "node_modules/@sentry/utils/dist/node.js"(exports2, module2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isNodeEnv() {
      return Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
    }
    exports2.isNodeEnv = isNodeEnv;
    function dynamicRequire(mod, request) {
      return mod.require(request);
    }
    exports2.dynamicRequire = dynamicRequire;
    function loadModule(moduleName) {
      var mod;
      try {
        mod = dynamicRequire(module2, moduleName);
      } catch (e) {
      }
      try {
        var cwd = dynamicRequire(module2, "process").cwd;
        mod = dynamicRequire(module2, cwd() + "/node_modules/" + moduleName);
      } catch (e) {
      }
      return mod;
    }
    exports2.loadModule = loadModule;
  }
});

// node_modules/@sentry/utils/dist/global.js
var require_global = __commonJS({
  "node_modules/@sentry/utils/dist/global.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var node_1 = require_node();
    var fallbackGlobalObject = {};
    function getGlobalObject() {
      return node_1.isNodeEnv() ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : fallbackGlobalObject;
    }
    exports2.getGlobalObject = getGlobalObject;
  }
});

// node_modules/@sentry/utils/dist/is.js
var require_is = __commonJS({
  "node_modules/@sentry/utils/dist/is.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isError(wat) {
      switch (Object.prototype.toString.call(wat)) {
        case "[object Error]":
          return true;
        case "[object Exception]":
          return true;
        case "[object DOMException]":
          return true;
        default:
          return isInstanceOf(wat, Error);
      }
    }
    exports2.isError = isError;
    function isErrorEvent(wat) {
      return Object.prototype.toString.call(wat) === "[object ErrorEvent]";
    }
    exports2.isErrorEvent = isErrorEvent;
    function isDOMError(wat) {
      return Object.prototype.toString.call(wat) === "[object DOMError]";
    }
    exports2.isDOMError = isDOMError;
    function isDOMException(wat) {
      return Object.prototype.toString.call(wat) === "[object DOMException]";
    }
    exports2.isDOMException = isDOMException;
    function isString(wat) {
      return Object.prototype.toString.call(wat) === "[object String]";
    }
    exports2.isString = isString;
    function isPrimitive(wat) {
      return wat === null || typeof wat !== "object" && typeof wat !== "function";
    }
    exports2.isPrimitive = isPrimitive;
    function isPlainObject(wat) {
      return Object.prototype.toString.call(wat) === "[object Object]";
    }
    exports2.isPlainObject = isPlainObject;
    function isEvent(wat) {
      return typeof Event !== "undefined" && isInstanceOf(wat, Event);
    }
    exports2.isEvent = isEvent;
    function isElement(wat) {
      return typeof Element !== "undefined" && isInstanceOf(wat, Element);
    }
    exports2.isElement = isElement;
    function isRegExp(wat) {
      return Object.prototype.toString.call(wat) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isThenable(wat) {
      return Boolean(wat && wat.then && typeof wat.then === "function");
    }
    exports2.isThenable = isThenable;
    function isSyntheticEvent(wat) {
      return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
    }
    exports2.isSyntheticEvent = isSyntheticEvent;
    function isInstanceOf(wat, base) {
      try {
        return wat instanceof base;
      } catch (_e) {
        return false;
      }
    }
    exports2.isInstanceOf = isInstanceOf;
  }
});

// node_modules/@sentry/utils/dist/browser.js
var require_browser = __commonJS({
  "node_modules/@sentry/utils/dist/browser.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var global_1 = require_global();
    var is_1 = require_is();
    function htmlTreeAsString(elem, keyAttrs) {
      try {
        var currentElem = elem;
        var MAX_TRAVERSE_HEIGHT = 5;
        var MAX_OUTPUT_LEN = 80;
        var out = [];
        var height = 0;
        var len = 0;
        var separator = " > ";
        var sepLength = separator.length;
        var nextStr = void 0;
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
          nextStr = _htmlElementAsString(currentElem, keyAttrs);
          if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN) {
            break;
          }
          out.push(nextStr);
          len += nextStr.length;
          currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
      } catch (_oO) {
        return "<unknown>";
      }
    }
    exports2.htmlTreeAsString = htmlTreeAsString;
    function _htmlElementAsString(el, keyAttrs) {
      var _a, _b;
      var elem = el;
      var out = [];
      var className;
      var classes;
      var key;
      var attr;
      var i;
      if (!elem || !elem.tagName) {
        return "";
      }
      out.push(elem.tagName.toLowerCase());
      var keyAttrPairs = ((_a = keyAttrs) === null || _a === void 0 ? void 0 : _a.length) ? keyAttrs.filter(function(keyAttr) {
        return elem.getAttribute(keyAttr);
      }).map(function(keyAttr) {
        return [keyAttr, elem.getAttribute(keyAttr)];
      }) : null;
      if ((_b = keyAttrPairs) === null || _b === void 0 ? void 0 : _b.length) {
        keyAttrPairs.forEach(function(keyAttrPair) {
          out.push("[" + keyAttrPair[0] + '="' + keyAttrPair[1] + '"]');
        });
      } else {
        if (elem.id) {
          out.push("#" + elem.id);
        }
        className = elem.className;
        if (className && is_1.isString(className)) {
          classes = className.split(/\s+/);
          for (i = 0; i < classes.length; i++) {
            out.push("." + classes[i]);
          }
        }
      }
      var allowedAttrs = ["type", "name", "title", "alt"];
      for (i = 0; i < allowedAttrs.length; i++) {
        key = allowedAttrs[i];
        attr = elem.getAttribute(key);
        if (attr) {
          out.push("[" + key + '="' + attr + '"]');
        }
      }
      return out.join("");
    }
    function getLocationHref() {
      var global2 = global_1.getGlobalObject();
      try {
        return global2.document.location.href;
      } catch (oO) {
        return "";
      }
    }
    exports2.getLocationHref = getLocationHref;
  }
});

// node_modules/@sentry/utils/dist/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/@sentry/utils/dist/polyfill.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setPrototypeOf = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
    function setProtoOf(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    }
    function mixinProperties(obj, proto) {
      for (var prop in proto) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
          obj[prop] = proto[prop];
        }
      }
      return obj;
    }
  }
});

// node_modules/@sentry/utils/dist/error.js
var require_error = __commonJS({
  "node_modules/@sentry/utils/dist/error.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var polyfill_1 = require_polyfill();
    var SentryError = function(_super) {
      tslib_1.__extends(SentryError2, _super);
      function SentryError2(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = _newTarget.prototype.constructor.name;
        polyfill_1.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
      }
      return SentryError2;
    }(Error);
    exports2.SentryError = SentryError;
  }
});

// node_modules/@sentry/utils/dist/dsn.js
var require_dsn = __commonJS({
  "node_modules/@sentry/utils/dist/dsn.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var error_1 = require_error();
    var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;
    var ERROR_MESSAGE = "Invalid Dsn";
    var Dsn = function() {
      function Dsn2(from) {
        if (typeof from === "string") {
          this._fromString(from);
        } else {
          this._fromComponents(from);
        }
        this._validate();
      }
      Dsn2.prototype.toString = function(withPassword) {
        if (withPassword === void 0) {
          withPassword = false;
        }
        var _a = this, host = _a.host, path = _a.path, pass = _a.pass, port = _a.port, projectId = _a.projectId, protocol = _a.protocol, publicKey = _a.publicKey;
        return protocol + "://" + publicKey + (withPassword && pass ? ":" + pass : "") + ("@" + host + (port ? ":" + port : "") + "/" + (path ? path + "/" : path) + projectId);
      };
      Dsn2.prototype._fromString = function(str) {
        var match2 = DSN_REGEX.exec(str);
        if (!match2) {
          throw new error_1.SentryError(ERROR_MESSAGE);
        }
        var _a = tslib_1.__read(match2.slice(1), 6), protocol = _a[0], publicKey = _a[1], _b = _a[2], pass = _b === void 0 ? "" : _b, host = _a[3], _c = _a[4], port = _c === void 0 ? "" : _c, lastPath = _a[5];
        var path = "";
        var projectId = lastPath;
        var split = projectId.split("/");
        if (split.length > 1) {
          path = split.slice(0, -1).join("/");
          projectId = split.pop();
        }
        if (projectId) {
          var projectMatch = projectId.match(/^\d+/);
          if (projectMatch) {
            projectId = projectMatch[0];
          }
        }
        this._fromComponents({ host, pass, path, projectId, port, protocol, publicKey });
      };
      Dsn2.prototype._fromComponents = function(components) {
        if ("user" in components && !("publicKey" in components)) {
          components.publicKey = components.user;
        }
        this.user = components.publicKey || "";
        this.protocol = components.protocol;
        this.publicKey = components.publicKey || "";
        this.pass = components.pass || "";
        this.host = components.host;
        this.port = components.port || "";
        this.path = components.path || "";
        this.projectId = components.projectId;
      };
      Dsn2.prototype._validate = function() {
        var _this = this;
        ["protocol", "publicKey", "host", "projectId"].forEach(function(component) {
          if (!_this[component]) {
            throw new error_1.SentryError(ERROR_MESSAGE + ": " + component + " missing");
          }
        });
        if (!this.projectId.match(/^\d+$/)) {
          throw new error_1.SentryError(ERROR_MESSAGE + ": Invalid projectId " + this.projectId);
        }
        if (this.protocol !== "http" && this.protocol !== "https") {
          throw new error_1.SentryError(ERROR_MESSAGE + ": Invalid protocol " + this.protocol);
        }
        if (this.port && isNaN(parseInt(this.port, 10))) {
          throw new error_1.SentryError(ERROR_MESSAGE + ": Invalid port " + this.port);
        }
      };
      return Dsn2;
    }();
    exports2.Dsn = Dsn;
  }
});

// node_modules/@sentry/utils/dist/logger.js
var require_logger = __commonJS({
  "node_modules/@sentry/utils/dist/logger.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var global_1 = require_global();
    var global2 = global_1.getGlobalObject();
    var PREFIX = "Sentry Logger ";
    function consoleSandbox(callback) {
      var global3 = global_1.getGlobalObject();
      var levels = ["debug", "info", "warn", "error", "log", "assert"];
      if (!("console" in global3)) {
        return callback();
      }
      var originalConsole = global3.console;
      var wrappedLevels = {};
      levels.forEach(function(level) {
        if (level in global3.console && originalConsole[level].__sentry_original__) {
          wrappedLevels[level] = originalConsole[level];
          originalConsole[level] = originalConsole[level].__sentry_original__;
        }
      });
      var result = callback();
      Object.keys(wrappedLevels).forEach(function(level) {
        originalConsole[level] = wrappedLevels[level];
      });
      return result;
    }
    exports2.consoleSandbox = consoleSandbox;
    var Logger = function() {
      function Logger2() {
        this._enabled = false;
      }
      Logger2.prototype.disable = function() {
        this._enabled = false;
      };
      Logger2.prototype.enable = function() {
        this._enabled = true;
      };
      Logger2.prototype.log = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!this._enabled) {
          return;
        }
        consoleSandbox(function() {
          global2.console.log(PREFIX + "[Log]: " + args.join(" "));
        });
      };
      Logger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!this._enabled) {
          return;
        }
        consoleSandbox(function() {
          global2.console.warn(PREFIX + "[Warn]: " + args.join(" "));
        });
      };
      Logger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!this._enabled) {
          return;
        }
        consoleSandbox(function() {
          global2.console.error(PREFIX + "[Error]: " + args.join(" "));
        });
      };
      return Logger2;
    }();
    global2.__SENTRY__ = global2.__SENTRY__ || {};
    var logger = global2.__SENTRY__.logger || (global2.__SENTRY__.logger = new Logger());
    exports2.logger = logger;
  }
});

// node_modules/@sentry/utils/dist/memo.js
var require_memo = __commonJS({
  "node_modules/@sentry/utils/dist/memo.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Memo = function() {
      function Memo2() {
        this._hasWeakSet = typeof WeakSet === "function";
        this._inner = this._hasWeakSet ? new WeakSet() : [];
      }
      Memo2.prototype.memoize = function(obj) {
        if (this._hasWeakSet) {
          if (this._inner.has(obj)) {
            return true;
          }
          this._inner.add(obj);
          return false;
        }
        for (var i = 0; i < this._inner.length; i++) {
          var value = this._inner[i];
          if (value === obj) {
            return true;
          }
        }
        this._inner.push(obj);
        return false;
      };
      Memo2.prototype.unmemoize = function(obj) {
        if (this._hasWeakSet) {
          this._inner.delete(obj);
        } else {
          for (var i = 0; i < this._inner.length; i++) {
            if (this._inner[i] === obj) {
              this._inner.splice(i, 1);
              break;
            }
          }
        }
      };
      return Memo2;
    }();
    exports2.Memo = Memo;
  }
});

// node_modules/@sentry/utils/dist/stacktrace.js
var require_stacktrace = __commonJS({
  "node_modules/@sentry/utils/dist/stacktrace.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var defaultFunctionName = "<anonymous>";
    function getFunctionName(fn) {
      try {
        if (!fn || typeof fn !== "function") {
          return defaultFunctionName;
        }
        return fn.name || defaultFunctionName;
      } catch (e) {
        return defaultFunctionName;
      }
    }
    exports2.getFunctionName = getFunctionName;
  }
});

// node_modules/@sentry/utils/dist/string.js
var require_string = __commonJS({
  "node_modules/@sentry/utils/dist/string.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var is_1 = require_is();
    function truncate(str, max) {
      if (max === void 0) {
        max = 0;
      }
      if (typeof str !== "string" || max === 0) {
        return str;
      }
      return str.length <= max ? str : str.substr(0, max) + "...";
    }
    exports2.truncate = truncate;
    function snipLine(line, colno) {
      var newLine = line;
      var ll = newLine.length;
      if (ll <= 150) {
        return newLine;
      }
      if (colno > ll) {
        colno = ll;
      }
      var start = Math.max(colno - 60, 0);
      if (start < 5) {
        start = 0;
      }
      var end = Math.min(start + 140, ll);
      if (end > ll - 5) {
        end = ll;
      }
      if (end === ll) {
        start = Math.max(end - 140, 0);
      }
      newLine = newLine.slice(start, end);
      if (start > 0) {
        newLine = "'{snip} " + newLine;
      }
      if (end < ll) {
        newLine += " {snip}";
      }
      return newLine;
    }
    exports2.snipLine = snipLine;
    function safeJoin(input, delimiter) {
      if (!Array.isArray(input)) {
        return "";
      }
      var output = [];
      for (var i = 0; i < input.length; i++) {
        var value = input[i];
        try {
          output.push(String(value));
        } catch (e) {
          output.push("[value cannot be serialized]");
        }
      }
      return output.join(delimiter);
    }
    exports2.safeJoin = safeJoin;
    function isMatchingPattern(value, pattern) {
      if (!is_1.isString(value)) {
        return false;
      }
      if (is_1.isRegExp(pattern)) {
        return pattern.test(value);
      }
      if (typeof pattern === "string") {
        return value.indexOf(pattern) !== -1;
      }
      return false;
    }
    exports2.isMatchingPattern = isMatchingPattern;
    function escapeStringForRegex(regexString) {
      return regexString.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    }
    exports2.escapeStringForRegex = escapeStringForRegex;
  }
});

// node_modules/@sentry/utils/dist/object.js
var require_object = __commonJS({
  "node_modules/@sentry/utils/dist/object.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var browser_1 = require_browser();
    var is_1 = require_is();
    var memo_1 = require_memo();
    var stacktrace_1 = require_stacktrace();
    var string_1 = require_string();
    function fill(source, name, replacementFactory) {
      if (!(name in source)) {
        return;
      }
      var original = source[name];
      var wrapped = replacementFactory(original);
      if (typeof wrapped === "function") {
        try {
          wrapped.prototype = wrapped.prototype || {};
          Object.defineProperties(wrapped, {
            __sentry_original__: {
              enumerable: false,
              value: original
            }
          });
        } catch (_Oo) {
        }
      }
      source[name] = wrapped;
    }
    exports2.fill = fill;
    function urlEncode(object) {
      return Object.keys(object).map(function(key) {
        return encodeURIComponent(key) + "=" + encodeURIComponent(object[key]);
      }).join("&");
    }
    exports2.urlEncode = urlEncode;
    function getWalkSource(value) {
      if (is_1.isError(value)) {
        var error2 = value;
        var err = {
          message: error2.message,
          name: error2.name,
          stack: error2.stack
        };
        for (var i in error2) {
          if (Object.prototype.hasOwnProperty.call(error2, i)) {
            err[i] = error2[i];
          }
        }
        return err;
      }
      if (is_1.isEvent(value)) {
        var event_1 = value;
        var source = {};
        source.type = event_1.type;
        try {
          source.target = is_1.isElement(event_1.target) ? browser_1.htmlTreeAsString(event_1.target) : Object.prototype.toString.call(event_1.target);
        } catch (_oO) {
          source.target = "<unknown>";
        }
        try {
          source.currentTarget = is_1.isElement(event_1.currentTarget) ? browser_1.htmlTreeAsString(event_1.currentTarget) : Object.prototype.toString.call(event_1.currentTarget);
        } catch (_oO) {
          source.currentTarget = "<unknown>";
        }
        if (typeof CustomEvent !== "undefined" && is_1.isInstanceOf(value, CustomEvent)) {
          source.detail = event_1.detail;
        }
        for (var attr in event_1) {
          if (Object.prototype.hasOwnProperty.call(event_1, attr)) {
            source[attr] = event_1[attr];
          }
        }
        return source;
      }
      return value;
    }
    function utf8Length(value) {
      return ~-encodeURI(value).split(/%..|./).length;
    }
    function jsonSize(value) {
      return utf8Length(JSON.stringify(value));
    }
    function normalizeToSize(object, depth, maxSize) {
      if (depth === void 0) {
        depth = 3;
      }
      if (maxSize === void 0) {
        maxSize = 100 * 1024;
      }
      var serialized = normalize(object, depth);
      if (jsonSize(serialized) > maxSize) {
        return normalizeToSize(object, depth - 1, maxSize);
      }
      return serialized;
    }
    exports2.normalizeToSize = normalizeToSize;
    function serializeValue(value) {
      var type = Object.prototype.toString.call(value);
      if (typeof value === "string") {
        return value;
      }
      if (type === "[object Object]") {
        return "[Object]";
      }
      if (type === "[object Array]") {
        return "[Array]";
      }
      var normalized = normalizeValue(value);
      return is_1.isPrimitive(normalized) ? normalized : type;
    }
    function normalizeValue(value, key) {
      if (key === "domain" && value && typeof value === "object" && value._events) {
        return "[Domain]";
      }
      if (key === "domainEmitter") {
        return "[DomainEmitter]";
      }
      if (typeof global !== "undefined" && value === global) {
        return "[Global]";
      }
      if (typeof window !== "undefined" && value === window) {
        return "[Window]";
      }
      if (typeof document !== "undefined" && value === document) {
        return "[Document]";
      }
      if (is_1.isSyntheticEvent(value)) {
        return "[SyntheticEvent]";
      }
      if (typeof value === "number" && value !== value) {
        return "[NaN]";
      }
      if (value === void 0) {
        return "[undefined]";
      }
      if (typeof value === "function") {
        return "[Function: " + stacktrace_1.getFunctionName(value) + "]";
      }
      if (typeof value === "symbol") {
        return "[" + String(value) + "]";
      }
      if (typeof value === "bigint") {
        return "[BigInt: " + String(value) + "]";
      }
      return value;
    }
    function walk(key, value, depth, memo) {
      if (depth === void 0) {
        depth = Infinity;
      }
      if (memo === void 0) {
        memo = new memo_1.Memo();
      }
      if (depth === 0) {
        return serializeValue(value);
      }
      if (value !== null && value !== void 0 && typeof value.toJSON === "function") {
        return value.toJSON();
      }
      var normalized = normalizeValue(value, key);
      if (is_1.isPrimitive(normalized)) {
        return normalized;
      }
      var source = getWalkSource(value);
      var acc = Array.isArray(value) ? [] : {};
      if (memo.memoize(value)) {
        return "[Circular ~]";
      }
      for (var innerKey in source) {
        if (!Object.prototype.hasOwnProperty.call(source, innerKey)) {
          continue;
        }
        acc[innerKey] = walk(innerKey, source[innerKey], depth - 1, memo);
      }
      memo.unmemoize(value);
      return acc;
    }
    exports2.walk = walk;
    function normalize(input, depth) {
      try {
        return JSON.parse(JSON.stringify(input, function(key, value) {
          return walk(key, value, depth);
        }));
      } catch (_oO) {
        return "**non-serializable**";
      }
    }
    exports2.normalize = normalize;
    function extractExceptionKeysForMessage(exception, maxLength) {
      if (maxLength === void 0) {
        maxLength = 40;
      }
      var keys = Object.keys(getWalkSource(exception));
      keys.sort();
      if (!keys.length) {
        return "[object has no keys]";
      }
      if (keys[0].length >= maxLength) {
        return string_1.truncate(keys[0], maxLength);
      }
      for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {
        var serialized = keys.slice(0, includedKeys).join(", ");
        if (serialized.length > maxLength) {
          continue;
        }
        if (includedKeys === keys.length) {
          return serialized;
        }
        return string_1.truncate(serialized, maxLength);
      }
      return "";
    }
    exports2.extractExceptionKeysForMessage = extractExceptionKeysForMessage;
    function dropUndefinedKeys(val) {
      var e_1, _a;
      if (is_1.isPlainObject(val)) {
        var obj = val;
        var rv = {};
        try {
          for (var _b = tslib_1.__values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            if (typeof obj[key] !== "undefined") {
              rv[key] = dropUndefinedKeys(obj[key]);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return rv;
      }
      if (Array.isArray(val)) {
        return val.map(dropUndefinedKeys);
      }
      return val;
    }
    exports2.dropUndefinedKeys = dropUndefinedKeys;
    function objectify(wat) {
      var objectified;
      switch (true) {
        case (wat === void 0 || wat === null):
          objectified = new String(wat);
          break;
        case (typeof wat === "symbol" || typeof wat === "bigint"):
          objectified = Object(wat);
          break;
        case is_1.isPrimitive(wat):
          objectified = new wat.constructor(wat);
          break;
        default:
          objectified = wat;
          break;
      }
      return objectified;
    }
    exports2.objectify = objectify;
  }
});

// node_modules/@sentry/utils/dist/supports.js
var require_supports = __commonJS({
  "node_modules/@sentry/utils/dist/supports.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var global_1 = require_global();
    var logger_1 = require_logger();
    function supportsErrorEvent() {
      try {
        new ErrorEvent("");
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.supportsErrorEvent = supportsErrorEvent;
    function supportsDOMError() {
      try {
        new DOMError("");
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.supportsDOMError = supportsDOMError;
    function supportsDOMException() {
      try {
        new DOMException("");
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.supportsDOMException = supportsDOMException;
    function supportsFetch() {
      if (!("fetch" in global_1.getGlobalObject())) {
        return false;
      }
      try {
        new Headers();
        new Request("");
        new Response();
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.supportsFetch = supportsFetch;
    function isNativeFetch(func) {
      return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
    }
    exports2.isNativeFetch = isNativeFetch;
    function supportsNativeFetch() {
      if (!supportsFetch()) {
        return false;
      }
      var global2 = global_1.getGlobalObject();
      if (isNativeFetch(global2.fetch)) {
        return true;
      }
      var result = false;
      var doc = global2.document;
      if (doc && typeof doc.createElement === "function") {
        try {
          var sandbox = doc.createElement("iframe");
          sandbox.hidden = true;
          doc.head.appendChild(sandbox);
          if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
            result = isNativeFetch(sandbox.contentWindow.fetch);
          }
          doc.head.removeChild(sandbox);
        } catch (err) {
          logger_1.logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
        }
      }
      return result;
    }
    exports2.supportsNativeFetch = supportsNativeFetch;
    function supportsReportingObserver() {
      return "ReportingObserver" in global_1.getGlobalObject();
    }
    exports2.supportsReportingObserver = supportsReportingObserver;
    function supportsReferrerPolicy() {
      if (!supportsFetch()) {
        return false;
      }
      try {
        new Request("_", {
          referrerPolicy: "origin"
        });
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.supportsReferrerPolicy = supportsReferrerPolicy;
    function supportsHistory() {
      var global2 = global_1.getGlobalObject();
      var chrome = global2.chrome;
      var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
      var hasHistoryApi = "history" in global2 && !!global2.history.pushState && !!global2.history.replaceState;
      return !isChromePackagedApp && hasHistoryApi;
    }
    exports2.supportsHistory = supportsHistory;
  }
});

// node_modules/@sentry/utils/dist/instrument.js
var require_instrument = __commonJS({
  "node_modules/@sentry/utils/dist/instrument.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var global_1 = require_global();
    var is_1 = require_is();
    var logger_1 = require_logger();
    var object_1 = require_object();
    var stacktrace_1 = require_stacktrace();
    var supports_1 = require_supports();
    var global2 = global_1.getGlobalObject();
    var handlers = {};
    var instrumented = {};
    function instrument(type) {
      if (instrumented[type]) {
        return;
      }
      instrumented[type] = true;
      switch (type) {
        case "console":
          instrumentConsole();
          break;
        case "dom":
          instrumentDOM();
          break;
        case "xhr":
          instrumentXHR();
          break;
        case "fetch":
          instrumentFetch();
          break;
        case "history":
          instrumentHistory();
          break;
        case "error":
          instrumentError();
          break;
        case "unhandledrejection":
          instrumentUnhandledRejection();
          break;
        default:
          logger_1.logger.warn("unknown instrumentation type:", type);
      }
    }
    function addInstrumentationHandler(handler) {
      if (!handler || typeof handler.type !== "string" || typeof handler.callback !== "function") {
        return;
      }
      handlers[handler.type] = handlers[handler.type] || [];
      handlers[handler.type].push(handler.callback);
      instrument(handler.type);
    }
    exports2.addInstrumentationHandler = addInstrumentationHandler;
    function triggerHandlers(type, data) {
      var e_1, _a;
      if (!type || !handlers[type]) {
        return;
      }
      try {
        for (var _b = tslib_1.__values(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {
          var handler = _c.value;
          try {
            handler(data);
          } catch (e) {
            logger_1.logger.error("Error while triggering instrumentation handler.\nType: " + type + "\nName: " + stacktrace_1.getFunctionName(handler) + "\nError: " + e);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    function instrumentConsole() {
      if (!("console" in global2)) {
        return;
      }
      ["debug", "info", "warn", "error", "log", "assert"].forEach(function(level) {
        if (!(level in global2.console)) {
          return;
        }
        object_1.fill(global2.console, level, function(originalConsoleLevel) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            triggerHandlers("console", { args, level });
            if (originalConsoleLevel) {
              Function.prototype.apply.call(originalConsoleLevel, global2.console, args);
            }
          };
        });
      });
    }
    function instrumentFetch() {
      if (!supports_1.supportsNativeFetch()) {
        return;
      }
      object_1.fill(global2, "fetch", function(originalFetch) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var handlerData = {
            args,
            fetchData: {
              method: getFetchMethod(args),
              url: getFetchUrl(args)
            },
            startTimestamp: Date.now()
          };
          triggerHandlers("fetch", tslib_1.__assign({}, handlerData));
          return originalFetch.apply(global2, args).then(function(response) {
            triggerHandlers("fetch", tslib_1.__assign(tslib_1.__assign({}, handlerData), { endTimestamp: Date.now(), response }));
            return response;
          }, function(error2) {
            triggerHandlers("fetch", tslib_1.__assign(tslib_1.__assign({}, handlerData), { endTimestamp: Date.now(), error: error2 }));
            throw error2;
          });
        };
      });
    }
    function getFetchMethod(fetchArgs) {
      if (fetchArgs === void 0) {
        fetchArgs = [];
      }
      if ("Request" in global2 && is_1.isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {
        return String(fetchArgs[0].method).toUpperCase();
      }
      if (fetchArgs[1] && fetchArgs[1].method) {
        return String(fetchArgs[1].method).toUpperCase();
      }
      return "GET";
    }
    function getFetchUrl(fetchArgs) {
      if (fetchArgs === void 0) {
        fetchArgs = [];
      }
      if (typeof fetchArgs[0] === "string") {
        return fetchArgs[0];
      }
      if ("Request" in global2 && is_1.isInstanceOf(fetchArgs[0], Request)) {
        return fetchArgs[0].url;
      }
      return String(fetchArgs[0]);
    }
    function instrumentXHR() {
      if (!("XMLHttpRequest" in global2)) {
        return;
      }
      var requestKeys = [];
      var requestValues = [];
      var xhrproto = XMLHttpRequest.prototype;
      object_1.fill(xhrproto, "open", function(originalOpen) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var xhr = this;
          var url = args[1];
          xhr.__sentry_xhr__ = {
            method: is_1.isString(args[0]) ? args[0].toUpperCase() : args[0],
            url: args[1]
          };
          if (is_1.isString(url) && xhr.__sentry_xhr__.method === "POST" && url.match(/sentry_key/)) {
            xhr.__sentry_own_request__ = true;
          }
          var onreadystatechangeHandler = function() {
            if (xhr.readyState === 4) {
              try {
                if (xhr.__sentry_xhr__) {
                  xhr.__sentry_xhr__.status_code = xhr.status;
                }
              } catch (e) {
              }
              try {
                var requestPos = requestKeys.indexOf(xhr);
                if (requestPos !== -1) {
                  requestKeys.splice(requestPos);
                  var args_1 = requestValues.splice(requestPos)[0];
                  if (xhr.__sentry_xhr__ && args_1[0] !== void 0) {
                    xhr.__sentry_xhr__.body = args_1[0];
                  }
                }
              } catch (e) {
              }
              triggerHandlers("xhr", {
                args,
                endTimestamp: Date.now(),
                startTimestamp: Date.now(),
                xhr
              });
            }
          };
          if ("onreadystatechange" in xhr && typeof xhr.onreadystatechange === "function") {
            object_1.fill(xhr, "onreadystatechange", function(original) {
              return function() {
                var readyStateArgs = [];
                for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                  readyStateArgs[_i2] = arguments[_i2];
                }
                onreadystatechangeHandler();
                return original.apply(xhr, readyStateArgs);
              };
            });
          } else {
            xhr.addEventListener("readystatechange", onreadystatechangeHandler);
          }
          return originalOpen.apply(xhr, args);
        };
      });
      object_1.fill(xhrproto, "send", function(originalSend) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          requestKeys.push(this);
          requestValues.push(args);
          triggerHandlers("xhr", {
            args,
            startTimestamp: Date.now(),
            xhr: this
          });
          return originalSend.apply(this, args);
        };
      });
    }
    var lastHref;
    function instrumentHistory() {
      if (!supports_1.supportsHistory()) {
        return;
      }
      var oldOnPopState = global2.onpopstate;
      global2.onpopstate = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var to = global2.location.href;
        var from = lastHref;
        lastHref = to;
        triggerHandlers("history", {
          from,
          to
        });
        if (oldOnPopState) {
          try {
            return oldOnPopState.apply(this, args);
          } catch (_oO) {
          }
        }
      };
      function historyReplacementFunction(originalHistoryFunction) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var url = args.length > 2 ? args[2] : void 0;
          if (url) {
            var from = lastHref;
            var to = String(url);
            lastHref = to;
            triggerHandlers("history", {
              from,
              to
            });
          }
          return originalHistoryFunction.apply(this, args);
        };
      }
      object_1.fill(global2.history, "pushState", historyReplacementFunction);
      object_1.fill(global2.history, "replaceState", historyReplacementFunction);
    }
    var debounceDuration = 1e3;
    var debounceTimerID;
    var lastCapturedEvent;
    function shouldShortcircuitPreviousDebounce(previous, current) {
      if (!previous) {
        return true;
      }
      if (previous.type !== current.type) {
        return true;
      }
      try {
        if (previous.target !== current.target) {
          return true;
        }
      } catch (e) {
      }
      return false;
    }
    function shouldSkipDOMEvent(event) {
      if (event.type !== "keypress") {
        return false;
      }
      try {
        var target = event.target;
        if (!target || !target.tagName) {
          return true;
        }
        if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
          return false;
        }
      } catch (e) {
      }
      return true;
    }
    function makeDOMEventHandler(handler, globalListener) {
      if (globalListener === void 0) {
        globalListener = false;
      }
      return function(event) {
        if (!event || lastCapturedEvent === event) {
          return;
        }
        if (shouldSkipDOMEvent(event)) {
          return;
        }
        var name = event.type === "keypress" ? "input" : event.type;
        if (debounceTimerID === void 0) {
          handler({
            event,
            name,
            global: globalListener
          });
          lastCapturedEvent = event;
        } else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
          handler({
            event,
            name,
            global: globalListener
          });
          lastCapturedEvent = event;
        }
        clearTimeout(debounceTimerID);
        debounceTimerID = global2.setTimeout(function() {
          debounceTimerID = void 0;
        }, debounceDuration);
      };
    }
    function instrumentDOM() {
      if (!("document" in global2)) {
        return;
      }
      var triggerDOMHandler = triggerHandlers.bind(null, "dom");
      var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
      global2.document.addEventListener("click", globalDOMEventHandler, false);
      global2.document.addEventListener("keypress", globalDOMEventHandler, false);
      ["EventTarget", "Node"].forEach(function(target) {
        var proto = global2[target] && global2[target].prototype;
        if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
          return;
        }
        object_1.fill(proto, "addEventListener", function(originalAddEventListener) {
          return function(type, listener, options) {
            if (type === "click" || type == "keypress") {
              try {
                var el = this;
                var handlers_1 = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};
                var handlerForType = handlers_1[type] = handlers_1[type] || { refCount: 0 };
                if (!handlerForType.handler) {
                  var handler = makeDOMEventHandler(triggerDOMHandler);
                  handlerForType.handler = handler;
                  originalAddEventListener.call(this, type, handler, options);
                }
                handlerForType.refCount += 1;
              } catch (e) {
              }
            }
            return originalAddEventListener.call(this, type, listener, options);
          };
        });
        object_1.fill(proto, "removeEventListener", function(originalRemoveEventListener) {
          return function(type, listener, options) {
            if (type === "click" || type == "keypress") {
              try {
                var el = this;
                var handlers_2 = el.__sentry_instrumentation_handlers__ || {};
                var handlerForType = handlers_2[type];
                if (handlerForType) {
                  handlerForType.refCount -= 1;
                  if (handlerForType.refCount <= 0) {
                    originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                    handlerForType.handler = void 0;
                    delete handlers_2[type];
                  }
                  if (Object.keys(handlers_2).length === 0) {
                    delete el.__sentry_instrumentation_handlers__;
                  }
                }
              } catch (e) {
              }
            }
            return originalRemoveEventListener.call(this, type, listener, options);
          };
        });
      });
    }
    var _oldOnErrorHandler = null;
    function instrumentError() {
      _oldOnErrorHandler = global2.onerror;
      global2.onerror = function(msg, url, line, column, error2) {
        triggerHandlers("error", {
          column,
          error: error2,
          line,
          msg,
          url
        });
        if (_oldOnErrorHandler) {
          return _oldOnErrorHandler.apply(this, arguments);
        }
        return false;
      };
    }
    var _oldOnUnhandledRejectionHandler = null;
    function instrumentUnhandledRejection() {
      _oldOnUnhandledRejectionHandler = global2.onunhandledrejection;
      global2.onunhandledrejection = function(e) {
        triggerHandlers("unhandledrejection", e);
        if (_oldOnUnhandledRejectionHandler) {
          return _oldOnUnhandledRejectionHandler.apply(this, arguments);
        }
        return true;
      };
    }
  }
});

// node_modules/@sentry/utils/dist/misc.js
var require_misc = __commonJS({
  "node_modules/@sentry/utils/dist/misc.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var global_1 = require_global();
    var string_1 = require_string();
    function uuid4() {
      var global2 = global_1.getGlobalObject();
      var crypto = global2.crypto || global2.msCrypto;
      if (!(crypto === void 0) && crypto.getRandomValues) {
        var arr = new Uint16Array(8);
        crypto.getRandomValues(arr);
        arr[3] = arr[3] & 4095 | 16384;
        arr[4] = arr[4] & 16383 | 32768;
        var pad = function(num) {
          var v = num.toString(16);
          while (v.length < 4) {
            v = "0" + v;
          }
          return v;
        };
        return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
      }
      return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0;
        var v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }
    exports2.uuid4 = uuid4;
    function parseUrl(url) {
      if (!url) {
        return {};
      }
      var match2 = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
      if (!match2) {
        return {};
      }
      var query = match2[6] || "";
      var fragment = match2[8] || "";
      return {
        host: match2[4],
        path: match2[5],
        protocol: match2[2],
        relative: match2[5] + query + fragment
      };
    }
    exports2.parseUrl = parseUrl;
    function getEventDescription(event) {
      if (event.message) {
        return event.message;
      }
      if (event.exception && event.exception.values && event.exception.values[0]) {
        var exception = event.exception.values[0];
        if (exception.type && exception.value) {
          return exception.type + ": " + exception.value;
        }
        return exception.type || exception.value || event.event_id || "<unknown>";
      }
      return event.event_id || "<unknown>";
    }
    exports2.getEventDescription = getEventDescription;
    function addExceptionTypeValue(event, value, type) {
      event.exception = event.exception || {};
      event.exception.values = event.exception.values || [];
      event.exception.values[0] = event.exception.values[0] || {};
      event.exception.values[0].value = event.exception.values[0].value || value || "";
      event.exception.values[0].type = event.exception.values[0].type || type || "Error";
    }
    exports2.addExceptionTypeValue = addExceptionTypeValue;
    function addExceptionMechanism(event, newMechanism) {
      var _a;
      if (!event.exception || !event.exception.values) {
        return;
      }
      var exceptionValue0 = event.exception.values[0];
      var defaultMechanism = { type: "generic", handled: true };
      var currentMechanism = exceptionValue0.mechanism;
      exceptionValue0.mechanism = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, defaultMechanism), currentMechanism), newMechanism);
      if (newMechanism && "data" in newMechanism) {
        var mergedData = tslib_1.__assign(tslib_1.__assign({}, (_a = currentMechanism) === null || _a === void 0 ? void 0 : _a.data), newMechanism.data);
        exceptionValue0.mechanism.data = mergedData;
      }
    }
    exports2.addExceptionMechanism = addExceptionMechanism;
    var SEMVER_REGEXP = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
    function parseSemver(input) {
      var match2 = input.match(SEMVER_REGEXP) || [];
      var major = parseInt(match2[1], 10);
      var minor = parseInt(match2[2], 10);
      var patch = parseInt(match2[3], 10);
      return {
        buildmetadata: match2[5],
        major: isNaN(major) ? void 0 : major,
        minor: isNaN(minor) ? void 0 : minor,
        patch: isNaN(patch) ? void 0 : patch,
        prerelease: match2[4]
      };
    }
    exports2.parseSemver = parseSemver;
    var defaultRetryAfter = 60 * 1e3;
    function parseRetryAfterHeader(now, header) {
      if (!header) {
        return defaultRetryAfter;
      }
      var headerDelay = parseInt("" + header, 10);
      if (!isNaN(headerDelay)) {
        return headerDelay * 1e3;
      }
      var headerDate = Date.parse("" + header);
      if (!isNaN(headerDate)) {
        return headerDate - now;
      }
      return defaultRetryAfter;
    }
    exports2.parseRetryAfterHeader = parseRetryAfterHeader;
    function addContextToFrame(lines, frame, linesOfContext) {
      if (linesOfContext === void 0) {
        linesOfContext = 5;
      }
      var lineno = frame.lineno || 0;
      var maxLines = lines.length;
      var sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);
      frame.pre_context = lines.slice(Math.max(0, sourceLine - linesOfContext), sourceLine).map(function(line) {
        return string_1.snipLine(line, 0);
      });
      frame.context_line = string_1.snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);
      frame.post_context = lines.slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext).map(function(line) {
        return string_1.snipLine(line, 0);
      });
    }
    exports2.addContextToFrame = addContextToFrame;
    function stripUrlQueryAndFragment(urlPath) {
      return urlPath.split(/[\?#]/, 1)[0];
    }
    exports2.stripUrlQueryAndFragment = stripUrlQueryAndFragment;
    function checkOrSetAlreadyCaught(exception) {
      var _a;
      if ((_a = exception) === null || _a === void 0 ? void 0 : _a.__sentry_captured__) {
        return true;
      }
      try {
        Object.defineProperty(exception, "__sentry_captured__", {
          value: true
        });
      } catch (err) {
      }
      return false;
    }
    exports2.checkOrSetAlreadyCaught = checkOrSetAlreadyCaught;
  }
});

// node_modules/@sentry/utils/dist/path.js
var require_path = __commonJS({
  "node_modules/@sentry/utils/dist/path.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    function normalizeArray(parts, allowAboveRoot) {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift("..");
        }
      }
      return parts;
    }
    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^/]+?|)(\.[^./]*|))(?:[/]*)$/;
    function splitPath(filename) {
      var parts = splitPathRe.exec(filename);
      return parts ? parts.slice(1) : [];
    }
    function resolve() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resolvedPath = "";
      var resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args[i] : "/";
        if (!path) {
          continue;
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = path.charAt(0) === "/";
      }
      resolvedPath = normalizeArray(resolvedPath.split("/").filter(function(p) {
        return !!p;
      }), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    }
    exports2.resolve = resolve;
    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== "") {
          break;
        }
      }
      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== "") {
          break;
        }
      }
      if (start > end) {
        return [];
      }
      return arr.slice(start, end - start + 1);
    }
    function relative(from, to) {
      from = resolve(from).substr(1);
      to = resolve(to).substr(1);
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
    exports2.relative = relative;
    function normalizePath(path) {
      var isPathAbsolute = isAbsolute(path);
      var trailingSlash = path.substr(-1) === "/";
      var normalizedPath = normalizeArray(path.split("/").filter(function(p) {
        return !!p;
      }), !isPathAbsolute).join("/");
      if (!normalizedPath && !isPathAbsolute) {
        normalizedPath = ".";
      }
      if (normalizedPath && trailingSlash) {
        normalizedPath += "/";
      }
      return (isPathAbsolute ? "/" : "") + normalizedPath;
    }
    exports2.normalizePath = normalizePath;
    function isAbsolute(path) {
      return path.charAt(0) === "/";
    }
    exports2.isAbsolute = isAbsolute;
    function join() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return normalizePath(args.join("/"));
    }
    exports2.join = join;
    function dirname(path) {
      var result = splitPath(path);
      var root = result[0];
      var dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    }
    exports2.dirname = dirname;
    function basename(path, ext) {
      var f = splitPath(path)[2];
      if (ext && f.substr(ext.length * -1) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    }
    exports2.basename = basename;
  }
});

// node_modules/@sentry/utils/dist/syncpromise.js
var require_syncpromise = __commonJS({
  "node_modules/@sentry/utils/dist/syncpromise.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var is_1 = require_is();
    var States;
    (function(States2) {
      States2["PENDING"] = "PENDING";
      States2["RESOLVED"] = "RESOLVED";
      States2["REJECTED"] = "REJECTED";
    })(States || (States = {}));
    var SyncPromise = function() {
      function SyncPromise2(executor) {
        var _this = this;
        this._state = States.PENDING;
        this._handlers = [];
        this._resolve = function(value) {
          _this._setResult(States.RESOLVED, value);
        };
        this._reject = function(reason) {
          _this._setResult(States.REJECTED, reason);
        };
        this._setResult = function(state, value) {
          if (_this._state !== States.PENDING) {
            return;
          }
          if (is_1.isThenable(value)) {
            void value.then(_this._resolve, _this._reject);
            return;
          }
          _this._state = state;
          _this._value = value;
          _this._executeHandlers();
        };
        this._attachHandler = function(handler) {
          _this._handlers = _this._handlers.concat(handler);
          _this._executeHandlers();
        };
        this._executeHandlers = function() {
          if (_this._state === States.PENDING) {
            return;
          }
          var cachedHandlers = _this._handlers.slice();
          _this._handlers = [];
          cachedHandlers.forEach(function(handler) {
            if (handler.done) {
              return;
            }
            if (_this._state === States.RESOLVED) {
              if (handler.onfulfilled) {
                handler.onfulfilled(_this._value);
              }
            }
            if (_this._state === States.REJECTED) {
              if (handler.onrejected) {
                handler.onrejected(_this._value);
              }
            }
            handler.done = true;
          });
        };
        try {
          executor(this._resolve, this._reject);
        } catch (e) {
          this._reject(e);
        }
      }
      SyncPromise2.resolve = function(value) {
        return new SyncPromise2(function(resolve) {
          resolve(value);
        });
      };
      SyncPromise2.reject = function(reason) {
        return new SyncPromise2(function(_, reject) {
          reject(reason);
        });
      };
      SyncPromise2.all = function(collection) {
        return new SyncPromise2(function(resolve, reject) {
          if (!Array.isArray(collection)) {
            reject(new TypeError("Promise.all requires an array as input."));
            return;
          }
          if (collection.length === 0) {
            resolve([]);
            return;
          }
          var counter = collection.length;
          var resolvedCollection = [];
          collection.forEach(function(item, index) {
            void SyncPromise2.resolve(item).then(function(value) {
              resolvedCollection[index] = value;
              counter -= 1;
              if (counter !== 0) {
                return;
              }
              resolve(resolvedCollection);
            }).then(null, reject);
          });
        });
      };
      SyncPromise2.prototype.then = function(onfulfilled, onrejected) {
        var _this = this;
        return new SyncPromise2(function(resolve, reject) {
          _this._attachHandler({
            done: false,
            onfulfilled: function(result) {
              if (!onfulfilled) {
                resolve(result);
                return;
              }
              try {
                resolve(onfulfilled(result));
                return;
              } catch (e) {
                reject(e);
                return;
              }
            },
            onrejected: function(reason) {
              if (!onrejected) {
                reject(reason);
                return;
              }
              try {
                resolve(onrejected(reason));
                return;
              } catch (e) {
                reject(e);
                return;
              }
            }
          });
        });
      };
      SyncPromise2.prototype.catch = function(onrejected) {
        return this.then(function(val) {
          return val;
        }, onrejected);
      };
      SyncPromise2.prototype.finally = function(onfinally) {
        var _this = this;
        return new SyncPromise2(function(resolve, reject) {
          var val;
          var isRejected;
          return _this.then(function(value) {
            isRejected = false;
            val = value;
            if (onfinally) {
              onfinally();
            }
          }, function(reason) {
            isRejected = true;
            val = reason;
            if (onfinally) {
              onfinally();
            }
          }).then(function() {
            if (isRejected) {
              reject(val);
              return;
            }
            resolve(val);
          });
        });
      };
      SyncPromise2.prototype.toString = function() {
        return "[object SyncPromise]";
      };
      return SyncPromise2;
    }();
    exports2.SyncPromise = SyncPromise;
  }
});

// node_modules/@sentry/utils/dist/promisebuffer.js
var require_promisebuffer = __commonJS({
  "node_modules/@sentry/utils/dist/promisebuffer.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var error_1 = require_error();
    var syncpromise_1 = require_syncpromise();
    var PromiseBuffer = function() {
      function PromiseBuffer2(_limit) {
        this._limit = _limit;
        this._buffer = [];
      }
      PromiseBuffer2.prototype.isReady = function() {
        return this._limit === void 0 || this.length() < this._limit;
      };
      PromiseBuffer2.prototype.add = function(taskProducer) {
        var _this = this;
        if (!this.isReady()) {
          return syncpromise_1.SyncPromise.reject(new error_1.SentryError("Not adding Promise due to buffer limit reached."));
        }
        var task = taskProducer();
        if (this._buffer.indexOf(task) === -1) {
          this._buffer.push(task);
        }
        void task.then(function() {
          return _this.remove(task);
        }).then(null, function() {
          return _this.remove(task).then(null, function() {
          });
        });
        return task;
      };
      PromiseBuffer2.prototype.remove = function(task) {
        var removedTask = this._buffer.splice(this._buffer.indexOf(task), 1)[0];
        return removedTask;
      };
      PromiseBuffer2.prototype.length = function() {
        return this._buffer.length;
      };
      PromiseBuffer2.prototype.drain = function(timeout) {
        var _this = this;
        return new syncpromise_1.SyncPromise(function(resolve) {
          var capturedSetTimeout = setTimeout(function() {
            if (timeout && timeout > 0) {
              resolve(false);
            }
          }, timeout);
          void syncpromise_1.SyncPromise.all(_this._buffer).then(function() {
            clearTimeout(capturedSetTimeout);
            resolve(true);
          }).then(null, function() {
            resolve(true);
          });
        });
      };
      return PromiseBuffer2;
    }();
    exports2.PromiseBuffer = PromiseBuffer;
  }
});

// node_modules/@sentry/utils/dist/time.js
var require_time = __commonJS({
  "node_modules/@sentry/utils/dist/time.js"(exports2, module2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var global_1 = require_global();
    var node_1 = require_node();
    var dateTimestampSource = {
      nowSeconds: function() {
        return Date.now() / 1e3;
      }
    };
    function getBrowserPerformance() {
      var performance2 = global_1.getGlobalObject().performance;
      if (!performance2 || !performance2.now) {
        return void 0;
      }
      var timeOrigin = Date.now() - performance2.now();
      return {
        now: function() {
          return performance2.now();
        },
        timeOrigin
      };
    }
    function getNodePerformance() {
      try {
        var perfHooks = node_1.dynamicRequire(module2, "perf_hooks");
        return perfHooks.performance;
      } catch (_) {
        return void 0;
      }
    }
    var platformPerformance = node_1.isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
    var timestampSource = platformPerformance === void 0 ? dateTimestampSource : {
      nowSeconds: function() {
        return (platformPerformance.timeOrigin + platformPerformance.now()) / 1e3;
      }
    };
    exports2.dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
    exports2.timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
    exports2.timestampWithMs = exports2.timestampInSeconds;
    exports2.usingPerformanceAPI = platformPerformance !== void 0;
    exports2.browserPerformanceTimeOrigin = function() {
      var performance2 = global_1.getGlobalObject().performance;
      if (!performance2 || !performance2.now) {
        exports2._browserPerformanceTimeOriginMode = "none";
        return void 0;
      }
      var threshold = 3600 * 1e3;
      var performanceNow = performance2.now();
      var dateNow = Date.now();
      var timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;
      var timeOriginIsReliable = timeOriginDelta < threshold;
      var navigationStart = performance2.timing && performance2.timing.navigationStart;
      var hasNavigationStart = typeof navigationStart === "number";
      var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
      var navigationStartIsReliable = navigationStartDelta < threshold;
      if (timeOriginIsReliable || navigationStartIsReliable) {
        if (timeOriginDelta <= navigationStartDelta) {
          exports2._browserPerformanceTimeOriginMode = "timeOrigin";
          return performance2.timeOrigin;
        } else {
          exports2._browserPerformanceTimeOriginMode = "navigationStart";
          return navigationStart;
        }
      }
      exports2._browserPerformanceTimeOriginMode = "dateNow";
      return dateNow;
    }();
  }
});

// node_modules/@sentry/utils/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@sentry/utils/dist/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_async(), exports2);
    tslib_1.__exportStar(require_browser(), exports2);
    tslib_1.__exportStar(require_dsn(), exports2);
    tslib_1.__exportStar(require_error(), exports2);
    tslib_1.__exportStar(require_global(), exports2);
    tslib_1.__exportStar(require_instrument(), exports2);
    tslib_1.__exportStar(require_is(), exports2);
    tslib_1.__exportStar(require_logger(), exports2);
    tslib_1.__exportStar(require_memo(), exports2);
    tslib_1.__exportStar(require_misc(), exports2);
    tslib_1.__exportStar(require_node(), exports2);
    tslib_1.__exportStar(require_object(), exports2);
    tslib_1.__exportStar(require_path(), exports2);
    tslib_1.__exportStar(require_promisebuffer(), exports2);
    tslib_1.__exportStar(require_stacktrace(), exports2);
    tslib_1.__exportStar(require_string(), exports2);
    tslib_1.__exportStar(require_supports(), exports2);
    tslib_1.__exportStar(require_syncpromise(), exports2);
    tslib_1.__exportStar(require_time(), exports2);
  }
});

// node_modules/@sentry/hub/dist/scope.js
var require_scope = __commonJS({
  "node_modules/@sentry/hub/dist/scope.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var utils_1 = require_dist2();
    var MAX_BREADCRUMBS = 100;
    var Scope = function() {
      function Scope2() {
        this._notifyingListeners = false;
        this._scopeListeners = [];
        this._eventProcessors = [];
        this._breadcrumbs = [];
        this._user = {};
        this._tags = {};
        this._extra = {};
        this._contexts = {};
      }
      Scope2.clone = function(scope) {
        var newScope = new Scope2();
        if (scope) {
          newScope._breadcrumbs = tslib_1.__spread(scope._breadcrumbs);
          newScope._tags = tslib_1.__assign({}, scope._tags);
          newScope._extra = tslib_1.__assign({}, scope._extra);
          newScope._contexts = tslib_1.__assign({}, scope._contexts);
          newScope._user = scope._user;
          newScope._level = scope._level;
          newScope._span = scope._span;
          newScope._session = scope._session;
          newScope._transactionName = scope._transactionName;
          newScope._fingerprint = scope._fingerprint;
          newScope._eventProcessors = tslib_1.__spread(scope._eventProcessors);
          newScope._requestSession = scope._requestSession;
        }
        return newScope;
      };
      Scope2.prototype.addScopeListener = function(callback) {
        this._scopeListeners.push(callback);
      };
      Scope2.prototype.addEventProcessor = function(callback) {
        this._eventProcessors.push(callback);
        return this;
      };
      Scope2.prototype.setUser = function(user) {
        this._user = user || {};
        if (this._session) {
          this._session.update({ user });
        }
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.getUser = function() {
        return this._user;
      };
      Scope2.prototype.getRequestSession = function() {
        return this._requestSession;
      };
      Scope2.prototype.setRequestSession = function(requestSession) {
        this._requestSession = requestSession;
        return this;
      };
      Scope2.prototype.setTags = function(tags) {
        this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), tags);
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setTag = function(key, value) {
        var _a;
        this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), (_a = {}, _a[key] = value, _a));
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setExtras = function(extras) {
        this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), extras);
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setExtra = function(key, extra) {
        var _a;
        this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), (_a = {}, _a[key] = extra, _a));
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setFingerprint = function(fingerprint) {
        this._fingerprint = fingerprint;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setLevel = function(level) {
        this._level = level;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setTransactionName = function(name) {
        this._transactionName = name;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setTransaction = function(name) {
        return this.setTransactionName(name);
      };
      Scope2.prototype.setContext = function(key, context) {
        var _a;
        if (context === null) {
          delete this._contexts[key];
        } else {
          this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), (_a = {}, _a[key] = context, _a));
        }
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setSpan = function(span) {
        this._span = span;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.getSpan = function() {
        return this._span;
      };
      Scope2.prototype.getTransaction = function() {
        var _a, _b, _c, _d;
        var span = this.getSpan();
        if ((_a = span) === null || _a === void 0 ? void 0 : _a.transaction) {
          return (_b = span) === null || _b === void 0 ? void 0 : _b.transaction;
        }
        if ((_d = (_c = span) === null || _c === void 0 ? void 0 : _c.spanRecorder) === null || _d === void 0 ? void 0 : _d.spans[0]) {
          return span.spanRecorder.spans[0];
        }
        return void 0;
      };
      Scope2.prototype.setSession = function(session) {
        if (!session) {
          delete this._session;
        } else {
          this._session = session;
        }
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.getSession = function() {
        return this._session;
      };
      Scope2.prototype.update = function(captureContext) {
        if (!captureContext) {
          return this;
        }
        if (typeof captureContext === "function") {
          var updatedScope = captureContext(this);
          return updatedScope instanceof Scope2 ? updatedScope : this;
        }
        if (captureContext instanceof Scope2) {
          this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), captureContext._tags);
          this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), captureContext._extra);
          this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), captureContext._contexts);
          if (captureContext._user && Object.keys(captureContext._user).length) {
            this._user = captureContext._user;
          }
          if (captureContext._level) {
            this._level = captureContext._level;
          }
          if (captureContext._fingerprint) {
            this._fingerprint = captureContext._fingerprint;
          }
          if (captureContext._requestSession) {
            this._requestSession = captureContext._requestSession;
          }
        } else if (utils_1.isPlainObject(captureContext)) {
          captureContext = captureContext;
          this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), captureContext.tags);
          this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), captureContext.extra);
          this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), captureContext.contexts);
          if (captureContext.user) {
            this._user = captureContext.user;
          }
          if (captureContext.level) {
            this._level = captureContext.level;
          }
          if (captureContext.fingerprint) {
            this._fingerprint = captureContext.fingerprint;
          }
          if (captureContext.requestSession) {
            this._requestSession = captureContext.requestSession;
          }
        }
        return this;
      };
      Scope2.prototype.clear = function() {
        this._breadcrumbs = [];
        this._tags = {};
        this._extra = {};
        this._user = {};
        this._contexts = {};
        this._level = void 0;
        this._transactionName = void 0;
        this._fingerprint = void 0;
        this._requestSession = void 0;
        this._span = void 0;
        this._session = void 0;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.addBreadcrumb = function(breadcrumb, maxBreadcrumbs) {
        var maxCrumbs = typeof maxBreadcrumbs === "number" ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;
        if (maxCrumbs <= 0) {
          return this;
        }
        var mergedBreadcrumb = tslib_1.__assign({ timestamp: utils_1.dateTimestampInSeconds() }, breadcrumb);
        this._breadcrumbs = tslib_1.__spread(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxCrumbs);
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.clearBreadcrumbs = function() {
        this._breadcrumbs = [];
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.applyToEvent = function(event, hint) {
        var _a;
        if (this._extra && Object.keys(this._extra).length) {
          event.extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), event.extra);
        }
        if (this._tags && Object.keys(this._tags).length) {
          event.tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), event.tags);
        }
        if (this._user && Object.keys(this._user).length) {
          event.user = tslib_1.__assign(tslib_1.__assign({}, this._user), event.user);
        }
        if (this._contexts && Object.keys(this._contexts).length) {
          event.contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), event.contexts);
        }
        if (this._level) {
          event.level = this._level;
        }
        if (this._transactionName) {
          event.transaction = this._transactionName;
        }
        if (this._span) {
          event.contexts = tslib_1.__assign({ trace: this._span.getTraceContext() }, event.contexts);
          var transactionName = (_a = this._span.transaction) === null || _a === void 0 ? void 0 : _a.name;
          if (transactionName) {
            event.tags = tslib_1.__assign({ transaction: transactionName }, event.tags);
          }
        }
        this._applyFingerprint(event);
        event.breadcrumbs = tslib_1.__spread(event.breadcrumbs || [], this._breadcrumbs);
        event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : void 0;
        return this._notifyEventProcessors(tslib_1.__spread(getGlobalEventProcessors(), this._eventProcessors), event, hint);
      };
      Scope2.prototype._notifyEventProcessors = function(processors, event, hint, index) {
        var _this = this;
        if (index === void 0) {
          index = 0;
        }
        return new utils_1.SyncPromise(function(resolve, reject) {
          var processor = processors[index];
          if (event === null || typeof processor !== "function") {
            resolve(event);
          } else {
            var result = processor(tslib_1.__assign({}, event), hint);
            if (utils_1.isThenable(result)) {
              void result.then(function(final) {
                return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve);
              }).then(null, reject);
            } else {
              void _this._notifyEventProcessors(processors, result, hint, index + 1).then(resolve).then(null, reject);
            }
          }
        });
      };
      Scope2.prototype._notifyScopeListeners = function() {
        var _this = this;
        if (!this._notifyingListeners) {
          this._notifyingListeners = true;
          this._scopeListeners.forEach(function(callback) {
            callback(_this);
          });
          this._notifyingListeners = false;
        }
      };
      Scope2.prototype._applyFingerprint = function(event) {
        event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : [];
        if (this._fingerprint) {
          event.fingerprint = event.fingerprint.concat(this._fingerprint);
        }
        if (event.fingerprint && !event.fingerprint.length) {
          delete event.fingerprint;
        }
      };
      return Scope2;
    }();
    exports2.Scope = Scope;
    function getGlobalEventProcessors() {
      var global2 = utils_1.getGlobalObject();
      global2.__SENTRY__ = global2.__SENTRY__ || {};
      global2.__SENTRY__.globalEventProcessors = global2.__SENTRY__.globalEventProcessors || [];
      return global2.__SENTRY__.globalEventProcessors;
    }
    function addGlobalEventProcessor(callback) {
      getGlobalEventProcessors().push(callback);
    }
    exports2.addGlobalEventProcessor = addGlobalEventProcessor;
  }
});

// node_modules/@sentry/hub/dist/session.js
var require_session2 = __commonJS({
  "node_modules/@sentry/hub/dist/session.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var Session = function() {
      function Session2(context) {
        this.errors = 0;
        this.sid = utils_1.uuid4();
        this.duration = 0;
        this.status = types_1.SessionStatus.Ok;
        this.init = true;
        this.ignoreDuration = false;
        var startingTime = utils_1.timestampInSeconds();
        this.timestamp = startingTime;
        this.started = startingTime;
        if (context) {
          this.update(context);
        }
      }
      Session2.prototype.update = function(context) {
        if (context === void 0) {
          context = {};
        }
        if (context.user) {
          if (!this.ipAddress && context.user.ip_address) {
            this.ipAddress = context.user.ip_address;
          }
          if (!this.did && !context.did) {
            this.did = context.user.id || context.user.email || context.user.username;
          }
        }
        this.timestamp = context.timestamp || utils_1.timestampInSeconds();
        if (context.ignoreDuration) {
          this.ignoreDuration = context.ignoreDuration;
        }
        if (context.sid) {
          this.sid = context.sid.length === 32 ? context.sid : utils_1.uuid4();
        }
        if (context.init !== void 0) {
          this.init = context.init;
        }
        if (!this.did && context.did) {
          this.did = "" + context.did;
        }
        if (typeof context.started === "number") {
          this.started = context.started;
        }
        if (this.ignoreDuration) {
          this.duration = void 0;
        } else if (typeof context.duration === "number") {
          this.duration = context.duration;
        } else {
          var duration = this.timestamp - this.started;
          this.duration = duration >= 0 ? duration : 0;
        }
        if (context.release) {
          this.release = context.release;
        }
        if (context.environment) {
          this.environment = context.environment;
        }
        if (!this.ipAddress && context.ipAddress) {
          this.ipAddress = context.ipAddress;
        }
        if (!this.userAgent && context.userAgent) {
          this.userAgent = context.userAgent;
        }
        if (typeof context.errors === "number") {
          this.errors = context.errors;
        }
        if (context.status) {
          this.status = context.status;
        }
      };
      Session2.prototype.close = function(status) {
        if (status) {
          this.update({ status });
        } else if (this.status === types_1.SessionStatus.Ok) {
          this.update({ status: types_1.SessionStatus.Exited });
        } else {
          this.update();
        }
      };
      Session2.prototype.toJSON = function() {
        return utils_1.dropUndefinedKeys({
          sid: "" + this.sid,
          init: this.init,
          started: new Date(this.started * 1e3).toISOString(),
          timestamp: new Date(this.timestamp * 1e3).toISOString(),
          status: this.status,
          errors: this.errors,
          did: typeof this.did === "number" || typeof this.did === "string" ? "" + this.did : void 0,
          duration: this.duration,
          attrs: utils_1.dropUndefinedKeys({
            release: this.release,
            environment: this.environment,
            ip_address: this.ipAddress,
            user_agent: this.userAgent
          })
        });
      };
      return Session2;
    }();
    exports2.Session = Session;
  }
});

// node_modules/@sentry/hub/dist/hub.js
var require_hub = __commonJS({
  "node_modules/@sentry/hub/dist/hub.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var scope_1 = require_scope();
    var session_1 = require_session2();
    exports2.API_VERSION = 4;
    var DEFAULT_BREADCRUMBS = 100;
    var Hub = function() {
      function Hub2(client, scope, _version) {
        if (scope === void 0) {
          scope = new scope_1.Scope();
        }
        if (_version === void 0) {
          _version = exports2.API_VERSION;
        }
        this._version = _version;
        this._stack = [{}];
        this.getStackTop().scope = scope;
        if (client) {
          this.bindClient(client);
        }
      }
      Hub2.prototype.isOlderThan = function(version) {
        return this._version < version;
      };
      Hub2.prototype.bindClient = function(client) {
        var top = this.getStackTop();
        top.client = client;
        if (client && client.setupIntegrations) {
          client.setupIntegrations();
        }
      };
      Hub2.prototype.pushScope = function() {
        var scope = scope_1.Scope.clone(this.getScope());
        this.getStack().push({
          client: this.getClient(),
          scope
        });
        return scope;
      };
      Hub2.prototype.popScope = function() {
        if (this.getStack().length <= 1)
          return false;
        return !!this.getStack().pop();
      };
      Hub2.prototype.withScope = function(callback) {
        var scope = this.pushScope();
        try {
          callback(scope);
        } finally {
          this.popScope();
        }
      };
      Hub2.prototype.getClient = function() {
        return this.getStackTop().client;
      };
      Hub2.prototype.getScope = function() {
        return this.getStackTop().scope;
      };
      Hub2.prototype.getStack = function() {
        return this._stack;
      };
      Hub2.prototype.getStackTop = function() {
        return this._stack[this._stack.length - 1];
      };
      Hub2.prototype.captureException = function(exception, hint) {
        var eventId = this._lastEventId = utils_1.uuid4();
        var finalHint = hint;
        if (!hint) {
          var syntheticException = void 0;
          try {
            throw new Error("Sentry syntheticException");
          } catch (exception2) {
            syntheticException = exception2;
          }
          finalHint = {
            originalException: exception,
            syntheticException
          };
        }
        this._invokeClient("captureException", exception, tslib_1.__assign(tslib_1.__assign({}, finalHint), { event_id: eventId }));
        return eventId;
      };
      Hub2.prototype.captureMessage = function(message, level, hint) {
        var eventId = this._lastEventId = utils_1.uuid4();
        var finalHint = hint;
        if (!hint) {
          var syntheticException = void 0;
          try {
            throw new Error(message);
          } catch (exception) {
            syntheticException = exception;
          }
          finalHint = {
            originalException: message,
            syntheticException
          };
        }
        this._invokeClient("captureMessage", message, level, tslib_1.__assign(tslib_1.__assign({}, finalHint), { event_id: eventId }));
        return eventId;
      };
      Hub2.prototype.captureEvent = function(event, hint) {
        var eventId = utils_1.uuid4();
        if (event.type !== "transaction") {
          this._lastEventId = eventId;
        }
        this._invokeClient("captureEvent", event, tslib_1.__assign(tslib_1.__assign({}, hint), { event_id: eventId }));
        return eventId;
      };
      Hub2.prototype.lastEventId = function() {
        return this._lastEventId;
      };
      Hub2.prototype.addBreadcrumb = function(breadcrumb, hint) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (!scope || !client)
          return;
        var _b = client.getOptions && client.getOptions() || {}, _c = _b.beforeBreadcrumb, beforeBreadcrumb = _c === void 0 ? null : _c, _d = _b.maxBreadcrumbs, maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS : _d;
        if (maxBreadcrumbs <= 0)
          return;
        var timestamp = utils_1.dateTimestampInSeconds();
        var mergedBreadcrumb = tslib_1.__assign({ timestamp }, breadcrumb);
        var finalBreadcrumb = beforeBreadcrumb ? utils_1.consoleSandbox(function() {
          return beforeBreadcrumb(mergedBreadcrumb, hint);
        }) : mergedBreadcrumb;
        if (finalBreadcrumb === null)
          return;
        scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
      };
      Hub2.prototype.setUser = function(user) {
        var scope = this.getScope();
        if (scope)
          scope.setUser(user);
      };
      Hub2.prototype.setTags = function(tags) {
        var scope = this.getScope();
        if (scope)
          scope.setTags(tags);
      };
      Hub2.prototype.setExtras = function(extras) {
        var scope = this.getScope();
        if (scope)
          scope.setExtras(extras);
      };
      Hub2.prototype.setTag = function(key, value) {
        var scope = this.getScope();
        if (scope)
          scope.setTag(key, value);
      };
      Hub2.prototype.setExtra = function(key, extra) {
        var scope = this.getScope();
        if (scope)
          scope.setExtra(key, extra);
      };
      Hub2.prototype.setContext = function(name, context) {
        var scope = this.getScope();
        if (scope)
          scope.setContext(name, context);
      };
      Hub2.prototype.configureScope = function(callback) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (scope && client) {
          callback(scope);
        }
      };
      Hub2.prototype.run = function(callback) {
        var oldHub = makeMain(this);
        try {
          callback(this);
        } finally {
          makeMain(oldHub);
        }
      };
      Hub2.prototype.getIntegration = function(integration) {
        var client = this.getClient();
        if (!client)
          return null;
        try {
          return client.getIntegration(integration);
        } catch (_oO) {
          utils_1.logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
          return null;
        }
      };
      Hub2.prototype.startSpan = function(context) {
        return this._callExtensionMethod("startSpan", context);
      };
      Hub2.prototype.startTransaction = function(context, customSamplingContext) {
        return this._callExtensionMethod("startTransaction", context, customSamplingContext);
      };
      Hub2.prototype.traceHeaders = function() {
        return this._callExtensionMethod("traceHeaders");
      };
      Hub2.prototype.captureSession = function(endSession) {
        if (endSession === void 0) {
          endSession = false;
        }
        if (endSession) {
          return this.endSession();
        }
        this._sendSessionUpdate();
      };
      Hub2.prototype.endSession = function() {
        var _a, _b, _c, _d, _e;
        (_c = (_b = (_a = this.getStackTop()) === null || _a === void 0 ? void 0 : _a.scope) === null || _b === void 0 ? void 0 : _b.getSession()) === null || _c === void 0 ? void 0 : _c.close();
        this._sendSessionUpdate();
        (_e = (_d = this.getStackTop()) === null || _d === void 0 ? void 0 : _d.scope) === null || _e === void 0 ? void 0 : _e.setSession();
      };
      Hub2.prototype.startSession = function(context) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        var _b = client && client.getOptions() || {}, release = _b.release, environment = _b.environment;
        var global2 = utils_1.getGlobalObject();
        var userAgent = (global2.navigator || {}).userAgent;
        var session = new session_1.Session(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({
          release,
          environment
        }, scope && { user: scope.getUser() }), userAgent && { userAgent }), context));
        if (scope) {
          var currentSession = scope.getSession && scope.getSession();
          if (currentSession && currentSession.status === types_1.SessionStatus.Ok) {
            currentSession.update({ status: types_1.SessionStatus.Exited });
          }
          this.endSession();
          scope.setSession(session);
        }
        return session;
      };
      Hub2.prototype._sendSessionUpdate = function() {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (!scope)
          return;
        var session = scope.getSession && scope.getSession();
        if (session) {
          if (client && client.captureSession) {
            client.captureSession(session);
          }
        }
      };
      Hub2.prototype._invokeClient = function(method) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
        if (client && client[method]) {
          (_a = client)[method].apply(_a, tslib_1.__spread(args, [scope]));
        }
      };
      Hub2.prototype._callExtensionMethod = function(method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var carrier = getMainCarrier();
        var sentry = carrier.__SENTRY__;
        if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
          return sentry.extensions[method].apply(this, args);
        }
        utils_1.logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
      };
      return Hub2;
    }();
    exports2.Hub = Hub;
    function getMainCarrier() {
      var carrier = utils_1.getGlobalObject();
      carrier.__SENTRY__ = carrier.__SENTRY__ || {
        extensions: {},
        hub: void 0
      };
      return carrier;
    }
    exports2.getMainCarrier = getMainCarrier;
    function makeMain(hub) {
      var registry = getMainCarrier();
      var oldHub = getHubFromCarrier(registry);
      setHubOnCarrier(registry, hub);
      return oldHub;
    }
    exports2.makeMain = makeMain;
    function getCurrentHub() {
      var registry = getMainCarrier();
      if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(exports2.API_VERSION)) {
        setHubOnCarrier(registry, new Hub());
      }
      if (utils_1.isNodeEnv()) {
        return getHubFromActiveDomain(registry);
      }
      return getHubFromCarrier(registry);
    }
    exports2.getCurrentHub = getCurrentHub;
    function getActiveDomain() {
      utils_1.logger.warn("Function `getActiveDomain` is deprecated and will be removed in a future version.");
      var sentry = getMainCarrier().__SENTRY__;
      return sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
    }
    exports2.getActiveDomain = getActiveDomain;
    function getHubFromActiveDomain(registry) {
      var _a, _b, _c;
      try {
        var activeDomain = (_c = (_b = (_a = getMainCarrier().__SENTRY__) === null || _a === void 0 ? void 0 : _a.extensions) === null || _b === void 0 ? void 0 : _b.domain) === null || _c === void 0 ? void 0 : _c.active;
        if (!activeDomain) {
          return getHubFromCarrier(registry);
        }
        if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(exports2.API_VERSION)) {
          var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
          setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, scope_1.Scope.clone(registryHubTopStack.scope)));
        }
        return getHubFromCarrier(activeDomain);
      } catch (_Oo) {
        return getHubFromCarrier(registry);
      }
    }
    function hasHubOnCarrier(carrier) {
      return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
    }
    function getHubFromCarrier(carrier) {
      if (carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub)
        return carrier.__SENTRY__.hub;
      carrier.__SENTRY__ = carrier.__SENTRY__ || {};
      carrier.__SENTRY__.hub = new Hub();
      return carrier.__SENTRY__.hub;
    }
    exports2.getHubFromCarrier = getHubFromCarrier;
    function setHubOnCarrier(carrier, hub) {
      if (!carrier)
        return false;
      carrier.__SENTRY__ = carrier.__SENTRY__ || {};
      carrier.__SENTRY__.hub = hub;
      return true;
    }
    exports2.setHubOnCarrier = setHubOnCarrier;
  }
});

// node_modules/@sentry/hub/dist/sessionflusher.js
var require_sessionflusher = __commonJS({
  "node_modules/@sentry/hub/dist/sessionflusher.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var hub_1 = require_hub();
    var SessionFlusher = function() {
      function SessionFlusher2(transport, attrs) {
        var _this = this;
        this.flushTimeout = 60;
        this._pendingAggregates = {};
        this._isEnabled = true;
        this._transport = transport;
        this._intervalId = setInterval(function() {
          return _this.flush();
        }, this.flushTimeout * 1e3);
        this._sessionAttrs = attrs;
      }
      SessionFlusher2.prototype.sendSessionAggregates = function(sessionAggregates) {
        if (!this._transport.sendSession) {
          utils_1.logger.warn("Dropping session because custom transport doesn't implement sendSession");
          return;
        }
        void this._transport.sendSession(sessionAggregates).then(null, function(reason) {
          utils_1.logger.error("Error while sending session: " + reason);
        });
      };
      SessionFlusher2.prototype.flush = function() {
        var sessionAggregates = this.getSessionAggregates();
        if (sessionAggregates.aggregates.length === 0) {
          return;
        }
        this._pendingAggregates = {};
        this.sendSessionAggregates(sessionAggregates);
      };
      SessionFlusher2.prototype.getSessionAggregates = function() {
        var _this = this;
        var aggregates = Object.keys(this._pendingAggregates).map(function(key) {
          return _this._pendingAggregates[parseInt(key)];
        });
        var sessionAggregates = {
          attrs: this._sessionAttrs,
          aggregates
        };
        return utils_1.dropUndefinedKeys(sessionAggregates);
      };
      SessionFlusher2.prototype.close = function() {
        clearInterval(this._intervalId);
        this._isEnabled = false;
        this.flush();
      };
      SessionFlusher2.prototype.incrementSessionStatusCount = function() {
        var _a, _b;
        if (!this._isEnabled) {
          return;
        }
        var scope = hub_1.getCurrentHub().getScope();
        var requestSession = (_a = scope) === null || _a === void 0 ? void 0 : _a.getRequestSession();
        if (requestSession && requestSession.status) {
          this._incrementSessionStatusCount(requestSession.status, new Date());
          (_b = scope) === null || _b === void 0 ? void 0 : _b.setRequestSession(void 0);
        }
      };
      SessionFlusher2.prototype._incrementSessionStatusCount = function(status, date) {
        var sessionStartedTrunc = new Date(date).setSeconds(0, 0);
        this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};
        var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];
        if (!aggregationCounts.started) {
          aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();
        }
        switch (status) {
          case types_1.RequestSessionStatus.Errored:
            aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;
            return aggregationCounts.errored;
          case types_1.RequestSessionStatus.Ok:
            aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;
            return aggregationCounts.exited;
          case types_1.RequestSessionStatus.Crashed:
            aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;
            return aggregationCounts.crashed;
        }
      };
      return SessionFlusher2;
    }();
    exports2.SessionFlusher = SessionFlusher;
  }
});

// node_modules/@sentry/hub/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@sentry/hub/dist/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var scope_1 = require_scope();
    exports2.addGlobalEventProcessor = scope_1.addGlobalEventProcessor;
    exports2.Scope = scope_1.Scope;
    var session_1 = require_session2();
    exports2.Session = session_1.Session;
    var sessionflusher_1 = require_sessionflusher();
    exports2.SessionFlusher = sessionflusher_1.SessionFlusher;
    var hub_1 = require_hub();
    exports2.getActiveDomain = hub_1.getActiveDomain;
    exports2.getCurrentHub = hub_1.getCurrentHub;
    exports2.getHubFromCarrier = hub_1.getHubFromCarrier;
    exports2.getMainCarrier = hub_1.getMainCarrier;
    exports2.Hub = hub_1.Hub;
    exports2.makeMain = hub_1.makeMain;
    exports2.setHubOnCarrier = hub_1.setHubOnCarrier;
  }
});

// node_modules/@sentry/minimal/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@sentry/minimal/dist/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var hub_1 = require_dist3();
    function callOnHub(method) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var hub = hub_1.getCurrentHub();
      if (hub && hub[method]) {
        return hub[method].apply(hub, tslib_1.__spread(args));
      }
      throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
    }
    function captureException2(exception, captureContext) {
      var syntheticException;
      try {
        throw new Error("Sentry syntheticException");
      } catch (exception2) {
        syntheticException = exception2;
      }
      return callOnHub("captureException", exception, {
        captureContext,
        originalException: exception,
        syntheticException
      });
    }
    exports2.captureException = captureException2;
    function captureMessage(message, captureContext) {
      var syntheticException;
      try {
        throw new Error(message);
      } catch (exception) {
        syntheticException = exception;
      }
      var level = typeof captureContext === "string" ? captureContext : void 0;
      var context = typeof captureContext !== "string" ? { captureContext } : void 0;
      return callOnHub("captureMessage", message, level, tslib_1.__assign({ originalException: message, syntheticException }, context));
    }
    exports2.captureMessage = captureMessage;
    function captureEvent(event) {
      return callOnHub("captureEvent", event);
    }
    exports2.captureEvent = captureEvent;
    function configureScope(callback) {
      callOnHub("configureScope", callback);
    }
    exports2.configureScope = configureScope;
    function addBreadcrumb(breadcrumb) {
      callOnHub("addBreadcrumb", breadcrumb);
    }
    exports2.addBreadcrumb = addBreadcrumb;
    function setContext(name, context) {
      callOnHub("setContext", name, context);
    }
    exports2.setContext = setContext;
    function setExtras(extras) {
      callOnHub("setExtras", extras);
    }
    exports2.setExtras = setExtras;
    function setTags(tags) {
      callOnHub("setTags", tags);
    }
    exports2.setTags = setTags;
    function setExtra(key, extra) {
      callOnHub("setExtra", key, extra);
    }
    exports2.setExtra = setExtra;
    function setTag(key, value) {
      callOnHub("setTag", key, value);
    }
    exports2.setTag = setTag;
    function setUser(user) {
      callOnHub("setUser", user);
    }
    exports2.setUser = setUser;
    function withScope(callback) {
      callOnHub("withScope", callback);
    }
    exports2.withScope = withScope;
    function _callOnClient(method) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      callOnHub.apply(void 0, tslib_1.__spread(["_invokeClient", method], args));
    }
    exports2._callOnClient = _callOnClient;
    function startTransaction(context, customSamplingContext) {
      return callOnHub("startTransaction", tslib_1.__assign({}, context), customSamplingContext);
    }
    exports2.startTransaction = startTransaction;
  }
});

// node_modules/@sentry/core/dist/api.js
var require_api = __commonJS({
  "node_modules/@sentry/core/dist/api.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var SENTRY_API_VERSION = "7";
    var API = function() {
      function API2(dsn, metadata, tunnel) {
        if (metadata === void 0) {
          metadata = {};
        }
        this.dsn = dsn;
        this._dsnObject = new utils_1.Dsn(dsn);
        this.metadata = metadata;
        this._tunnel = tunnel;
      }
      API2.prototype.getDsn = function() {
        return this._dsnObject;
      };
      API2.prototype.forceEnvelope = function() {
        return !!this._tunnel;
      };
      API2.prototype.getBaseApiEndpoint = function() {
        var dsn = this.getDsn();
        var protocol = dsn.protocol ? dsn.protocol + ":" : "";
        var port = dsn.port ? ":" + dsn.port : "";
        return protocol + "//" + dsn.host + port + (dsn.path ? "/" + dsn.path : "") + "/api/";
      };
      API2.prototype.getStoreEndpoint = function() {
        return this._getIngestEndpoint("store");
      };
      API2.prototype.getStoreEndpointWithUrlEncodedAuth = function() {
        return this.getStoreEndpoint() + "?" + this._encodedAuth();
      };
      API2.prototype.getEnvelopeEndpointWithUrlEncodedAuth = function() {
        if (this.forceEnvelope()) {
          return this._tunnel;
        }
        return this._getEnvelopeEndpoint() + "?" + this._encodedAuth();
      };
      API2.prototype.getStoreEndpointPath = function() {
        var dsn = this.getDsn();
        return (dsn.path ? "/" + dsn.path : "") + "/api/" + dsn.projectId + "/store/";
      };
      API2.prototype.getRequestHeaders = function(clientName, clientVersion) {
        var dsn = this.getDsn();
        var header = ["Sentry sentry_version=" + SENTRY_API_VERSION];
        header.push("sentry_client=" + clientName + "/" + clientVersion);
        header.push("sentry_key=" + dsn.publicKey);
        if (dsn.pass) {
          header.push("sentry_secret=" + dsn.pass);
        }
        return {
          "Content-Type": "application/json",
          "X-Sentry-Auth": header.join(", ")
        };
      };
      API2.prototype.getReportDialogEndpoint = function(dialogOptions) {
        if (dialogOptions === void 0) {
          dialogOptions = {};
        }
        var dsn = this.getDsn();
        var endpoint = this.getBaseApiEndpoint() + "embed/error-page/";
        var encodedOptions = [];
        encodedOptions.push("dsn=" + dsn.toString());
        for (var key in dialogOptions) {
          if (key === "dsn") {
            continue;
          }
          if (key === "user") {
            if (!dialogOptions.user) {
              continue;
            }
            if (dialogOptions.user.name) {
              encodedOptions.push("name=" + encodeURIComponent(dialogOptions.user.name));
            }
            if (dialogOptions.user.email) {
              encodedOptions.push("email=" + encodeURIComponent(dialogOptions.user.email));
            }
          } else {
            encodedOptions.push(encodeURIComponent(key) + "=" + encodeURIComponent(dialogOptions[key]));
          }
        }
        if (encodedOptions.length) {
          return endpoint + "?" + encodedOptions.join("&");
        }
        return endpoint;
      };
      API2.prototype._getEnvelopeEndpoint = function() {
        return this._getIngestEndpoint("envelope");
      };
      API2.prototype._getIngestEndpoint = function(target) {
        if (this._tunnel) {
          return this._tunnel;
        }
        var base = this.getBaseApiEndpoint();
        var dsn = this.getDsn();
        return "" + base + dsn.projectId + "/" + target + "/";
      };
      API2.prototype._encodedAuth = function() {
        var dsn = this.getDsn();
        var auth = {
          sentry_key: dsn.publicKey,
          sentry_version: SENTRY_API_VERSION
        };
        return utils_1.urlEncode(auth);
      };
      return API2;
    }();
    exports2.API = API;
  }
});

// node_modules/@sentry/core/dist/integration.js
var require_integration = __commonJS({
  "node_modules/@sentry/core/dist/integration.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var hub_1 = require_dist3();
    var utils_1 = require_dist2();
    exports2.installedIntegrations = [];
    function filterDuplicates(integrations) {
      return integrations.reduce(function(acc, integrations2) {
        if (acc.every(function(accIntegration) {
          return integrations2.name !== accIntegration.name;
        })) {
          acc.push(integrations2);
        }
        return acc;
      }, []);
    }
    function getIntegrationsToSetup(options) {
      var defaultIntegrations = options.defaultIntegrations && tslib_1.__spread(options.defaultIntegrations) || [];
      var userIntegrations = options.integrations;
      var integrations = tslib_1.__spread(filterDuplicates(defaultIntegrations));
      if (Array.isArray(userIntegrations)) {
        integrations = tslib_1.__spread(integrations.filter(function(integrations2) {
          return userIntegrations.every(function(userIntegration) {
            return userIntegration.name !== integrations2.name;
          });
        }), filterDuplicates(userIntegrations));
      } else if (typeof userIntegrations === "function") {
        integrations = userIntegrations(integrations);
        integrations = Array.isArray(integrations) ? integrations : [integrations];
      }
      var integrationsNames = integrations.map(function(i) {
        return i.name;
      });
      var alwaysLastToRun = "Debug";
      if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {
        integrations.push.apply(integrations, tslib_1.__spread(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));
      }
      return integrations;
    }
    exports2.getIntegrationsToSetup = getIntegrationsToSetup;
    function setupIntegration(integration) {
      if (exports2.installedIntegrations.indexOf(integration.name) !== -1) {
        return;
      }
      integration.setupOnce(hub_1.addGlobalEventProcessor, hub_1.getCurrentHub);
      exports2.installedIntegrations.push(integration.name);
      utils_1.logger.log("Integration installed: " + integration.name);
    }
    exports2.setupIntegration = setupIntegration;
    function setupIntegrations(options) {
      var integrations = {};
      getIntegrationsToSetup(options).forEach(function(integration) {
        integrations[integration.name] = integration;
        setupIntegration(integration);
      });
      Object.defineProperty(integrations, "initialized", { value: true });
      return integrations;
    }
    exports2.setupIntegrations = setupIntegrations;
  }
});

// node_modules/@sentry/core/dist/baseclient.js
var require_baseclient = __commonJS({
  "node_modules/@sentry/core/dist/baseclient.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var hub_1 = require_dist3();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var integration_1 = require_integration();
    var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
    var BaseClient = function() {
      function BaseClient2(backendClass, options) {
        this._integrations = {};
        this._numProcessing = 0;
        this._backend = new backendClass(options);
        this._options = options;
        if (options.dsn) {
          this._dsn = new utils_1.Dsn(options.dsn);
        }
      }
      BaseClient2.prototype.captureException = function(exception, hint, scope) {
        var _this = this;
        if (utils_1.checkOrSetAlreadyCaught(exception)) {
          utils_1.logger.log(ALREADY_SEEN_ERROR);
          return;
        }
        var eventId = hint && hint.event_id;
        this._process(this._getBackend().eventFromException(exception, hint).then(function(event) {
          return _this._captureEvent(event, hint, scope);
        }).then(function(result) {
          eventId = result;
        }));
        return eventId;
      };
      BaseClient2.prototype.captureMessage = function(message, level, hint, scope) {
        var _this = this;
        var eventId = hint && hint.event_id;
        var promisedEvent = utils_1.isPrimitive(message) ? this._getBackend().eventFromMessage(String(message), level, hint) : this._getBackend().eventFromException(message, hint);
        this._process(promisedEvent.then(function(event) {
          return _this._captureEvent(event, hint, scope);
        }).then(function(result) {
          eventId = result;
        }));
        return eventId;
      };
      BaseClient2.prototype.captureEvent = function(event, hint, scope) {
        var _a;
        if (((_a = hint) === null || _a === void 0 ? void 0 : _a.originalException) && utils_1.checkOrSetAlreadyCaught(hint.originalException)) {
          utils_1.logger.log(ALREADY_SEEN_ERROR);
          return;
        }
        var eventId = hint && hint.event_id;
        this._process(this._captureEvent(event, hint, scope).then(function(result) {
          eventId = result;
        }));
        return eventId;
      };
      BaseClient2.prototype.captureSession = function(session) {
        if (!this._isEnabled()) {
          utils_1.logger.warn("SDK not enabled, will not capture session.");
          return;
        }
        if (!(typeof session.release === "string")) {
          utils_1.logger.warn("Discarded session because of missing or non-string release");
        } else {
          this._sendSession(session);
          session.update({ init: false });
        }
      };
      BaseClient2.prototype.getDsn = function() {
        return this._dsn;
      };
      BaseClient2.prototype.getOptions = function() {
        return this._options;
      };
      BaseClient2.prototype.getTransport = function() {
        return this._getBackend().getTransport();
      };
      BaseClient2.prototype.flush = function(timeout) {
        var _this = this;
        return this._isClientDoneProcessing(timeout).then(function(clientFinished) {
          return _this.getTransport().close(timeout).then(function(transportFlushed) {
            return clientFinished && transportFlushed;
          });
        });
      };
      BaseClient2.prototype.close = function(timeout) {
        var _this = this;
        return this.flush(timeout).then(function(result) {
          _this.getOptions().enabled = false;
          return result;
        });
      };
      BaseClient2.prototype.setupIntegrations = function() {
        if (this._isEnabled() && !this._integrations.initialized) {
          this._integrations = integration_1.setupIntegrations(this._options);
        }
      };
      BaseClient2.prototype.getIntegration = function(integration) {
        try {
          return this._integrations[integration.id] || null;
        } catch (_oO) {
          utils_1.logger.warn("Cannot retrieve integration " + integration.id + " from the current Client");
          return null;
        }
      };
      BaseClient2.prototype._updateSessionFromEvent = function(session, event) {
        var e_1, _a;
        var crashed = false;
        var errored = false;
        var exceptions = event.exception && event.exception.values;
        if (exceptions) {
          errored = true;
          try {
            for (var exceptions_1 = tslib_1.__values(exceptions), exceptions_1_1 = exceptions_1.next(); !exceptions_1_1.done; exceptions_1_1 = exceptions_1.next()) {
              var ex = exceptions_1_1.value;
              var mechanism = ex.mechanism;
              if (mechanism && mechanism.handled === false) {
                crashed = true;
                break;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (exceptions_1_1 && !exceptions_1_1.done && (_a = exceptions_1.return))
                _a.call(exceptions_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
        var sessionNonTerminal = session.status === types_1.SessionStatus.Ok;
        var shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
        if (shouldUpdateAndSend) {
          session.update(tslib_1.__assign(tslib_1.__assign({}, crashed && { status: types_1.SessionStatus.Crashed }), { errors: session.errors || Number(errored || crashed) }));
          this.captureSession(session);
        }
      };
      BaseClient2.prototype._sendSession = function(session) {
        this._getBackend().sendSession(session);
      };
      BaseClient2.prototype._isClientDoneProcessing = function(timeout) {
        var _this = this;
        return new utils_1.SyncPromise(function(resolve) {
          var ticked = 0;
          var tick = 1;
          var interval = setInterval(function() {
            if (_this._numProcessing == 0) {
              clearInterval(interval);
              resolve(true);
            } else {
              ticked += tick;
              if (timeout && ticked >= timeout) {
                clearInterval(interval);
                resolve(false);
              }
            }
          }, tick);
        });
      };
      BaseClient2.prototype._getBackend = function() {
        return this._backend;
      };
      BaseClient2.prototype._isEnabled = function() {
        return this.getOptions().enabled !== false && this._dsn !== void 0;
      };
      BaseClient2.prototype._prepareEvent = function(event, scope, hint) {
        var _this = this;
        var _a = this.getOptions().normalizeDepth, normalizeDepth = _a === void 0 ? 3 : _a;
        var prepared = tslib_1.__assign(tslib_1.__assign({}, event), { event_id: event.event_id || (hint && hint.event_id ? hint.event_id : utils_1.uuid4()), timestamp: event.timestamp || utils_1.dateTimestampInSeconds() });
        this._applyClientOptions(prepared);
        this._applyIntegrationsMetadata(prepared);
        var finalScope = scope;
        if (hint && hint.captureContext) {
          finalScope = hub_1.Scope.clone(finalScope).update(hint.captureContext);
        }
        var result = utils_1.SyncPromise.resolve(prepared);
        if (finalScope) {
          result = finalScope.applyToEvent(prepared, hint);
        }
        return result.then(function(evt) {
          if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
            return _this._normalizeEvent(evt, normalizeDepth);
          }
          return evt;
        });
      };
      BaseClient2.prototype._normalizeEvent = function(event, depth) {
        if (!event) {
          return null;
        }
        var normalized = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, event), event.breadcrumbs && {
          breadcrumbs: event.breadcrumbs.map(function(b) {
            return tslib_1.__assign(tslib_1.__assign({}, b), b.data && {
              data: utils_1.normalize(b.data, depth)
            });
          })
        }), event.user && {
          user: utils_1.normalize(event.user, depth)
        }), event.contexts && {
          contexts: utils_1.normalize(event.contexts, depth)
        }), event.extra && {
          extra: utils_1.normalize(event.extra, depth)
        });
        if (event.contexts && event.contexts.trace) {
          normalized.contexts.trace = event.contexts.trace;
        }
        var _a = this.getOptions()._experiments, _experiments = _a === void 0 ? {} : _a;
        if (_experiments.ensureNoCircularStructures) {
          return utils_1.normalize(normalized);
        }
        return normalized;
      };
      BaseClient2.prototype._applyClientOptions = function(event) {
        var options = this.getOptions();
        var environment = options.environment, release = options.release, dist = options.dist, _a = options.maxValueLength, maxValueLength = _a === void 0 ? 250 : _a;
        if (!("environment" in event)) {
          event.environment = "environment" in options ? environment : "production";
        }
        if (event.release === void 0 && release !== void 0) {
          event.release = release;
        }
        if (event.dist === void 0 && dist !== void 0) {
          event.dist = dist;
        }
        if (event.message) {
          event.message = utils_1.truncate(event.message, maxValueLength);
        }
        var exception = event.exception && event.exception.values && event.exception.values[0];
        if (exception && exception.value) {
          exception.value = utils_1.truncate(exception.value, maxValueLength);
        }
        var request = event.request;
        if (request && request.url) {
          request.url = utils_1.truncate(request.url, maxValueLength);
        }
      };
      BaseClient2.prototype._applyIntegrationsMetadata = function(event) {
        var integrationsArray = Object.keys(this._integrations);
        if (integrationsArray.length > 0) {
          event.sdk = event.sdk || {};
          event.sdk.integrations = tslib_1.__spread(event.sdk.integrations || [], integrationsArray);
        }
      };
      BaseClient2.prototype._sendEvent = function(event) {
        this._getBackend().sendEvent(event);
      };
      BaseClient2.prototype._captureEvent = function(event, hint, scope) {
        return this._processEvent(event, hint, scope).then(function(finalEvent) {
          return finalEvent.event_id;
        }, function(reason) {
          utils_1.logger.error(reason);
          return void 0;
        });
      };
      BaseClient2.prototype._processEvent = function(event, hint, scope) {
        var _this = this;
        var _a, _b;
        var _c = this.getOptions(), beforeSend = _c.beforeSend, sampleRate = _c.sampleRate;
        var transport = this.getTransport();
        if (!this._isEnabled()) {
          return utils_1.SyncPromise.reject(new utils_1.SentryError("SDK not enabled, will not capture event."));
        }
        var isTransaction = event.type === "transaction";
        if (!isTransaction && typeof sampleRate === "number" && Math.random() > sampleRate) {
          (_b = (_a = transport).recordLostEvent) === null || _b === void 0 ? void 0 : _b.call(_a, types_1.Outcome.SampleRate, "event");
          return utils_1.SyncPromise.reject(new utils_1.SentryError("Discarding event because it's not included in the random sample (sampling rate = " + sampleRate + ")"));
        }
        return this._prepareEvent(event, scope, hint).then(function(prepared) {
          var _a2, _b2;
          if (prepared === null) {
            (_b2 = (_a2 = transport).recordLostEvent) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, types_1.Outcome.EventProcessor, event.type || "event");
            throw new utils_1.SentryError("An event processor returned null, will not send event.");
          }
          var isInternalException = hint && hint.data && hint.data.__sentry__ === true;
          if (isInternalException || isTransaction || !beforeSend) {
            return prepared;
          }
          var beforeSendResult = beforeSend(prepared, hint);
          return _this._ensureBeforeSendRv(beforeSendResult);
        }).then(function(processedEvent) {
          var _a2, _b2;
          if (processedEvent === null) {
            (_b2 = (_a2 = transport).recordLostEvent) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, types_1.Outcome.BeforeSend, event.type || "event");
            throw new utils_1.SentryError("`beforeSend` returned `null`, will not send event.");
          }
          var session = scope && scope.getSession && scope.getSession();
          if (!isTransaction && session) {
            _this._updateSessionFromEvent(session, processedEvent);
          }
          _this._sendEvent(processedEvent);
          return processedEvent;
        }).then(null, function(reason) {
          if (reason instanceof utils_1.SentryError) {
            throw reason;
          }
          _this.captureException(reason, {
            data: {
              __sentry__: true
            },
            originalException: reason
          });
          throw new utils_1.SentryError("Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: " + reason);
        });
      };
      BaseClient2.prototype._process = function(promise) {
        var _this = this;
        this._numProcessing += 1;
        void promise.then(function(value) {
          _this._numProcessing -= 1;
          return value;
        }, function(reason) {
          _this._numProcessing -= 1;
          return reason;
        });
      };
      BaseClient2.prototype._ensureBeforeSendRv = function(rv) {
        var nullErr = "`beforeSend` method has to return `null` or a valid event.";
        if (utils_1.isThenable(rv)) {
          return rv.then(function(event) {
            if (!(utils_1.isPlainObject(event) || event === null)) {
              throw new utils_1.SentryError(nullErr);
            }
            return event;
          }, function(e) {
            throw new utils_1.SentryError("beforeSend rejected with " + e);
          });
        } else if (!(utils_1.isPlainObject(rv) || rv === null)) {
          throw new utils_1.SentryError(nullErr);
        }
        return rv;
      };
      return BaseClient2;
    }();
    exports2.BaseClient = BaseClient;
  }
});

// node_modules/@sentry/core/dist/transports/noop.js
var require_noop = __commonJS({
  "node_modules/@sentry/core/dist/transports/noop.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var NoopTransport = function() {
      function NoopTransport2() {
      }
      NoopTransport2.prototype.sendEvent = function(_) {
        return utils_1.SyncPromise.resolve({
          reason: "NoopTransport: Event has been skipped because no Dsn is configured.",
          status: types_1.Status.Skipped
        });
      };
      NoopTransport2.prototype.close = function(_) {
        return utils_1.SyncPromise.resolve(true);
      };
      return NoopTransport2;
    }();
    exports2.NoopTransport = NoopTransport;
  }
});

// node_modules/@sentry/core/dist/basebackend.js
var require_basebackend = __commonJS({
  "node_modules/@sentry/core/dist/basebackend.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var noop_1 = require_noop();
    var BaseBackend = function() {
      function BaseBackend2(options) {
        this._options = options;
        if (!this._options.dsn) {
          utils_1.logger.warn("No DSN provided, backend will not do anything.");
        }
        this._transport = this._setupTransport();
      }
      BaseBackend2.prototype.eventFromException = function(_exception, _hint) {
        throw new utils_1.SentryError("Backend has to implement `eventFromException` method");
      };
      BaseBackend2.prototype.eventFromMessage = function(_message, _level, _hint) {
        throw new utils_1.SentryError("Backend has to implement `eventFromMessage` method");
      };
      BaseBackend2.prototype.sendEvent = function(event) {
        void this._transport.sendEvent(event).then(null, function(reason) {
          utils_1.logger.error("Error while sending event: " + reason);
        });
      };
      BaseBackend2.prototype.sendSession = function(session) {
        if (!this._transport.sendSession) {
          utils_1.logger.warn("Dropping session because custom transport doesn't implement sendSession");
          return;
        }
        void this._transport.sendSession(session).then(null, function(reason) {
          utils_1.logger.error("Error while sending session: " + reason);
        });
      };
      BaseBackend2.prototype.getTransport = function() {
        return this._transport;
      };
      BaseBackend2.prototype._setupTransport = function() {
        return new noop_1.NoopTransport();
      };
      return BaseBackend2;
    }();
    exports2.BaseBackend = BaseBackend;
  }
});

// node_modules/@sentry/core/dist/request.js
var require_request = __commonJS({
  "node_modules/@sentry/core/dist/request.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    function getSdkMetadataForEnvelopeHeader(api) {
      if (!api.metadata || !api.metadata.sdk) {
        return;
      }
      var _a = api.metadata.sdk, name = _a.name, version = _a.version;
      return { name, version };
    }
    function enhanceEventWithSdkInfo(event, sdkInfo) {
      if (!sdkInfo) {
        return event;
      }
      event.sdk = event.sdk || {};
      event.sdk.name = event.sdk.name || sdkInfo.name;
      event.sdk.version = event.sdk.version || sdkInfo.version;
      event.sdk.integrations = tslib_1.__spread(event.sdk.integrations || [], sdkInfo.integrations || []);
      event.sdk.packages = tslib_1.__spread(event.sdk.packages || [], sdkInfo.packages || []);
      return event;
    }
    function sessionToSentryRequest(session, api) {
      var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
      var envelopeHeaders = JSON.stringify(tslib_1.__assign(tslib_1.__assign({ sent_at: new Date().toISOString() }, sdkInfo && { sdk: sdkInfo }), api.forceEnvelope() && { dsn: api.getDsn().toString() }));
      var type = "aggregates" in session ? "sessions" : "session";
      var itemHeaders = JSON.stringify({
        type
      });
      return {
        body: envelopeHeaders + "\n" + itemHeaders + "\n" + JSON.stringify(session),
        type,
        url: api.getEnvelopeEndpointWithUrlEncodedAuth()
      };
    }
    exports2.sessionToSentryRequest = sessionToSentryRequest;
    function eventToSentryRequest(event, api) {
      var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
      var eventType = event.type || "event";
      var useEnvelope = eventType === "transaction" || api.forceEnvelope();
      var _a = event.debug_meta || {}, transactionSampling = _a.transactionSampling, metadata = tslib_1.__rest(_a, ["transactionSampling"]);
      var _b = transactionSampling || {}, samplingMethod = _b.method, sampleRate = _b.rate;
      if (Object.keys(metadata).length === 0) {
        delete event.debug_meta;
      } else {
        event.debug_meta = metadata;
      }
      var req = {
        body: JSON.stringify(sdkInfo ? enhanceEventWithSdkInfo(event, api.metadata.sdk) : event),
        type: eventType,
        url: useEnvelope ? api.getEnvelopeEndpointWithUrlEncodedAuth() : api.getStoreEndpointWithUrlEncodedAuth()
      };
      if (useEnvelope) {
        var envelopeHeaders = JSON.stringify(tslib_1.__assign(tslib_1.__assign({ event_id: event.event_id, sent_at: new Date().toISOString() }, sdkInfo && { sdk: sdkInfo }), api.forceEnvelope() && { dsn: api.getDsn().toString() }));
        var itemHeaders = JSON.stringify({
          type: eventType,
          sample_rates: [{ id: samplingMethod, rate: sampleRate }]
        });
        var envelope = envelopeHeaders + "\n" + itemHeaders + "\n" + req.body;
        req.body = envelope;
      }
      return req;
    }
    exports2.eventToSentryRequest = eventToSentryRequest;
  }
});

// node_modules/@sentry/core/dist/sdk.js
var require_sdk = __commonJS({
  "node_modules/@sentry/core/dist/sdk.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hub_1 = require_dist3();
    var utils_1 = require_dist2();
    function initAndBind(clientClass, options) {
      var _a;
      if (options.debug === true) {
        utils_1.logger.enable();
      }
      var hub = hub_1.getCurrentHub();
      (_a = hub.getScope()) === null || _a === void 0 ? void 0 : _a.update(options.initialScope);
      var client = new clientClass(options);
      hub.bindClient(client);
    }
    exports2.initAndBind = initAndBind;
  }
});

// node_modules/@sentry/core/dist/version.js
var require_version = __commonJS({
  "node_modules/@sentry/core/dist/version.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SDK_VERSION = "6.15.0";
  }
});

// node_modules/@sentry/core/dist/integrations/functiontostring.js
var require_functiontostring = __commonJS({
  "node_modules/@sentry/core/dist/integrations/functiontostring.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var originalFunctionToString;
    var FunctionToString = function() {
      function FunctionToString2() {
        this.name = FunctionToString2.id;
      }
      FunctionToString2.prototype.setupOnce = function() {
        originalFunctionToString = Function.prototype.toString;
        Function.prototype.toString = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var context = this.__sentry_original__ || this;
          return originalFunctionToString.apply(context, args);
        };
      };
      FunctionToString2.id = "FunctionToString";
      return FunctionToString2;
    }();
    exports2.FunctionToString = FunctionToString;
  }
});

// node_modules/@sentry/core/dist/integrations/inboundfilters.js
var require_inboundfilters = __commonJS({
  "node_modules/@sentry/core/dist/integrations/inboundfilters.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var hub_1 = require_dist3();
    var utils_1 = require_dist2();
    var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
    var InboundFilters = function() {
      function InboundFilters2(_options) {
        if (_options === void 0) {
          _options = {};
        }
        this._options = _options;
        this.name = InboundFilters2.id;
      }
      InboundFilters2.prototype.setupOnce = function() {
        hub_1.addGlobalEventProcessor(function(event) {
          var hub = hub_1.getCurrentHub();
          if (!hub) {
            return event;
          }
          var self2 = hub.getIntegration(InboundFilters2);
          if (self2) {
            var client = hub.getClient();
            var clientOptions = client ? client.getOptions() : {};
            var options = typeof self2._mergeOptions === "function" ? self2._mergeOptions(clientOptions) : {};
            if (typeof self2._shouldDropEvent !== "function") {
              return event;
            }
            return self2._shouldDropEvent(event, options) ? null : event;
          }
          return event;
        });
      };
      InboundFilters2.prototype._shouldDropEvent = function(event, options) {
        if (this._isSentryError(event, options)) {
          utils_1.logger.warn("Event dropped due to being internal Sentry Error.\nEvent: " + utils_1.getEventDescription(event));
          return true;
        }
        if (this._isIgnoredError(event, options)) {
          utils_1.logger.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + utils_1.getEventDescription(event));
          return true;
        }
        if (this._isDeniedUrl(event, options)) {
          utils_1.logger.warn("Event dropped due to being matched by `denyUrls` option.\nEvent: " + utils_1.getEventDescription(event) + ".\nUrl: " + this._getEventFilterUrl(event));
          return true;
        }
        if (!this._isAllowedUrl(event, options)) {
          utils_1.logger.warn("Event dropped due to not being matched by `allowUrls` option.\nEvent: " + utils_1.getEventDescription(event) + ".\nUrl: " + this._getEventFilterUrl(event));
          return true;
        }
        return false;
      };
      InboundFilters2.prototype._isSentryError = function(event, options) {
        if (!options.ignoreInternal) {
          return false;
        }
        try {
          return event && event.exception && event.exception.values && event.exception.values[0] && event.exception.values[0].type === "SentryError" || false;
        } catch (_oO) {
          return false;
        }
      };
      InboundFilters2.prototype._isIgnoredError = function(event, options) {
        if (!options.ignoreErrors || !options.ignoreErrors.length) {
          return false;
        }
        return this._getPossibleEventMessages(event).some(function(message) {
          return options.ignoreErrors.some(function(pattern) {
            return utils_1.isMatchingPattern(message, pattern);
          });
        });
      };
      InboundFilters2.prototype._isDeniedUrl = function(event, options) {
        if (!options.denyUrls || !options.denyUrls.length) {
          return false;
        }
        var url = this._getEventFilterUrl(event);
        return !url ? false : options.denyUrls.some(function(pattern) {
          return utils_1.isMatchingPattern(url, pattern);
        });
      };
      InboundFilters2.prototype._isAllowedUrl = function(event, options) {
        if (!options.allowUrls || !options.allowUrls.length) {
          return true;
        }
        var url = this._getEventFilterUrl(event);
        return !url ? true : options.allowUrls.some(function(pattern) {
          return utils_1.isMatchingPattern(url, pattern);
        });
      };
      InboundFilters2.prototype._mergeOptions = function(clientOptions) {
        if (clientOptions === void 0) {
          clientOptions = {};
        }
        return {
          allowUrls: tslib_1.__spread(this._options.whitelistUrls || [], this._options.allowUrls || [], clientOptions.whitelistUrls || [], clientOptions.allowUrls || []),
          denyUrls: tslib_1.__spread(this._options.blacklistUrls || [], this._options.denyUrls || [], clientOptions.blacklistUrls || [], clientOptions.denyUrls || []),
          ignoreErrors: tslib_1.__spread(this._options.ignoreErrors || [], clientOptions.ignoreErrors || [], DEFAULT_IGNORE_ERRORS),
          ignoreInternal: typeof this._options.ignoreInternal !== "undefined" ? this._options.ignoreInternal : true
        };
      };
      InboundFilters2.prototype._getPossibleEventMessages = function(event) {
        if (event.message) {
          return [event.message];
        }
        if (event.exception) {
          try {
            var _a = event.exception.values && event.exception.values[0] || {}, _b = _a.type, type = _b === void 0 ? "" : _b, _c = _a.value, value = _c === void 0 ? "" : _c;
            return ["" + value, type + ": " + value];
          } catch (oO) {
            utils_1.logger.error("Cannot extract message for event " + utils_1.getEventDescription(event));
            return [];
          }
        }
        return [];
      };
      InboundFilters2.prototype._getLastValidUrl = function(frames) {
        if (frames === void 0) {
          frames = [];
        }
        var _a, _b;
        for (var i = frames.length - 1; i >= 0; i--) {
          var frame = frames[i];
          if (((_a = frame) === null || _a === void 0 ? void 0 : _a.filename) !== "<anonymous>" && ((_b = frame) === null || _b === void 0 ? void 0 : _b.filename) !== "[native code]") {
            return frame.filename || null;
          }
        }
        return null;
      };
      InboundFilters2.prototype._getEventFilterUrl = function(event) {
        try {
          if (event.stacktrace) {
            var frames_1 = event.stacktrace.frames;
            return this._getLastValidUrl(frames_1);
          }
          if (event.exception) {
            var frames_2 = event.exception.values && event.exception.values[0].stacktrace && event.exception.values[0].stacktrace.frames;
            return this._getLastValidUrl(frames_2);
          }
          return null;
        } catch (oO) {
          utils_1.logger.error("Cannot extract url for event " + utils_1.getEventDescription(event));
          return null;
        }
      };
      InboundFilters2.id = "InboundFilters";
      return InboundFilters2;
    }();
    exports2.InboundFilters = InboundFilters;
  }
});

// node_modules/@sentry/core/dist/integrations/index.js
var require_integrations = __commonJS({
  "node_modules/@sentry/core/dist/integrations/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var functiontostring_1 = require_functiontostring();
    exports2.FunctionToString = functiontostring_1.FunctionToString;
    var inboundfilters_1 = require_inboundfilters();
    exports2.InboundFilters = inboundfilters_1.InboundFilters;
  }
});

// node_modules/@sentry/core/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@sentry/core/dist/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var minimal_1 = require_dist4();
    exports2.addBreadcrumb = minimal_1.addBreadcrumb;
    exports2.captureException = minimal_1.captureException;
    exports2.captureEvent = minimal_1.captureEvent;
    exports2.captureMessage = minimal_1.captureMessage;
    exports2.configureScope = minimal_1.configureScope;
    exports2.startTransaction = minimal_1.startTransaction;
    exports2.setContext = minimal_1.setContext;
    exports2.setExtra = minimal_1.setExtra;
    exports2.setExtras = minimal_1.setExtras;
    exports2.setTag = minimal_1.setTag;
    exports2.setTags = minimal_1.setTags;
    exports2.setUser = minimal_1.setUser;
    exports2.withScope = minimal_1.withScope;
    var hub_1 = require_dist3();
    exports2.addGlobalEventProcessor = hub_1.addGlobalEventProcessor;
    exports2.getCurrentHub = hub_1.getCurrentHub;
    exports2.getHubFromCarrier = hub_1.getHubFromCarrier;
    exports2.Hub = hub_1.Hub;
    exports2.makeMain = hub_1.makeMain;
    exports2.Scope = hub_1.Scope;
    var api_1 = require_api();
    exports2.API = api_1.API;
    var baseclient_1 = require_baseclient();
    exports2.BaseClient = baseclient_1.BaseClient;
    var basebackend_1 = require_basebackend();
    exports2.BaseBackend = basebackend_1.BaseBackend;
    var request_1 = require_request();
    exports2.eventToSentryRequest = request_1.eventToSentryRequest;
    exports2.sessionToSentryRequest = request_1.sessionToSentryRequest;
    var sdk_1 = require_sdk();
    exports2.initAndBind = sdk_1.initAndBind;
    var noop_1 = require_noop();
    exports2.NoopTransport = noop_1.NoopTransport;
    var version_1 = require_version();
    exports2.SDK_VERSION = version_1.SDK_VERSION;
    var Integrations = require_integrations();
    exports2.Integrations = Integrations;
  }
});

// node_modules/lru_map/lru.js
var require_lru = __commonJS({
  "node_modules/lru_map/lru.js"(exports2) {
    (function(g, f) {
      const e = typeof exports2 == "object" ? exports2 : typeof g == "object" ? g : {};
      f(e);
      if (typeof define == "function" && define.amd) {
        define("lru", e);
      }
    })(exports2, function(exports3) {
      const NEWER = Symbol("newer");
      const OLDER = Symbol("older");
      function LRUMap(limit, entries) {
        if (typeof limit !== "number") {
          entries = limit;
          limit = 0;
        }
        this.size = 0;
        this.limit = limit;
        this.oldest = this.newest = void 0;
        this._keymap = /* @__PURE__ */ new Map();
        if (entries) {
          this.assign(entries);
          if (limit < 1) {
            this.limit = this.size;
          }
        }
      }
      exports3.LRUMap = LRUMap;
      function Entry(key, value) {
        this.key = key;
        this.value = value;
        this[NEWER] = void 0;
        this[OLDER] = void 0;
      }
      LRUMap.prototype._markEntryAsUsed = function(entry) {
        if (entry === this.newest) {
          return;
        }
        if (entry[NEWER]) {
          if (entry === this.oldest) {
            this.oldest = entry[NEWER];
          }
          entry[NEWER][OLDER] = entry[OLDER];
        }
        if (entry[OLDER]) {
          entry[OLDER][NEWER] = entry[NEWER];
        }
        entry[NEWER] = void 0;
        entry[OLDER] = this.newest;
        if (this.newest) {
          this.newest[NEWER] = entry;
        }
        this.newest = entry;
      };
      LRUMap.prototype.assign = function(entries) {
        let entry, limit = this.limit || Number.MAX_VALUE;
        this._keymap.clear();
        let it = entries[Symbol.iterator]();
        for (let itv = it.next(); !itv.done; itv = it.next()) {
          let e = new Entry(itv.value[0], itv.value[1]);
          this._keymap.set(e.key, e);
          if (!entry) {
            this.oldest = e;
          } else {
            entry[NEWER] = e;
            e[OLDER] = entry;
          }
          entry = e;
          if (limit-- == 0) {
            throw new Error("overflow");
          }
        }
        this.newest = entry;
        this.size = this._keymap.size;
      };
      LRUMap.prototype.get = function(key) {
        var entry = this._keymap.get(key);
        if (!entry)
          return;
        this._markEntryAsUsed(entry);
        return entry.value;
      };
      LRUMap.prototype.set = function(key, value) {
        var entry = this._keymap.get(key);
        if (entry) {
          entry.value = value;
          this._markEntryAsUsed(entry);
          return this;
        }
        this._keymap.set(key, entry = new Entry(key, value));
        if (this.newest) {
          this.newest[NEWER] = entry;
          entry[OLDER] = this.newest;
        } else {
          this.oldest = entry;
        }
        this.newest = entry;
        ++this.size;
        if (this.size > this.limit) {
          this.shift();
        }
        return this;
      };
      LRUMap.prototype.shift = function() {
        var entry = this.oldest;
        if (entry) {
          if (this.oldest[NEWER]) {
            this.oldest = this.oldest[NEWER];
            this.oldest[OLDER] = void 0;
          } else {
            this.oldest = void 0;
            this.newest = void 0;
          }
          entry[NEWER] = entry[OLDER] = void 0;
          this._keymap.delete(entry.key);
          --this.size;
          return [entry.key, entry.value];
        }
      };
      LRUMap.prototype.find = function(key) {
        let e = this._keymap.get(key);
        return e ? e.value : void 0;
      };
      LRUMap.prototype.has = function(key) {
        return this._keymap.has(key);
      };
      LRUMap.prototype["delete"] = function(key) {
        var entry = this._keymap.get(key);
        if (!entry)
          return;
        this._keymap.delete(entry.key);
        if (entry[NEWER] && entry[OLDER]) {
          entry[OLDER][NEWER] = entry[NEWER];
          entry[NEWER][OLDER] = entry[OLDER];
        } else if (entry[NEWER]) {
          entry[NEWER][OLDER] = void 0;
          this.oldest = entry[NEWER];
        } else if (entry[OLDER]) {
          entry[OLDER][NEWER] = void 0;
          this.newest = entry[OLDER];
        } else {
          this.oldest = this.newest = void 0;
        }
        this.size--;
        return entry.value;
      };
      LRUMap.prototype.clear = function() {
        this.oldest = this.newest = void 0;
        this.size = 0;
        this._keymap.clear();
      };
      function EntryIterator(oldestEntry) {
        this.entry = oldestEntry;
      }
      EntryIterator.prototype[Symbol.iterator] = function() {
        return this;
      };
      EntryIterator.prototype.next = function() {
        let ent = this.entry;
        if (ent) {
          this.entry = ent[NEWER];
          return { done: false, value: [ent.key, ent.value] };
        } else {
          return { done: true, value: void 0 };
        }
      };
      function KeyIterator(oldestEntry) {
        this.entry = oldestEntry;
      }
      KeyIterator.prototype[Symbol.iterator] = function() {
        return this;
      };
      KeyIterator.prototype.next = function() {
        let ent = this.entry;
        if (ent) {
          this.entry = ent[NEWER];
          return { done: false, value: ent.key };
        } else {
          return { done: true, value: void 0 };
        }
      };
      function ValueIterator(oldestEntry) {
        this.entry = oldestEntry;
      }
      ValueIterator.prototype[Symbol.iterator] = function() {
        return this;
      };
      ValueIterator.prototype.next = function() {
        let ent = this.entry;
        if (ent) {
          this.entry = ent[NEWER];
          return { done: false, value: ent.value };
        } else {
          return { done: true, value: void 0 };
        }
      };
      LRUMap.prototype.keys = function() {
        return new KeyIterator(this.oldest);
      };
      LRUMap.prototype.values = function() {
        return new ValueIterator(this.oldest);
      };
      LRUMap.prototype.entries = function() {
        return this;
      };
      LRUMap.prototype[Symbol.iterator] = function() {
        return new EntryIterator(this.oldest);
      };
      LRUMap.prototype.forEach = function(fun, thisObj) {
        if (typeof thisObj !== "object") {
          thisObj = this;
        }
        let entry = this.oldest;
        while (entry) {
          fun.call(thisObj, entry.value, entry.key, this);
          entry = entry[NEWER];
        }
      };
      LRUMap.prototype.toJSON = function() {
        var s = new Array(this.size), i = 0, entry = this.oldest;
        while (entry) {
          s[i++] = { key: entry.key, value: entry.value };
          entry = entry[NEWER];
        }
        return s;
      };
      LRUMap.prototype.toString = function() {
        var s = "", entry = this.oldest;
        while (entry) {
          s += String(entry.key) + ":" + entry.value;
          entry = entry[NEWER];
          if (entry) {
            s += " < ";
          }
        }
        return s;
      };
    });
  }
});

// node_modules/@sentry/node/dist/stacktrace.js
var require_stacktrace2 = __commonJS({
  "node_modules/@sentry/node/dist/stacktrace.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    function parse(err) {
      if (!err.stack) {
        return [];
      }
      var lines = err.stack.split("\n").slice(1);
      return lines.map(function(line) {
        if (line.match(/^\s*[-]{4,}$/)) {
          return {
            columnNumber: null,
            fileName: line,
            functionName: null,
            lineNumber: null,
            methodName: null,
            native: null,
            typeName: null
          };
        }
        var lineMatch = line.match(/at (?:(.+?)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
          return void 0;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === "native";
        if (lineMatch[1]) {
          functionName = lineMatch[1];
          var methodStart = functionName.lastIndexOf(".");
          if (functionName[methodStart - 1] === ".") {
            methodStart--;
          }
          if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf(".Module");
            if (objectEnd > 0) {
              functionName = functionName.substr(objectEnd + 1);
              object = object.substr(0, objectEnd);
            }
          }
          typeName = null;
        }
        if (method) {
          typeName = object;
          methodName = method;
        }
        if (method === "<anonymous>") {
          methodName = null;
          functionName = null;
        }
        var properties = {
          columnNumber: parseInt(lineMatch[4], 10) || null,
          fileName: lineMatch[2] || null,
          functionName,
          lineNumber: parseInt(lineMatch[3], 10) || null,
          methodName,
          native: isNative,
          typeName
        };
        return properties;
      }).filter(function(callSite) {
        return !!callSite;
      });
    }
    exports2.parse = parse;
  }
});

// node_modules/@sentry/node/dist/parsers.js
var require_parsers = __commonJS({
  "node_modules/@sentry/node/dist/parsers.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var fs_1 = require("fs");
    var lru_map_1 = require_lru();
    var stacktrace = require_stacktrace2();
    var DEFAULT_LINES_OF_CONTEXT = 7;
    var FILE_CONTENT_CACHE = new lru_map_1.LRUMap(100);
    function resetFileContentCache() {
      FILE_CONTENT_CACHE.clear();
    }
    exports2.resetFileContentCache = resetFileContentCache;
    function getFunction(frame) {
      try {
        return frame.functionName || frame.typeName + "." + (frame.methodName || "<anonymous>");
      } catch (e) {
        return "<anonymous>";
      }
    }
    var mainModule = (require.main && require.main.filename && utils_1.dirname(require.main.filename) || global.process.cwd()) + "/";
    function getModule(filename, base) {
      if (!base) {
        base = mainModule;
      }
      var file = utils_1.basename(filename, ".js");
      filename = utils_1.dirname(filename);
      var n = filename.lastIndexOf("/node_modules/");
      if (n > -1) {
        return filename.substr(n + 14).replace(/\//g, ".") + ":" + file;
      }
      n = (filename + "/").lastIndexOf(base, 0);
      if (n === 0) {
        var moduleName = filename.substr(base.length).replace(/\//g, ".");
        if (moduleName) {
          moduleName += ":";
        }
        moduleName += file;
        return moduleName;
      }
      return file;
    }
    function readSourceFiles(filenames) {
      if (filenames.length === 0) {
        return utils_1.SyncPromise.resolve({});
      }
      return new utils_1.SyncPromise(function(resolve) {
        var sourceFiles = {};
        var count = 0;
        var _loop_1 = function(i2) {
          var filename = filenames[i2];
          var cache = FILE_CONTENT_CACHE.get(filename);
          if (cache !== void 0) {
            if (cache !== null) {
              sourceFiles[filename] = cache;
            }
            count++;
            if (count === filenames.length) {
              resolve(sourceFiles);
            }
            return "continue";
          }
          fs_1.readFile(filename, function(err, data) {
            var content = err ? null : data.toString();
            sourceFiles[filename] = content;
            FILE_CONTENT_CACHE.set(filename, content);
            count++;
            if (count === filenames.length) {
              resolve(sourceFiles);
            }
          });
        };
        for (var i = 0; i < filenames.length; i++) {
          _loop_1(i);
        }
      });
    }
    function extractStackFromError(error2) {
      var stack = stacktrace.parse(error2);
      if (!stack) {
        return [];
      }
      return stack;
    }
    exports2.extractStackFromError = extractStackFromError;
    function parseStack(stack, options) {
      var filesToRead = [];
      var linesOfContext = options && options.frameContextLines !== void 0 ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
      var frames = stack.map(function(frame) {
        var _a;
        var parsedFrame = {
          colno: frame.columnNumber,
          filename: ((_a = frame.fileName) === null || _a === void 0 ? void 0 : _a.startsWith("file://")) ? frame.fileName.substr(7) : frame.fileName || "",
          function: getFunction(frame),
          lineno: frame.lineNumber
        };
        var isInternal = frame.native || parsedFrame.filename && !parsedFrame.filename.startsWith("/") && !parsedFrame.filename.startsWith(".") && parsedFrame.filename.indexOf(":\\") !== 1;
        parsedFrame.in_app = !isInternal && parsedFrame.filename !== void 0 && parsedFrame.filename.indexOf("node_modules/") === -1;
        if (parsedFrame.filename) {
          parsedFrame.module = getModule(parsedFrame.filename);
          if (!isInternal && linesOfContext > 0 && filesToRead.indexOf(parsedFrame.filename) === -1) {
            filesToRead.push(parsedFrame.filename);
          }
        }
        return parsedFrame;
      });
      if (linesOfContext <= 0) {
        return utils_1.SyncPromise.resolve(frames);
      }
      try {
        return addPrePostContext(filesToRead, frames, linesOfContext);
      } catch (_) {
        return utils_1.SyncPromise.resolve(frames);
      }
    }
    exports2.parseStack = parseStack;
    function addPrePostContext(filesToRead, frames, linesOfContext) {
      return new utils_1.SyncPromise(function(resolve) {
        return readSourceFiles(filesToRead).then(function(sourceFiles) {
          var result = frames.map(function(frame) {
            if (frame.filename && sourceFiles[frame.filename]) {
              try {
                var lines = sourceFiles[frame.filename].split("\n");
                utils_1.addContextToFrame(lines, frame, linesOfContext);
              } catch (e) {
              }
            }
            return frame;
          });
          resolve(result);
        });
      });
    }
    function getExceptionFromError(error2, options) {
      var name = error2.name || error2.constructor.name;
      var stack = extractStackFromError(error2);
      return new utils_1.SyncPromise(function(resolve) {
        return parseStack(stack, options).then(function(frames) {
          var result = {
            stacktrace: {
              frames: prepareFramesForEvent(frames)
            },
            type: name,
            value: error2.message
          };
          resolve(result);
        });
      });
    }
    exports2.getExceptionFromError = getExceptionFromError;
    function parseError(error2, options) {
      return new utils_1.SyncPromise(function(resolve) {
        return getExceptionFromError(error2, options).then(function(exception) {
          resolve({
            exception: {
              values: [exception]
            }
          });
        });
      });
    }
    exports2.parseError = parseError;
    function prepareFramesForEvent(stack) {
      if (!stack || !stack.length) {
        return [];
      }
      var localStack = stack;
      var firstFrameFunction = localStack[0].function || "";
      if (firstFrameFunction.indexOf("captureMessage") !== -1 || firstFrameFunction.indexOf("captureException") !== -1) {
        localStack = localStack.slice(1);
      }
      return localStack.reverse();
    }
    exports2.prepareFramesForEvent = prepareFramesForEvent;
  }
});

// node_modules/@sentry/node/dist/version.js
var require_version2 = __commonJS({
  "node_modules/@sentry/node/dist/version.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SDK_NAME = "sentry.javascript.node";
  }
});

// node_modules/@sentry/node/dist/transports/base/index.js
var require_base = __commonJS({
  "node_modules/@sentry/node/dist/transports/base/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var fs = require("fs");
    var url_1 = require("url");
    var version_1 = require_version2();
    var CATEGORY_MAPPING = {
      event: "error",
      transaction: "transaction",
      session: "session",
      attachment: "attachment"
    };
    var BaseTransport = function() {
      function BaseTransport2(options) {
        this.options = options;
        this._buffer = new utils_1.PromiseBuffer(30);
        this._rateLimits = {};
        this.urlParser = function(url) {
          return new url_1.URL(url);
        };
        this._api = new core_1.API(options.dsn, options._metadata, options.tunnel);
      }
      BaseTransport2.prototype.sendEvent = function(_) {
        throw new utils_1.SentryError("Transport Class has to implement `sendEvent` method.");
      };
      BaseTransport2.prototype.close = function(timeout) {
        return this._buffer.drain(timeout);
      };
      BaseTransport2.prototype._getProxy = function(protocol) {
        var e_1, _a;
        var _b = process.env, no_proxy = _b.no_proxy, http_proxy = _b.http_proxy, https_proxy = _b.https_proxy;
        var _c = this.options, httpProxy = _c.httpProxy, httpsProxy = _c.httpsProxy;
        var proxy = protocol === "http" ? httpProxy || http_proxy : httpsProxy || httpProxy || https_proxy || http_proxy;
        if (!no_proxy) {
          return proxy;
        }
        var _d = this._api.getDsn(), host = _d.host, port = _d.port;
        try {
          for (var _e = tslib_1.__values(no_proxy.split(",")), _f = _e.next(); !_f.done; _f = _e.next()) {
            var np = _f.value;
            if (host.endsWith(np) || (host + ":" + port).endsWith(np)) {
              return;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_f && !_f.done && (_a = _e.return))
              _a.call(_e);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return proxy;
      };
      BaseTransport2.prototype._getRequestOptions = function(urlParts) {
        var headers = tslib_1.__assign(tslib_1.__assign({}, this._api.getRequestHeaders(version_1.SDK_NAME, core_1.SDK_VERSION)), this.options.headers);
        var hostname = urlParts.hostname, pathname = urlParts.pathname, port = urlParts.port, protocol = urlParts.protocol;
        var path = "" + pathname;
        return tslib_1.__assign({
          agent: this.client,
          headers,
          hostname,
          method: "POST",
          path,
          port,
          protocol
        }, this.options.caCerts && {
          ca: fs.readFileSync(this.options.caCerts)
        });
      };
      BaseTransport2.prototype._disabledUntil = function(requestType) {
        var category = CATEGORY_MAPPING[requestType];
        return this._rateLimits[category] || this._rateLimits.all;
      };
      BaseTransport2.prototype._isRateLimited = function(requestType) {
        return this._disabledUntil(requestType) > new Date(Date.now());
      };
      BaseTransport2.prototype._handleRateLimit = function(headers) {
        var e_2, _a, e_3, _b;
        var now = Date.now();
        var rlHeader = headers["x-sentry-rate-limits"];
        var raHeader = headers["retry-after"];
        if (rlHeader) {
          try {
            for (var _c = tslib_1.__values(rlHeader.trim().split(",")), _d = _c.next(); !_d.done; _d = _c.next()) {
              var limit = _d.value;
              var parameters = limit.split(":", 2);
              var headerDelay = parseInt(parameters[0], 10);
              var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
              try {
                for (var _e = (e_3 = void 0, tslib_1.__values(parameters[1] && parameters[1].split(";") || ["all"])), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var category = _f.value;
                  var categoriesAllowed = tslib_1.__spread(Object.keys(CATEGORY_MAPPING).map(function(k) {
                    return CATEGORY_MAPPING[k];
                  }), [
                    "all"
                  ]);
                  if (categoriesAllowed.includes(category))
                    this._rateLimits[category] = new Date(now + delay);
                }
              } catch (e_3_1) {
                e_3 = { error: e_3_1 };
              } finally {
                try {
                  if (_f && !_f.done && (_b = _e.return))
                    _b.call(_e);
                } finally {
                  if (e_3)
                    throw e_3.error;
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_d && !_d.done && (_a = _c.return))
                _a.call(_c);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
          return true;
        } else if (raHeader) {
          this._rateLimits.all = new Date(now + utils_1.parseRetryAfterHeader(now, raHeader));
          return true;
        }
        return false;
      };
      BaseTransport2.prototype._send = function(sentryRequest, originalPayload) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var _this = this;
          return tslib_1.__generator(this, function(_a) {
            if (!this.module) {
              throw new utils_1.SentryError("No module available");
            }
            if (originalPayload && this._isRateLimited(sentryRequest.type)) {
              return [2, Promise.reject({
                payload: originalPayload,
                type: sentryRequest.type,
                reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
                status: 429
              })];
            }
            return [2, this._buffer.add(function() {
              return new Promise(function(resolve, reject) {
                if (!_this.module) {
                  throw new utils_1.SentryError("No module available");
                }
                var options = _this._getRequestOptions(_this.urlParser(sentryRequest.url));
                var req = _this.module.request(options, function(res) {
                  var statusCode = res.statusCode || 500;
                  var status = types_1.Status.fromHttpCode(statusCode);
                  res.setEncoding("utf8");
                  var retryAfterHeader = res.headers ? res.headers["retry-after"] : "";
                  retryAfterHeader = Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader;
                  var rlHeader = res.headers ? res.headers["x-sentry-rate-limits"] : "";
                  rlHeader = Array.isArray(rlHeader) ? rlHeader[0] : rlHeader;
                  var headers = {
                    "x-sentry-rate-limits": rlHeader,
                    "retry-after": retryAfterHeader
                  };
                  var limited = _this._handleRateLimit(headers);
                  if (limited)
                    utils_1.logger.warn("Too many " + sentryRequest.type + " requests, backing off until: " + _this._disabledUntil(sentryRequest.type));
                  if (status === types_1.Status.Success) {
                    resolve({ status });
                  } else {
                    var rejectionMessage = "HTTP Error (" + statusCode + ")";
                    if (res.headers && res.headers["x-sentry-error"]) {
                      rejectionMessage += ": " + res.headers["x-sentry-error"];
                    }
                    reject(new utils_1.SentryError(rejectionMessage));
                  }
                  res.on("data", function() {
                  });
                  res.on("end", function() {
                  });
                });
                req.on("error", reject);
                req.end(sentryRequest.body);
              });
            })];
          });
        });
      };
      return BaseTransport2;
    }();
    exports2.BaseTransport = BaseTransport;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match2) {
        return;
      }
      var n = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
            if (match2 === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match2 = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match2;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index++;
        if (match2 === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters: formatters3 } = module2.exports;
    formatters3.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/supports-color/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/supports-color/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env: env2 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init2;
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters: formatters3 } = module2.exports;
    formatters3.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters3.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "node_modules/agent-base/dist/src/promisify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function promisify(fn) {
      return function(req, opts) {
        return new Promise((resolve, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve(rtn);
            }
          });
        });
      };
    }
    exports2.default = promisify;
  }
});

// node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/agent-base/dist/src/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = require("events");
    var debug_1 = __importDefault(require_src());
    var promisify_1 = __importDefault(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports2.default = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "node_modules/https-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              const servername = opts.servername || opts.host;
              if (!servername) {
                throw new Error('Could not determine "servername"');
              }
              debug("Upgrading socket connection to TLS");
              return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket();
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports2.default = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpsProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent2) {
      createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
    module2.exports = createHttpsProxyAgent;
  }
});

// node_modules/@sentry/node/dist/transports/http.js
var require_http = __commonJS({
  "node_modules/@sentry/node/dist/transports/http.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var http = require("http");
    var base_1 = require_base();
    var HTTPTransport = function(_super) {
      tslib_1.__extends(HTTPTransport2, _super);
      function HTTPTransport2(options) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        var proxy = _this._getProxy("http");
        _this.module = http;
        _this.client = proxy ? new (require_dist6())(proxy) : new http.Agent({ keepAlive: false, maxSockets: 30, timeout: 2e3 });
        return _this;
      }
      HTTPTransport2.prototype.sendEvent = function(event) {
        return this._send(core_1.eventToSentryRequest(event, this._api), event);
      };
      HTTPTransport2.prototype.sendSession = function(session) {
        return this._send(core_1.sessionToSentryRequest(session, this._api), session);
      };
      return HTTPTransport2;
    }(base_1.BaseTransport);
    exports2.HTTPTransport = HTTPTransport;
  }
});

// node_modules/@sentry/node/dist/transports/https.js
var require_https = __commonJS({
  "node_modules/@sentry/node/dist/transports/https.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var https = require("https");
    var base_1 = require_base();
    var HTTPSTransport = function(_super) {
      tslib_1.__extends(HTTPSTransport2, _super);
      function HTTPSTransport2(options) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        var proxy = _this._getProxy("https");
        _this.module = https;
        _this.client = proxy ? new (require_dist6())(proxy) : new https.Agent({ keepAlive: false, maxSockets: 30, timeout: 2e3 });
        return _this;
      }
      HTTPSTransport2.prototype.sendEvent = function(event) {
        return this._send(core_1.eventToSentryRequest(event, this._api), event);
      };
      HTTPSTransport2.prototype.sendSession = function(session) {
        return this._send(core_1.sessionToSentryRequest(session, this._api), session);
      };
      return HTTPSTransport2;
    }(base_1.BaseTransport);
    exports2.HTTPSTransport = HTTPSTransport;
  }
});

// node_modules/@sentry/node/dist/transports/index.js
var require_transports = __commonJS({
  "node_modules/@sentry/node/dist/transports/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base_1 = require_base();
    exports2.BaseTransport = base_1.BaseTransport;
    var http_1 = require_http();
    exports2.HTTPTransport = http_1.HTTPTransport;
    var https_1 = require_https();
    exports2.HTTPSTransport = https_1.HTTPSTransport;
  }
});

// node_modules/@sentry/node/dist/backend.js
var require_backend = __commonJS({
  "node_modules/@sentry/node/dist/backend.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var parsers_1 = require_parsers();
    var transports_1 = require_transports();
    var NodeBackend = function(_super) {
      tslib_1.__extends(NodeBackend2, _super);
      function NodeBackend2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NodeBackend2.prototype.eventFromException = function(exception, hint) {
        var _this = this;
        var ex = exception;
        var providedMechanism = hint && hint.data && hint.data.mechanism;
        var mechanism = providedMechanism || {
          handled: true,
          type: "generic"
        };
        if (!utils_1.isError(exception)) {
          if (utils_1.isPlainObject(exception)) {
            var message = "Non-Error exception captured with keys: " + utils_1.extractExceptionKeysForMessage(exception);
            core_1.getCurrentHub().configureScope(function(scope) {
              scope.setExtra("__serialized__", utils_1.normalizeToSize(exception));
            });
            ex = hint && hint.syntheticException || new Error(message);
            ex.message = message;
          } else {
            ex = hint && hint.syntheticException || new Error(exception);
            ex.message = exception;
          }
          mechanism.synthetic = true;
        }
        return new utils_1.SyncPromise(function(resolve, reject) {
          return parsers_1.parseError(ex, _this._options).then(function(event) {
            utils_1.addExceptionTypeValue(event, void 0, void 0);
            utils_1.addExceptionMechanism(event, mechanism);
            resolve(tslib_1.__assign(tslib_1.__assign({}, event), { event_id: hint && hint.event_id }));
          }).then(null, reject);
        });
      };
      NodeBackend2.prototype.eventFromMessage = function(message, level, hint) {
        var _this = this;
        if (level === void 0) {
          level = types_1.Severity.Info;
        }
        var event = {
          event_id: hint && hint.event_id,
          level,
          message
        };
        return new utils_1.SyncPromise(function(resolve) {
          if (_this._options.attachStacktrace && hint && hint.syntheticException) {
            var stack = hint.syntheticException ? parsers_1.extractStackFromError(hint.syntheticException) : [];
            void parsers_1.parseStack(stack, _this._options).then(function(frames) {
              event.stacktrace = {
                frames: parsers_1.prepareFramesForEvent(frames)
              };
              resolve(event);
            }).then(null, function() {
              resolve(event);
            });
          } else {
            resolve(event);
          }
        });
      };
      NodeBackend2.prototype._setupTransport = function() {
        if (!this._options.dsn) {
          return _super.prototype._setupTransport.call(this);
        }
        var dsn = new utils_1.Dsn(this._options.dsn);
        var transportOptions = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, this._options.transportOptions), this._options.httpProxy && { httpProxy: this._options.httpProxy }), this._options.httpsProxy && { httpsProxy: this._options.httpsProxy }), this._options.caCerts && { caCerts: this._options.caCerts }), { dsn: this._options.dsn, tunnel: this._options.tunnel, _metadata: this._options._metadata });
        if (this._options.transport) {
          return new this._options.transport(transportOptions);
        }
        if (dsn.protocol === "http") {
          return new transports_1.HTTPTransport(transportOptions);
        }
        return new transports_1.HTTPSTransport(transportOptions);
      };
      return NodeBackend2;
    }(core_1.BaseBackend);
    exports2.NodeBackend = NodeBackend;
  }
});

// node_modules/@sentry/node/dist/client.js
var require_client = __commonJS({
  "node_modules/@sentry/node/dist/client.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var hub_1 = require_dist3();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var backend_1 = require_backend();
    var NodeClient = function(_super) {
      tslib_1.__extends(NodeClient2, _super);
      function NodeClient2(options) {
        var _this = this;
        options._metadata = options._metadata || {};
        options._metadata.sdk = options._metadata.sdk || {
          name: "sentry.javascript.node",
          packages: [
            {
              name: "npm:@sentry/node",
              version: core_1.SDK_VERSION
            }
          ],
          version: core_1.SDK_VERSION
        };
        _this = _super.call(this, backend_1.NodeBackend, options) || this;
        return _this;
      }
      NodeClient2.prototype.captureException = function(exception, hint, scope) {
        if (this._options.autoSessionTracking && this._sessionFlusher && scope) {
          var requestSession = scope.getRequestSession();
          if (requestSession && requestSession.status === types_1.RequestSessionStatus.Ok) {
            requestSession.status = types_1.RequestSessionStatus.Errored;
          }
        }
        return _super.prototype.captureException.call(this, exception, hint, scope);
      };
      NodeClient2.prototype.captureEvent = function(event, hint, scope) {
        if (this._options.autoSessionTracking && this._sessionFlusher && scope) {
          var eventType = event.type || "exception";
          var isException = eventType === "exception" && event.exception && event.exception.values && event.exception.values.length > 0;
          if (isException) {
            var requestSession = scope.getRequestSession();
            if (requestSession && requestSession.status === types_1.RequestSessionStatus.Ok) {
              requestSession.status = types_1.RequestSessionStatus.Errored;
            }
          }
        }
        return _super.prototype.captureEvent.call(this, event, hint, scope);
      };
      NodeClient2.prototype.close = function(timeout) {
        var _a;
        (_a = this._sessionFlusher) === null || _a === void 0 ? void 0 : _a.close();
        return _super.prototype.close.call(this, timeout);
      };
      NodeClient2.prototype.initSessionFlusher = function() {
        var _a = this._options, release = _a.release, environment = _a.environment;
        if (!release) {
          utils_1.logger.warn("Cannot initialise an instance of SessionFlusher if no release is provided!");
        } else {
          this._sessionFlusher = new hub_1.SessionFlusher(this.getTransport(), {
            release,
            environment
          });
        }
      };
      NodeClient2.prototype._prepareEvent = function(event, scope, hint) {
        event.platform = event.platform || "node";
        if (this.getOptions().serverName) {
          event.server_name = this.getOptions().serverName;
        }
        return _super.prototype._prepareEvent.call(this, event, scope, hint);
      };
      NodeClient2.prototype._captureRequestSession = function() {
        if (!this._sessionFlusher) {
          utils_1.logger.warn("Discarded request mode session because autoSessionTracking option was disabled");
        } else {
          this._sessionFlusher.incrementSessionStatusCount();
        }
      };
      return NodeClient2;
    }(core_1.BaseClient);
    exports2.NodeClient = NodeClient;
  }
});

// node_modules/@sentry/node/dist/integrations/console.js
var require_console = __commonJS({
  "node_modules/@sentry/node/dist/integrations/console.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var util = require("util");
    var Console = function() {
      function Console2() {
        this.name = Console2.id;
      }
      Console2.prototype.setupOnce = function() {
        var e_1, _a;
        try {
          for (var _b = tslib_1.__values(["debug", "info", "warn", "error", "log"]), _c = _b.next(); !_c.done; _c = _b.next()) {
            var level = _c.value;
            utils_1.fill(console, level, createConsoleWrapper(level));
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      };
      Console2.id = "Console";
      return Console2;
    }();
    exports2.Console = Console;
    function createConsoleWrapper(level) {
      return function consoleWrapper(originalConsoleMethod) {
        var sentryLevel;
        switch (level) {
          case "debug":
            sentryLevel = types_1.Severity.Debug;
            break;
          case "error":
            sentryLevel = types_1.Severity.Error;
            break;
          case "info":
            sentryLevel = types_1.Severity.Info;
            break;
          case "warn":
            sentryLevel = types_1.Severity.Warning;
            break;
          default:
            sentryLevel = types_1.Severity.Log;
        }
        return function() {
          if (core_1.getCurrentHub().getIntegration(Console)) {
            core_1.getCurrentHub().addBreadcrumb({
              category: "console",
              level: sentryLevel,
              message: util.format.apply(void 0, arguments)
            }, {
              input: tslib_1.__spread(arguments),
              level
            });
          }
          originalConsoleMethod.apply(this, arguments);
        };
      };
    }
  }
});

// node_modules/@sentry/node/dist/integrations/utils/http.js
var require_http2 = __commonJS({
  "node_modules/@sentry/node/dist/integrations/utils/http.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var utils_1 = require_dist2();
    var url_1 = require("url");
    var NODE_VERSION = utils_1.parseSemver(process.versions.node);
    function isSentryRequest(url) {
      var _a;
      var dsn = (_a = core_1.getCurrentHub().getClient()) === null || _a === void 0 ? void 0 : _a.getDsn();
      return dsn ? url.includes(dsn.host) : false;
    }
    exports2.isSentryRequest = isSentryRequest;
    function extractUrl(requestOptions) {
      var protocol = requestOptions.protocol || "";
      var hostname = requestOptions.hostname || requestOptions.host || "";
      var port = !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 ? "" : ":" + requestOptions.port;
      var path = requestOptions.path ? requestOptions.path : "/";
      return protocol + "//" + hostname + port + path;
    }
    exports2.extractUrl = extractUrl;
    function cleanSpanDescription(description, requestOptions, request) {
      var _a, _b, _c;
      if (!description) {
        return description;
      }
      var _d = tslib_1.__read(description.split(" "), 2), method = _d[0], requestUrl = _d[1];
      if (requestOptions.host && !requestOptions.protocol) {
        requestOptions.protocol = (_b = (_a = request) === null || _a === void 0 ? void 0 : _a.agent) === null || _b === void 0 ? void 0 : _b.protocol;
        requestUrl = extractUrl(requestOptions);
      }
      if ((_c = requestUrl) === null || _c === void 0 ? void 0 : _c.startsWith("///")) {
        requestUrl = requestUrl.slice(2);
      }
      return method + " " + requestUrl;
    }
    exports2.cleanSpanDescription = cleanSpanDescription;
    function urlToOptions(url) {
      var options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === "string" && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        path: "" + (url.pathname || "") + (url.search || ""),
        href: url.href
      };
      if (url.port !== "") {
        options.port = Number(url.port);
      }
      if (url.username || url.password) {
        options.auth = url.username + ":" + url.password;
      }
      return options;
    }
    exports2.urlToOptions = urlToOptions;
    function normalizeRequestArgs(httpModule, requestArgs) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      var callback, requestOptions;
      if (typeof requestArgs[requestArgs.length - 1] === "function") {
        callback = requestArgs.pop();
      }
      if (typeof requestArgs[0] === "string") {
        requestOptions = urlToOptions(new url_1.URL(requestArgs[0]));
      } else if (requestArgs[0] instanceof url_1.URL) {
        requestOptions = urlToOptions(requestArgs[0]);
      } else {
        requestOptions = requestArgs[0];
      }
      if (requestArgs.length === 2) {
        requestOptions = tslib_1.__assign(tslib_1.__assign({}, requestOptions), requestArgs[1]);
      }
      if (requestOptions.protocol === void 0) {
        if (NODE_VERSION.major && NODE_VERSION.major > 8) {
          requestOptions.protocol = ((_b = (_a = httpModule) === null || _a === void 0 ? void 0 : _a.globalAgent) === null || _b === void 0 ? void 0 : _b.protocol) || ((_c = requestOptions.agent) === null || _c === void 0 ? void 0 : _c.protocol) || ((_d = requestOptions._defaultAgent) === null || _d === void 0 ? void 0 : _d.protocol);
        } else {
          requestOptions.protocol = ((_e = requestOptions.agent) === null || _e === void 0 ? void 0 : _e.protocol) || ((_f = requestOptions._defaultAgent) === null || _f === void 0 ? void 0 : _f.protocol) || ((_h = (_g = httpModule) === null || _g === void 0 ? void 0 : _g.globalAgent) === null || _h === void 0 ? void 0 : _h.protocol);
        }
      }
      if (callback) {
        return [requestOptions, callback];
      } else {
        return [requestOptions];
      }
    }
    exports2.normalizeRequestArgs = normalizeRequestArgs;
  }
});

// node_modules/@sentry/node/dist/integrations/http.js
var require_http3 = __commonJS({
  "node_modules/@sentry/node/dist/integrations/http.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var utils_1 = require_dist2();
    var http_1 = require_http2();
    var NODE_VERSION = utils_1.parseSemver(process.versions.node);
    var Http = function() {
      function Http2(options) {
        if (options === void 0) {
          options = {};
        }
        this.name = Http2.id;
        this._breadcrumbs = typeof options.breadcrumbs === "undefined" ? true : options.breadcrumbs;
        this._tracing = typeof options.tracing === "undefined" ? false : options.tracing;
      }
      Http2.prototype.setupOnce = function() {
        if (!this._breadcrumbs && !this._tracing) {
          return;
        }
        var wrappedHandlerMaker = _createWrappedRequestMethodFactory(this._breadcrumbs, this._tracing);
        var httpModule = require("http");
        utils_1.fill(httpModule, "get", wrappedHandlerMaker);
        utils_1.fill(httpModule, "request", wrappedHandlerMaker);
        if (NODE_VERSION.major && NODE_VERSION.major > 8) {
          var httpsModule = require("https");
          utils_1.fill(httpsModule, "get", wrappedHandlerMaker);
          utils_1.fill(httpsModule, "request", wrappedHandlerMaker);
        }
      };
      Http2.id = "Http";
      return Http2;
    }();
    exports2.Http = Http;
    function _createWrappedRequestMethodFactory(breadcrumbsEnabled, tracingEnabled) {
      return function wrappedRequestMethodFactory(originalRequestMethod) {
        return function wrappedMethod() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var httpModule = this;
          var requestArgs = http_1.normalizeRequestArgs(this, args);
          var requestOptions = requestArgs[0];
          var requestUrl = http_1.extractUrl(requestOptions);
          if (http_1.isSentryRequest(requestUrl)) {
            return originalRequestMethod.apply(httpModule, requestArgs);
          }
          var span;
          var parentSpan;
          var scope = core_1.getCurrentHub().getScope();
          if (scope && tracingEnabled) {
            parentSpan = scope.getSpan();
            if (parentSpan) {
              span = parentSpan.startChild({
                description: (requestOptions.method || "GET") + " " + requestUrl,
                op: "request"
              });
              var sentryTraceHeader = span.toTraceparent();
              utils_1.logger.log("[Tracing] Adding sentry-trace header " + sentryTraceHeader + " to outgoing request to " + requestUrl + ": ");
              requestOptions.headers = tslib_1.__assign(tslib_1.__assign({}, requestOptions.headers), { "sentry-trace": sentryTraceHeader });
            }
          }
          return originalRequestMethod.apply(httpModule, requestArgs).once("response", function(res) {
            var req = this;
            if (breadcrumbsEnabled) {
              addRequestBreadcrumb("response", requestUrl, req, res);
            }
            if (tracingEnabled && span) {
              if (res.statusCode) {
                span.setHttpStatus(res.statusCode);
              }
              span.description = http_1.cleanSpanDescription(span.description, requestOptions, req);
              span.finish();
            }
          }).once("error", function() {
            var req = this;
            if (breadcrumbsEnabled) {
              addRequestBreadcrumb("error", requestUrl, req);
            }
            if (tracingEnabled && span) {
              span.setHttpStatus(500);
              span.description = http_1.cleanSpanDescription(span.description, requestOptions, req);
              span.finish();
            }
          });
        };
      };
    }
    function addRequestBreadcrumb(event, url, req, res) {
      if (!core_1.getCurrentHub().getIntegration(Http)) {
        return;
      }
      core_1.getCurrentHub().addBreadcrumb({
        category: "http",
        data: {
          method: req.method,
          status_code: res && res.statusCode,
          url
        },
        type: "http"
      }, {
        event,
        request: req,
        response: res
      });
    }
  }
});

// node_modules/@sentry/node/dist/integrations/utils/errorhandling.js
var require_errorhandling = __commonJS({
  "node_modules/@sentry/node/dist/integrations/utils/errorhandling.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_dist5();
    var utils_1 = require_dist2();
    var DEFAULT_SHUTDOWN_TIMEOUT = 2e3;
    function logAndExitProcess(error2) {
      console.error(error2 && error2.stack ? error2.stack : error2);
      var client = core_1.getCurrentHub().getClient();
      if (client === void 0) {
        utils_1.logger.warn("No NodeClient was defined, we are exiting the process now.");
        global.process.exit(1);
        return;
      }
      var options = client.getOptions();
      var timeout = options && options.shutdownTimeout && options.shutdownTimeout > 0 && options.shutdownTimeout || DEFAULT_SHUTDOWN_TIMEOUT;
      utils_1.forget(client.close(timeout).then(function(result) {
        if (!result) {
          utils_1.logger.warn("We reached the timeout for emptying the request buffer, still exiting now!");
        }
        global.process.exit(1);
      }));
    }
    exports2.logAndExitProcess = logAndExitProcess;
  }
});

// node_modules/@sentry/node/dist/integrations/onuncaughtexception.js
var require_onuncaughtexception = __commonJS({
  "node_modules/@sentry/node/dist/integrations/onuncaughtexception.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_dist5();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var errorhandling_1 = require_errorhandling();
    var OnUncaughtException = function() {
      function OnUncaughtException2(_options) {
        if (_options === void 0) {
          _options = {};
        }
        this._options = _options;
        this.name = OnUncaughtException2.id;
        this.handler = this._makeErrorHandler();
      }
      OnUncaughtException2.prototype.setupOnce = function() {
        global.process.on("uncaughtException", this.handler.bind(this));
      };
      OnUncaughtException2.prototype._makeErrorHandler = function() {
        var _this = this;
        var timeout = 2e3;
        var caughtFirstError = false;
        var caughtSecondError = false;
        var calledFatalError = false;
        var firstError;
        return function(error2) {
          var onFatalError = errorhandling_1.logAndExitProcess;
          var client = core_1.getCurrentHub().getClient();
          if (_this._options.onFatalError) {
            onFatalError = _this._options.onFatalError;
          } else if (client && client.getOptions().onFatalError) {
            onFatalError = client.getOptions().onFatalError;
          }
          if (!caughtFirstError) {
            var hub_1 = core_1.getCurrentHub();
            firstError = error2;
            caughtFirstError = true;
            if (hub_1.getIntegration(OnUncaughtException2)) {
              hub_1.withScope(function(scope) {
                scope.setLevel(types_1.Severity.Fatal);
                hub_1.captureException(error2, {
                  originalException: error2,
                  data: { mechanism: { handled: false, type: "onuncaughtexception" } }
                });
                if (!calledFatalError) {
                  calledFatalError = true;
                  onFatalError(error2);
                }
              });
            } else {
              if (!calledFatalError) {
                calledFatalError = true;
                onFatalError(error2);
              }
            }
          } else if (calledFatalError) {
            utils_1.logger.warn("uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown");
            errorhandling_1.logAndExitProcess(error2);
          } else if (!caughtSecondError) {
            caughtSecondError = true;
            setTimeout(function() {
              if (!calledFatalError) {
                calledFatalError = true;
                onFatalError(firstError, error2);
              } else {
              }
            }, timeout);
          }
        };
      };
      OnUncaughtException2.id = "OnUncaughtException";
      return OnUncaughtException2;
    }();
    exports2.OnUncaughtException = OnUncaughtException;
  }
});

// node_modules/@sentry/node/dist/integrations/onunhandledrejection.js
var require_onunhandledrejection = __commonJS({
  "node_modules/@sentry/node/dist/integrations/onunhandledrejection.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_dist5();
    var utils_1 = require_dist2();
    var errorhandling_1 = require_errorhandling();
    var OnUnhandledRejection = function() {
      function OnUnhandledRejection2(_options) {
        if (_options === void 0) {
          _options = { mode: "warn" };
        }
        this._options = _options;
        this.name = OnUnhandledRejection2.id;
      }
      OnUnhandledRejection2.prototype.setupOnce = function() {
        global.process.on("unhandledRejection", this.sendUnhandledPromise.bind(this));
      };
      OnUnhandledRejection2.prototype.sendUnhandledPromise = function(reason, promise) {
        var hub = core_1.getCurrentHub();
        if (!hub.getIntegration(OnUnhandledRejection2)) {
          this._handleRejection(reason);
          return;
        }
        var context = promise.domain && promise.domain.sentryContext || {};
        hub.withScope(function(scope) {
          scope.setExtra("unhandledPromiseRejection", true);
          if (context.user) {
            scope.setUser(context.user);
          }
          if (context.tags) {
            scope.setTags(context.tags);
          }
          if (context.extra) {
            scope.setExtras(context.extra);
          }
          hub.captureException(reason, {
            originalException: promise,
            data: { mechanism: { handled: false, type: "onunhandledrejection" } }
          });
        });
        this._handleRejection(reason);
      };
      OnUnhandledRejection2.prototype._handleRejection = function(reason) {
        var rejectionWarning = "This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason:";
        if (this._options.mode === "warn") {
          utils_1.consoleSandbox(function() {
            console.warn(rejectionWarning);
            console.error(reason && reason.stack ? reason.stack : reason);
          });
        } else if (this._options.mode === "strict") {
          utils_1.consoleSandbox(function() {
            console.warn(rejectionWarning);
          });
          errorhandling_1.logAndExitProcess(reason);
        }
      };
      OnUnhandledRejection2.id = "OnUnhandledRejection";
      return OnUnhandledRejection2;
    }();
    exports2.OnUnhandledRejection = OnUnhandledRejection;
  }
});

// node_modules/@sentry/node/dist/integrations/linkederrors.js
var require_linkederrors = __commonJS({
  "node_modules/@sentry/node/dist/integrations/linkederrors.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var utils_1 = require_dist2();
    var parsers_1 = require_parsers();
    var DEFAULT_KEY = "cause";
    var DEFAULT_LIMIT = 5;
    var LinkedErrors = function() {
      function LinkedErrors2(options) {
        if (options === void 0) {
          options = {};
        }
        this.name = LinkedErrors2.id;
        this._key = options.key || DEFAULT_KEY;
        this._limit = options.limit || DEFAULT_LIMIT;
      }
      LinkedErrors2.prototype.setupOnce = function() {
        core_1.addGlobalEventProcessor(function(event, hint) {
          var self2 = core_1.getCurrentHub().getIntegration(LinkedErrors2);
          if (self2) {
            var handler = self2._handler && self2._handler.bind(self2);
            return typeof handler === "function" ? handler(event, hint) : event;
          }
          return event;
        });
      };
      LinkedErrors2.prototype._handler = function(event, hint) {
        var _this = this;
        if (!event.exception || !event.exception.values || !hint || !utils_1.isInstanceOf(hint.originalException, Error)) {
          return utils_1.SyncPromise.resolve(event);
        }
        return new utils_1.SyncPromise(function(resolve) {
          void _this._walkErrorTree(hint.originalException, _this._key).then(function(linkedErrors) {
            if (event && event.exception && event.exception.values) {
              event.exception.values = tslib_1.__spread(linkedErrors, event.exception.values);
            }
            resolve(event);
          }).then(null, function() {
            resolve(event);
          });
        });
      };
      LinkedErrors2.prototype._walkErrorTree = function(error2, key, stack) {
        var _this = this;
        if (stack === void 0) {
          stack = [];
        }
        if (!utils_1.isInstanceOf(error2[key], Error) || stack.length + 1 >= this._limit) {
          return utils_1.SyncPromise.resolve(stack);
        }
        return new utils_1.SyncPromise(function(resolve, reject) {
          void parsers_1.getExceptionFromError(error2[key]).then(function(exception) {
            void _this._walkErrorTree(error2[key], key, tslib_1.__spread([exception], stack)).then(resolve).then(null, function() {
              reject();
            });
          }).then(null, function() {
            reject();
          });
        });
      };
      LinkedErrors2.id = "LinkedErrors";
      return LinkedErrors2;
    }();
    exports2.LinkedErrors = LinkedErrors;
  }
});

// node_modules/@sentry/node/dist/integrations/modules.js
var require_modules = __commonJS({
  "node_modules/@sentry/node/dist/integrations/modules.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var fs_1 = require("fs");
    var path_1 = require("path");
    var moduleCache;
    function getPaths() {
      try {
        return require.cache ? Object.keys(require.cache) : [];
      } catch (e) {
        return [];
      }
    }
    function collectModules() {
      var mainPaths = require.main && require.main.paths || [];
      var paths = getPaths();
      var infos = {};
      var seen = {};
      paths.forEach(function(path) {
        var dir = path;
        var updir = function() {
          var orig = dir;
          dir = path_1.dirname(orig);
          if (!dir || orig === dir || seen[orig]) {
            return void 0;
          }
          if (mainPaths.indexOf(dir) < 0) {
            return updir();
          }
          var pkgfile = path_1.join(orig, "package.json");
          seen[orig] = true;
          if (!fs_1.existsSync(pkgfile)) {
            return updir();
          }
          try {
            var info = JSON.parse(fs_1.readFileSync(pkgfile, "utf8"));
            infos[info.name] = info.version;
          } catch (_oO) {
          }
        };
        updir();
      });
      return infos;
    }
    var Modules = function() {
      function Modules2() {
        this.name = Modules2.id;
      }
      Modules2.prototype.setupOnce = function(addGlobalEventProcessor, getCurrentHub) {
        var _this = this;
        addGlobalEventProcessor(function(event) {
          if (!getCurrentHub().getIntegration(Modules2)) {
            return event;
          }
          return tslib_1.__assign(tslib_1.__assign({}, event), { modules: _this._getModules() });
        });
      };
      Modules2.prototype._getModules = function() {
        if (!moduleCache) {
          moduleCache = collectModules();
        }
        return moduleCache;
      };
      Modules2.id = "Modules";
      return Modules2;
    }();
    exports2.Modules = Modules;
  }
});

// node_modules/@sentry/node/dist/integrations/index.js
var require_integrations2 = __commonJS({
  "node_modules/@sentry/node/dist/integrations/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var console_1 = require_console();
    exports2.Console = console_1.Console;
    var http_1 = require_http3();
    exports2.Http = http_1.Http;
    var onuncaughtexception_1 = require_onuncaughtexception();
    exports2.OnUncaughtException = onuncaughtexception_1.OnUncaughtException;
    var onunhandledrejection_1 = require_onunhandledrejection();
    exports2.OnUnhandledRejection = onunhandledrejection_1.OnUnhandledRejection;
    var linkederrors_1 = require_linkederrors();
    exports2.LinkedErrors = linkederrors_1.LinkedErrors;
    var modules_1 = require_modules();
    exports2.Modules = modules_1.Modules;
  }
});

// node_modules/@sentry/node/dist/sdk.js
var require_sdk2 = __commonJS({
  "node_modules/@sentry/node/dist/sdk.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var hub_1 = require_dist3();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var domain = require("domain");
    var client_1 = require_client();
    var integrations_1 = require_integrations2();
    exports2.defaultIntegrations = [
      new core_1.Integrations.InboundFilters(),
      new core_1.Integrations.FunctionToString(),
      new integrations_1.Console(),
      new integrations_1.Http(),
      new integrations_1.OnUncaughtException(),
      new integrations_1.OnUnhandledRejection(),
      new integrations_1.LinkedErrors()
    ];
    function init2(options) {
      if (options === void 0) {
        options = {};
      }
      var _a;
      var carrier = hub_1.getMainCarrier();
      var autoloadedIntegrations = ((_a = carrier.__SENTRY__) === null || _a === void 0 ? void 0 : _a.integrations) || [];
      options.defaultIntegrations = options.defaultIntegrations === false ? [] : tslib_1.__spread(Array.isArray(options.defaultIntegrations) ? options.defaultIntegrations : exports2.defaultIntegrations, autoloadedIntegrations);
      if (options.dsn === void 0 && process.env.SENTRY_DSN) {
        options.dsn = process.env.SENTRY_DSN;
      }
      if (options.tracesSampleRate === void 0 && process.env.SENTRY_TRACES_SAMPLE_RATE) {
        var tracesSampleRate = parseFloat(process.env.SENTRY_TRACES_SAMPLE_RATE);
        if (isFinite(tracesSampleRate)) {
          options.tracesSampleRate = tracesSampleRate;
        }
      }
      if (options.release === void 0) {
        var detectedRelease = getSentryRelease();
        if (detectedRelease !== void 0) {
          options.release = detectedRelease;
        } else {
          options.autoSessionTracking = false;
        }
      }
      if (options.environment === void 0 && process.env.SENTRY_ENVIRONMENT) {
        options.environment = process.env.SENTRY_ENVIRONMENT;
      }
      if (options.autoSessionTracking === void 0 && options.dsn !== void 0) {
        options.autoSessionTracking = true;
      }
      if (domain.active) {
        hub_1.setHubOnCarrier(carrier, core_1.getCurrentHub());
      }
      core_1.initAndBind(client_1.NodeClient, options);
      if (options.autoSessionTracking) {
        startSessionTracking();
      }
    }
    exports2.init = init2;
    function lastEventId() {
      return core_1.getCurrentHub().lastEventId();
    }
    exports2.lastEventId = lastEventId;
    function flush(timeout) {
      return tslib_1.__awaiter(this, void 0, void 0, function() {
        var client;
        return tslib_1.__generator(this, function(_a) {
          client = core_1.getCurrentHub().getClient();
          if (client) {
            return [2, client.flush(timeout)];
          }
          utils_1.logger.warn("Cannot flush events. No client defined.");
          return [2, Promise.resolve(false)];
        });
      });
    }
    exports2.flush = flush;
    function close(timeout) {
      return tslib_1.__awaiter(this, void 0, void 0, function() {
        var client;
        return tslib_1.__generator(this, function(_a) {
          client = core_1.getCurrentHub().getClient();
          if (client) {
            return [2, client.close(timeout)];
          }
          utils_1.logger.warn("Cannot flush events and disable SDK. No client defined.");
          return [2, Promise.resolve(false)];
        });
      });
    }
    exports2.close = close;
    function isAutoSessionTrackingEnabled(client) {
      if (client === void 0) {
        return false;
      }
      var clientOptions = client && client.getOptions();
      if (clientOptions && clientOptions.autoSessionTracking !== void 0) {
        return clientOptions.autoSessionTracking;
      }
      return false;
    }
    exports2.isAutoSessionTrackingEnabled = isAutoSessionTrackingEnabled;
    function getSentryRelease(fallback) {
      if (process.env.SENTRY_RELEASE) {
        return process.env.SENTRY_RELEASE;
      }
      var global2 = utils_1.getGlobalObject();
      if (global2.SENTRY_RELEASE && global2.SENTRY_RELEASE.id) {
        return global2.SENTRY_RELEASE.id;
      }
      return process.env.GITHUB_SHA || process.env.COMMIT_REF || process.env.VERCEL_GIT_COMMIT_SHA || process.env.VERCEL_GITHUB_COMMIT_SHA || process.env.VERCEL_GITLAB_COMMIT_SHA || process.env.VERCEL_BITBUCKET_COMMIT_SHA || process.env.ZEIT_GITHUB_COMMIT_SHA || process.env.ZEIT_GITLAB_COMMIT_SHA || process.env.ZEIT_BITBUCKET_COMMIT_SHA || fallback;
    }
    exports2.getSentryRelease = getSentryRelease;
    function startSessionTracking() {
      var hub = core_1.getCurrentHub();
      hub.startSession();
      process.on("beforeExit", function() {
        var _a;
        var session = (_a = hub.getScope()) === null || _a === void 0 ? void 0 : _a.getSession();
        var terminalStates = [types_1.SessionStatus.Exited, types_1.SessionStatus.Crashed];
        if (session && !terminalStates.includes(session.status))
          hub.endSession();
      });
    }
  }
});

// node_modules/@sentry/node/dist/utils.js
var require_utils = __commonJS({
  "node_modules/@sentry/node/dist/utils.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var fs = require("fs");
    var path = require("path");
    function deepReadDirSync(targetDir) {
      var targetDirAbsPath = path.resolve(targetDir);
      if (!fs.existsSync(targetDirAbsPath)) {
        throw new Error("Cannot read contents of " + targetDirAbsPath + ". Directory does not exist.");
      }
      if (!fs.statSync(targetDirAbsPath).isDirectory()) {
        throw new Error("Cannot read contents of " + targetDirAbsPath + ", because it is not a directory.");
      }
      var deepReadCurrentDir = function(currentDirAbsPath) {
        return fs.readdirSync(currentDirAbsPath).reduce(function(absPaths, itemName) {
          var itemAbsPath = path.join(currentDirAbsPath, itemName);
          if (fs.statSync(itemAbsPath).isDirectory()) {
            return tslib_1.__spread(absPaths, deepReadCurrentDir(itemAbsPath));
          }
          return tslib_1.__spread(absPaths, [itemAbsPath]);
        }, []);
      };
      return deepReadCurrentDir(targetDirAbsPath).map(function(absPath) {
        return path.relative(targetDirAbsPath, absPath);
      });
    }
    exports2.deepReadDirSync = deepReadDirSync;
  }
});

// node_modules/@sentry/tracing/dist/spanstatus.js
var require_spanstatus = __commonJS({
  "node_modules/@sentry/tracing/dist/spanstatus.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var SpanStatus;
    (function(SpanStatus2) {
      SpanStatus2["Ok"] = "ok";
      SpanStatus2["DeadlineExceeded"] = "deadline_exceeded";
      SpanStatus2["Unauthenticated"] = "unauthenticated";
      SpanStatus2["PermissionDenied"] = "permission_denied";
      SpanStatus2["NotFound"] = "not_found";
      SpanStatus2["ResourceExhausted"] = "resource_exhausted";
      SpanStatus2["InvalidArgument"] = "invalid_argument";
      SpanStatus2["Unimplemented"] = "unimplemented";
      SpanStatus2["Unavailable"] = "unavailable";
      SpanStatus2["InternalError"] = "internal_error";
      SpanStatus2["UnknownError"] = "unknown_error";
      SpanStatus2["Cancelled"] = "cancelled";
      SpanStatus2["AlreadyExists"] = "already_exists";
      SpanStatus2["FailedPrecondition"] = "failed_precondition";
      SpanStatus2["Aborted"] = "aborted";
      SpanStatus2["OutOfRange"] = "out_of_range";
      SpanStatus2["DataLoss"] = "data_loss";
    })(SpanStatus = exports2.SpanStatus || (exports2.SpanStatus = {}));
    (function(SpanStatus2) {
      function fromHttpCode(httpStatus) {
        if (httpStatus < 400) {
          return SpanStatus2.Ok;
        }
        if (httpStatus >= 400 && httpStatus < 500) {
          switch (httpStatus) {
            case 401:
              return SpanStatus2.Unauthenticated;
            case 403:
              return SpanStatus2.PermissionDenied;
            case 404:
              return SpanStatus2.NotFound;
            case 409:
              return SpanStatus2.AlreadyExists;
            case 413:
              return SpanStatus2.FailedPrecondition;
            case 429:
              return SpanStatus2.ResourceExhausted;
            default:
              return SpanStatus2.InvalidArgument;
          }
        }
        if (httpStatus >= 500 && httpStatus < 600) {
          switch (httpStatus) {
            case 501:
              return SpanStatus2.Unimplemented;
            case 503:
              return SpanStatus2.Unavailable;
            case 504:
              return SpanStatus2.DeadlineExceeded;
            default:
              return SpanStatus2.InternalError;
          }
        }
        return SpanStatus2.UnknownError;
      }
      SpanStatus2.fromHttpCode = fromHttpCode;
    })(SpanStatus = exports2.SpanStatus || (exports2.SpanStatus = {}));
  }
});

// node_modules/@sentry/tracing/dist/utils.js
var require_utils2 = __commonJS({
  "node_modules/@sentry/tracing/dist/utils.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hub_1 = require_dist3();
    exports2.TRACEPARENT_REGEXP = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");
    function hasTracingEnabled(options) {
      if (options === void 0) {
        options = (_a = hub_1.getCurrentHub().getClient()) === null || _a === void 0 ? void 0 : _a.getOptions();
      }
      var _a;
      if (!options) {
        return false;
      }
      return "tracesSampleRate" in options || "tracesSampler" in options;
    }
    exports2.hasTracingEnabled = hasTracingEnabled;
    function extractTraceparentData(traceparent) {
      var matches = traceparent.match(exports2.TRACEPARENT_REGEXP);
      if (matches) {
        var parentSampled = void 0;
        if (matches[3] === "1") {
          parentSampled = true;
        } else if (matches[3] === "0") {
          parentSampled = false;
        }
        return {
          traceId: matches[1],
          parentSampled,
          parentSpanId: matches[2]
        };
      }
      return void 0;
    }
    exports2.extractTraceparentData = extractTraceparentData;
    function getActiveTransaction(hub) {
      if (hub === void 0) {
        hub = hub_1.getCurrentHub();
      }
      var _a, _b;
      return (_b = (_a = hub) === null || _a === void 0 ? void 0 : _a.getScope()) === null || _b === void 0 ? void 0 : _b.getTransaction();
    }
    exports2.getActiveTransaction = getActiveTransaction;
    function msToSec(time) {
      return time / 1e3;
    }
    exports2.msToSec = msToSec;
    function secToMs(time) {
      return time * 1e3;
    }
    exports2.secToMs = secToMs;
    var utils_1 = require_dist2();
    exports2.stripUrlQueryAndFragment = utils_1.stripUrlQueryAndFragment;
  }
});

// node_modules/@sentry/tracing/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@sentry/tracing/dist/errors.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var spanstatus_1 = require_spanstatus();
    var utils_2 = require_utils2();
    function registerErrorInstrumentation() {
      utils_1.addInstrumentationHandler({
        callback: errorCallback,
        type: "error"
      });
      utils_1.addInstrumentationHandler({
        callback: errorCallback,
        type: "unhandledrejection"
      });
    }
    exports2.registerErrorInstrumentation = registerErrorInstrumentation;
    function errorCallback() {
      var activeTransaction = utils_2.getActiveTransaction();
      if (activeTransaction) {
        utils_1.logger.log("[Tracing] Transaction: " + spanstatus_1.SpanStatus.InternalError + " -> Global error occured");
        activeTransaction.setStatus(spanstatus_1.SpanStatus.InternalError);
      }
    }
  }
});

// node_modules/@sentry/tracing/dist/span.js
var require_span = __commonJS({
  "node_modules/@sentry/tracing/dist/span.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var utils_1 = require_dist2();
    var spanstatus_1 = require_spanstatus();
    var SpanRecorder = function() {
      function SpanRecorder2(maxlen) {
        if (maxlen === void 0) {
          maxlen = 1e3;
        }
        this.spans = [];
        this._maxlen = maxlen;
      }
      SpanRecorder2.prototype.add = function(span) {
        if (this.spans.length > this._maxlen) {
          span.spanRecorder = void 0;
        } else {
          this.spans.push(span);
        }
      };
      return SpanRecorder2;
    }();
    exports2.SpanRecorder = SpanRecorder;
    var Span = function() {
      function Span2(spanContext) {
        this.traceId = utils_1.uuid4();
        this.spanId = utils_1.uuid4().substring(16);
        this.startTimestamp = utils_1.timestampWithMs();
        this.tags = {};
        this.data = {};
        if (!spanContext) {
          return this;
        }
        if (spanContext.traceId) {
          this.traceId = spanContext.traceId;
        }
        if (spanContext.spanId) {
          this.spanId = spanContext.spanId;
        }
        if (spanContext.parentSpanId) {
          this.parentSpanId = spanContext.parentSpanId;
        }
        if ("sampled" in spanContext) {
          this.sampled = spanContext.sampled;
        }
        if (spanContext.op) {
          this.op = spanContext.op;
        }
        if (spanContext.description) {
          this.description = spanContext.description;
        }
        if (spanContext.data) {
          this.data = spanContext.data;
        }
        if (spanContext.tags) {
          this.tags = spanContext.tags;
        }
        if (spanContext.status) {
          this.status = spanContext.status;
        }
        if (spanContext.startTimestamp) {
          this.startTimestamp = spanContext.startTimestamp;
        }
        if (spanContext.endTimestamp) {
          this.endTimestamp = spanContext.endTimestamp;
        }
      }
      Span2.prototype.child = function(spanContext) {
        return this.startChild(spanContext);
      };
      Span2.prototype.startChild = function(spanContext) {
        var childSpan = new Span2(tslib_1.__assign(tslib_1.__assign({}, spanContext), { parentSpanId: this.spanId, sampled: this.sampled, traceId: this.traceId }));
        childSpan.spanRecorder = this.spanRecorder;
        if (childSpan.spanRecorder) {
          childSpan.spanRecorder.add(childSpan);
        }
        childSpan.transaction = this.transaction;
        return childSpan;
      };
      Span2.prototype.setTag = function(key, value) {
        var _a;
        this.tags = tslib_1.__assign(tslib_1.__assign({}, this.tags), (_a = {}, _a[key] = value, _a));
        return this;
      };
      Span2.prototype.setData = function(key, value) {
        var _a;
        this.data = tslib_1.__assign(tslib_1.__assign({}, this.data), (_a = {}, _a[key] = value, _a));
        return this;
      };
      Span2.prototype.setStatus = function(value) {
        this.status = value;
        return this;
      };
      Span2.prototype.setHttpStatus = function(httpStatus) {
        this.setTag("http.status_code", String(httpStatus));
        var spanStatus = spanstatus_1.SpanStatus.fromHttpCode(httpStatus);
        if (spanStatus !== spanstatus_1.SpanStatus.UnknownError) {
          this.setStatus(spanStatus);
        }
        return this;
      };
      Span2.prototype.isSuccess = function() {
        return this.status === spanstatus_1.SpanStatus.Ok;
      };
      Span2.prototype.finish = function(endTimestamp) {
        this.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : utils_1.timestampWithMs();
      };
      Span2.prototype.toTraceparent = function() {
        var sampledString = "";
        if (this.sampled !== void 0) {
          sampledString = this.sampled ? "-1" : "-0";
        }
        return this.traceId + "-" + this.spanId + sampledString;
      };
      Span2.prototype.toContext = function() {
        return utils_1.dropUndefinedKeys({
          data: this.data,
          description: this.description,
          endTimestamp: this.endTimestamp,
          op: this.op,
          parentSpanId: this.parentSpanId,
          sampled: this.sampled,
          spanId: this.spanId,
          startTimestamp: this.startTimestamp,
          status: this.status,
          tags: this.tags,
          traceId: this.traceId
        });
      };
      Span2.prototype.updateWithContext = function(spanContext) {
        var _a, _b, _c, _d, _e;
        this.data = (_a = spanContext.data, _a !== null && _a !== void 0 ? _a : {});
        this.description = spanContext.description;
        this.endTimestamp = spanContext.endTimestamp;
        this.op = spanContext.op;
        this.parentSpanId = spanContext.parentSpanId;
        this.sampled = spanContext.sampled;
        this.spanId = (_b = spanContext.spanId, _b !== null && _b !== void 0 ? _b : this.spanId);
        this.startTimestamp = (_c = spanContext.startTimestamp, _c !== null && _c !== void 0 ? _c : this.startTimestamp);
        this.status = spanContext.status;
        this.tags = (_d = spanContext.tags, _d !== null && _d !== void 0 ? _d : {});
        this.traceId = (_e = spanContext.traceId, _e !== null && _e !== void 0 ? _e : this.traceId);
        return this;
      };
      Span2.prototype.getTraceContext = function() {
        return utils_1.dropUndefinedKeys({
          data: Object.keys(this.data).length > 0 ? this.data : void 0,
          description: this.description,
          op: this.op,
          parent_span_id: this.parentSpanId,
          span_id: this.spanId,
          status: this.status,
          tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
          trace_id: this.traceId
        });
      };
      Span2.prototype.toJSON = function() {
        return utils_1.dropUndefinedKeys({
          data: Object.keys(this.data).length > 0 ? this.data : void 0,
          description: this.description,
          op: this.op,
          parent_span_id: this.parentSpanId,
          span_id: this.spanId,
          start_timestamp: this.startTimestamp,
          status: this.status,
          tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
          timestamp: this.endTimestamp,
          trace_id: this.traceId
        });
      };
      return Span2;
    }();
    exports2.Span = Span;
  }
});

// node_modules/@sentry/tracing/dist/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/@sentry/tracing/dist/transaction.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var hub_1 = require_dist3();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var span_1 = require_span();
    var Transaction = function(_super) {
      tslib_1.__extends(Transaction2, _super);
      function Transaction2(transactionContext, hub) {
        var _this = _super.call(this, transactionContext) || this;
        _this._measurements = {};
        _this._hub = hub_1.getCurrentHub();
        if (utils_1.isInstanceOf(hub, hub_1.Hub)) {
          _this._hub = hub;
        }
        _this.name = transactionContext.name || "";
        _this.metadata = transactionContext.metadata || {};
        _this._trimEnd = transactionContext.trimEnd;
        _this.transaction = _this;
        return _this;
      }
      Transaction2.prototype.setName = function(name) {
        this.name = name;
      };
      Transaction2.prototype.initSpanRecorder = function(maxlen) {
        if (maxlen === void 0) {
          maxlen = 1e3;
        }
        if (!this.spanRecorder) {
          this.spanRecorder = new span_1.SpanRecorder(maxlen);
        }
        this.spanRecorder.add(this);
      };
      Transaction2.prototype.setMeasurements = function(measurements) {
        this._measurements = tslib_1.__assign({}, measurements);
      };
      Transaction2.prototype.setMetadata = function(newMetadata) {
        this.metadata = tslib_1.__assign(tslib_1.__assign({}, this.metadata), newMetadata);
      };
      Transaction2.prototype.finish = function(endTimestamp) {
        var _this = this;
        var _a, _b, _c, _d, _e;
        if (this.endTimestamp !== void 0) {
          return void 0;
        }
        if (!this.name) {
          utils_1.logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
          this.name = "<unlabeled transaction>";
        }
        _super.prototype.finish.call(this, endTimestamp);
        if (this.sampled !== true) {
          utils_1.logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
          (_e = (_c = (_a = this._hub.getClient()) === null || _a === void 0 ? void 0 : (_b = _a).getTransport) === null || _c === void 0 ? void 0 : (_d = _c.call(_b)).recordLostEvent) === null || _e === void 0 ? void 0 : _e.call(_d, types_1.Outcome.SampleRate, "transaction");
          return void 0;
        }
        var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(function(s) {
          return s !== _this && s.endTimestamp;
        }) : [];
        if (this._trimEnd && finishedSpans.length > 0) {
          this.endTimestamp = finishedSpans.reduce(function(prev, current) {
            if (prev.endTimestamp && current.endTimestamp) {
              return prev.endTimestamp > current.endTimestamp ? prev : current;
            }
            return prev;
          }).endTimestamp;
        }
        var transaction2 = {
          contexts: {
            trace: this.getTraceContext()
          },
          spans: finishedSpans,
          start_timestamp: this.startTimestamp,
          tags: this.tags,
          timestamp: this.endTimestamp,
          transaction: this.name,
          type: "transaction",
          debug_meta: this.metadata
        };
        var hasMeasurements = Object.keys(this._measurements).length > 0;
        if (hasMeasurements) {
          utils_1.logger.log("[Measurements] Adding measurements to transaction", JSON.stringify(this._measurements, void 0, 2));
          transaction2.measurements = this._measurements;
        }
        utils_1.logger.log("[Tracing] Finishing " + this.op + " transaction: " + this.name + ".");
        return this._hub.captureEvent(transaction2);
      };
      Transaction2.prototype.toContext = function() {
        var spanContext = _super.prototype.toContext.call(this);
        return utils_1.dropUndefinedKeys(tslib_1.__assign(tslib_1.__assign({}, spanContext), { name: this.name, trimEnd: this._trimEnd }));
      };
      Transaction2.prototype.updateWithContext = function(transactionContext) {
        var _a;
        _super.prototype.updateWithContext.call(this, transactionContext);
        this.name = (_a = transactionContext.name, _a !== null && _a !== void 0 ? _a : "");
        this._trimEnd = transactionContext.trimEnd;
        return this;
      };
      return Transaction2;
    }(span_1.Span);
    exports2.Transaction = Transaction;
  }
});

// node_modules/@sentry/tracing/dist/idletransaction.js
var require_idletransaction = __commonJS({
  "node_modules/@sentry/tracing/dist/idletransaction.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var utils_1 = require_dist2();
    var span_1 = require_span();
    var spanstatus_1 = require_spanstatus();
    var transaction_1 = require_transaction2();
    exports2.DEFAULT_IDLE_TIMEOUT = 1e3;
    exports2.HEARTBEAT_INTERVAL = 5e3;
    var IdleTransactionSpanRecorder = function(_super) {
      tslib_1.__extends(IdleTransactionSpanRecorder2, _super);
      function IdleTransactionSpanRecorder2(_pushActivity, _popActivity, transactionSpanId, maxlen) {
        if (transactionSpanId === void 0) {
          transactionSpanId = "";
        }
        var _this = _super.call(this, maxlen) || this;
        _this._pushActivity = _pushActivity;
        _this._popActivity = _popActivity;
        _this.transactionSpanId = transactionSpanId;
        return _this;
      }
      IdleTransactionSpanRecorder2.prototype.add = function(span) {
        var _this = this;
        if (span.spanId !== this.transactionSpanId) {
          span.finish = function(endTimestamp) {
            span.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : utils_1.timestampWithMs();
            _this._popActivity(span.spanId);
          };
          if (span.endTimestamp === void 0) {
            this._pushActivity(span.spanId);
          }
        }
        _super.prototype.add.call(this, span);
      };
      return IdleTransactionSpanRecorder2;
    }(span_1.SpanRecorder);
    exports2.IdleTransactionSpanRecorder = IdleTransactionSpanRecorder;
    var IdleTransaction = function(_super) {
      tslib_1.__extends(IdleTransaction2, _super);
      function IdleTransaction2(transactionContext, _idleHub, _idleTimeout, _onScope) {
        if (_idleTimeout === void 0) {
          _idleTimeout = exports2.DEFAULT_IDLE_TIMEOUT;
        }
        if (_onScope === void 0) {
          _onScope = false;
        }
        var _this = _super.call(this, transactionContext, _idleHub) || this;
        _this._idleHub = _idleHub;
        _this._idleTimeout = _idleTimeout;
        _this._onScope = _onScope;
        _this.activities = {};
        _this._heartbeatCounter = 0;
        _this._finished = false;
        _this._beforeFinishCallbacks = [];
        if (_idleHub && _onScope) {
          clearActiveTransaction(_idleHub);
          utils_1.logger.log("Setting idle transaction on scope. Span ID: " + _this.spanId);
          _idleHub.configureScope(function(scope) {
            return scope.setSpan(_this);
          });
        }
        _this._initTimeout = setTimeout(function() {
          if (!_this._finished) {
            _this.finish();
          }
        }, _this._idleTimeout);
        return _this;
      }
      IdleTransaction2.prototype.finish = function(endTimestamp) {
        var e_1, _a;
        var _this = this;
        if (endTimestamp === void 0) {
          endTimestamp = utils_1.timestampWithMs();
        }
        this._finished = true;
        this.activities = {};
        if (this.spanRecorder) {
          utils_1.logger.log("[Tracing] finishing IdleTransaction", new Date(endTimestamp * 1e3).toISOString(), this.op);
          try {
            for (var _b = tslib_1.__values(this._beforeFinishCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {
              var callback = _c.value;
              callback(this, endTimestamp);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          this.spanRecorder.spans = this.spanRecorder.spans.filter(function(span) {
            if (span.spanId === _this.spanId) {
              return true;
            }
            if (!span.endTimestamp) {
              span.endTimestamp = endTimestamp;
              span.setStatus(spanstatus_1.SpanStatus.Cancelled);
              utils_1.logger.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(span, void 0, 2));
            }
            var keepSpan = span.startTimestamp < endTimestamp;
            if (!keepSpan) {
              utils_1.logger.log("[Tracing] discarding Span since it happened after Transaction was finished", JSON.stringify(span, void 0, 2));
            }
            return keepSpan;
          });
          utils_1.logger.log("[Tracing] flushing IdleTransaction");
        } else {
          utils_1.logger.log("[Tracing] No active IdleTransaction");
        }
        if (this._onScope) {
          clearActiveTransaction(this._idleHub);
        }
        return _super.prototype.finish.call(this, endTimestamp);
      };
      IdleTransaction2.prototype.registerBeforeFinishCallback = function(callback) {
        this._beforeFinishCallbacks.push(callback);
      };
      IdleTransaction2.prototype.initSpanRecorder = function(maxlen) {
        var _this = this;
        if (!this.spanRecorder) {
          var pushActivity = function(id) {
            if (_this._finished) {
              return;
            }
            _this._pushActivity(id);
          };
          var popActivity = function(id) {
            if (_this._finished) {
              return;
            }
            _this._popActivity(id);
          };
          this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);
          utils_1.logger.log("Starting heartbeat");
          this._pingHeartbeat();
        }
        this.spanRecorder.add(this);
      };
      IdleTransaction2.prototype._pushActivity = function(spanId) {
        if (this._initTimeout) {
          clearTimeout(this._initTimeout);
          this._initTimeout = void 0;
        }
        utils_1.logger.log("[Tracing] pushActivity: " + spanId);
        this.activities[spanId] = true;
        utils_1.logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
      };
      IdleTransaction2.prototype._popActivity = function(spanId) {
        var _this = this;
        if (this.activities[spanId]) {
          utils_1.logger.log("[Tracing] popActivity " + spanId);
          delete this.activities[spanId];
          utils_1.logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
        }
        if (Object.keys(this.activities).length === 0) {
          var timeout = this._idleTimeout;
          var end_1 = utils_1.timestampWithMs() + timeout / 1e3;
          setTimeout(function() {
            if (!_this._finished) {
              _this.finish(end_1);
            }
          }, timeout);
        }
      };
      IdleTransaction2.prototype._beat = function() {
        if (this._finished) {
          return;
        }
        var heartbeatString = Object.keys(this.activities).join("");
        if (heartbeatString === this._prevHeartbeatString) {
          this._heartbeatCounter += 1;
        } else {
          this._heartbeatCounter = 1;
        }
        this._prevHeartbeatString = heartbeatString;
        if (this._heartbeatCounter >= 3) {
          utils_1.logger.log("[Tracing] Transaction finished because of no change for 3 heart beats");
          this.setStatus(spanstatus_1.SpanStatus.DeadlineExceeded);
          this.setTag("heartbeat", "failed");
          this.finish();
        } else {
          this._pingHeartbeat();
        }
      };
      IdleTransaction2.prototype._pingHeartbeat = function() {
        var _this = this;
        utils_1.logger.log("pinging Heartbeat -> current counter: " + this._heartbeatCounter);
        setTimeout(function() {
          _this._beat();
        }, exports2.HEARTBEAT_INTERVAL);
      };
      return IdleTransaction2;
    }(transaction_1.Transaction);
    exports2.IdleTransaction = IdleTransaction;
    function clearActiveTransaction(hub) {
      if (hub) {
        var scope = hub.getScope();
        if (scope) {
          var transaction2 = scope.getTransaction();
          if (transaction2) {
            scope.setSpan(void 0);
          }
        }
      }
    }
  }
});

// node_modules/@sentry/tracing/dist/hubextensions.js
var require_hubextensions = __commonJS({
  "node_modules/@sentry/tracing/dist/hubextensions.js"(exports2, module2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var hub_1 = require_dist3();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var errors_1 = require_errors();
    var idletransaction_1 = require_idletransaction();
    var transaction_1 = require_transaction2();
    var utils_2 = require_utils2();
    function traceHeaders() {
      var scope = this.getScope();
      if (scope) {
        var span = scope.getSpan();
        if (span) {
          return {
            "sentry-trace": span.toTraceparent()
          };
        }
      }
      return {};
    }
    function sample(transaction2, options, samplingContext) {
      if (!utils_2.hasTracingEnabled(options)) {
        transaction2.sampled = false;
        return transaction2;
      }
      if (transaction2.sampled !== void 0) {
        transaction2.setMetadata({
          transactionSampling: { method: types_1.TransactionSamplingMethod.Explicit }
        });
        return transaction2;
      }
      var sampleRate;
      if (typeof options.tracesSampler === "function") {
        sampleRate = options.tracesSampler(samplingContext);
        transaction2.setMetadata({
          transactionSampling: {
            method: types_1.TransactionSamplingMethod.Sampler,
            rate: Number(sampleRate)
          }
        });
      } else if (samplingContext.parentSampled !== void 0) {
        sampleRate = samplingContext.parentSampled;
        transaction2.setMetadata({
          transactionSampling: { method: types_1.TransactionSamplingMethod.Inheritance }
        });
      } else {
        sampleRate = options.tracesSampleRate;
        transaction2.setMetadata({
          transactionSampling: {
            method: types_1.TransactionSamplingMethod.Rate,
            rate: Number(sampleRate)
          }
        });
      }
      if (!isValidSampleRate(sampleRate)) {
        utils_1.logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
        transaction2.sampled = false;
        return transaction2;
      }
      if (!sampleRate) {
        utils_1.logger.log("[Tracing] Discarding transaction because " + (typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"));
        transaction2.sampled = false;
        return transaction2;
      }
      transaction2.sampled = Math.random() < sampleRate;
      if (!transaction2.sampled) {
        utils_1.logger.log("[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = " + Number(sampleRate) + ")");
        return transaction2;
      }
      utils_1.logger.log("[Tracing] starting " + transaction2.op + " transaction - " + transaction2.name);
      return transaction2;
    }
    function isValidSampleRate(rate) {
      if (isNaN(rate) || !(typeof rate === "number" || typeof rate === "boolean")) {
        utils_1.logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got " + JSON.stringify(rate) + " of type " + JSON.stringify(typeof rate) + ".");
        return false;
      }
      if (rate < 0 || rate > 1) {
        utils_1.logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got " + rate + ".");
        return false;
      }
      return true;
    }
    function _startTransaction(transactionContext, customSamplingContext) {
      var _a, _b;
      var options = ((_a = this.getClient()) === null || _a === void 0 ? void 0 : _a.getOptions()) || {};
      var transaction2 = new transaction_1.Transaction(transactionContext, this);
      transaction2 = sample(transaction2, options, tslib_1.__assign({ parentSampled: transactionContext.parentSampled, transactionContext }, customSamplingContext));
      if (transaction2.sampled) {
        transaction2.initSpanRecorder((_b = options._experiments) === null || _b === void 0 ? void 0 : _b.maxSpans);
      }
      return transaction2;
    }
    function startIdleTransaction(hub, transactionContext, idleTimeout, onScope, customSamplingContext) {
      var _a, _b;
      var options = ((_a = hub.getClient()) === null || _a === void 0 ? void 0 : _a.getOptions()) || {};
      var transaction2 = new idletransaction_1.IdleTransaction(transactionContext, hub, idleTimeout, onScope);
      transaction2 = sample(transaction2, options, tslib_1.__assign({ parentSampled: transactionContext.parentSampled, transactionContext }, customSamplingContext));
      if (transaction2.sampled) {
        transaction2.initSpanRecorder((_b = options._experiments) === null || _b === void 0 ? void 0 : _b.maxSpans);
      }
      return transaction2;
    }
    exports2.startIdleTransaction = startIdleTransaction;
    function _addTracingExtensions() {
      var carrier = hub_1.getMainCarrier();
      if (!carrier.__SENTRY__) {
        return;
      }
      carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
      if (!carrier.__SENTRY__.extensions.startTransaction) {
        carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
      }
      if (!carrier.__SENTRY__.extensions.traceHeaders) {
        carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
      }
    }
    exports2._addTracingExtensions = _addTracingExtensions;
    function _autoloadDatabaseIntegrations() {
      var carrier = hub_1.getMainCarrier();
      if (!carrier.__SENTRY__) {
        return;
      }
      var packageToIntegrationMapping = {
        mongodb: function() {
          var integration = utils_1.dynamicRequire(module2, "./integrations/node/mongo");
          return new integration.Mongo();
        },
        mongoose: function() {
          var integration = utils_1.dynamicRequire(module2, "./integrations/node/mongo");
          return new integration.Mongo({ mongoose: true });
        },
        mysql: function() {
          var integration = utils_1.dynamicRequire(module2, "./integrations/node/mysql");
          return new integration.Mysql();
        },
        pg: function() {
          var integration = utils_1.dynamicRequire(module2, "./integrations/node/postgres");
          return new integration.Postgres();
        }
      };
      var mappedPackages = Object.keys(packageToIntegrationMapping).filter(function(moduleName) {
        return !!utils_1.loadModule(moduleName);
      }).map(function(pkg) {
        try {
          return packageToIntegrationMapping[pkg]();
        } catch (e) {
          return void 0;
        }
      }).filter(function(p) {
        return p;
      });
      if (mappedPackages.length > 0) {
        carrier.__SENTRY__.integrations = tslib_1.__spread(carrier.__SENTRY__.integrations || [], mappedPackages);
      }
    }
    function addExtensionMethods() {
      _addTracingExtensions();
      if (utils_1.isNodeEnv()) {
        _autoloadDatabaseIntegrations();
      }
      errors_1.registerErrorInstrumentation();
    }
    exports2.addExtensionMethods = addExtensionMethods;
  }
});

// node_modules/@sentry/tracing/dist/browser/backgroundtab.js
var require_backgroundtab = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/backgroundtab.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var spanstatus_1 = require_spanstatus();
    var utils_2 = require_utils2();
    var global2 = utils_1.getGlobalObject();
    function registerBackgroundTabDetection() {
      if (global2 && global2.document) {
        global2.document.addEventListener("visibilitychange", function() {
          var activeTransaction = utils_2.getActiveTransaction();
          if (global2.document.hidden && activeTransaction) {
            utils_1.logger.log("[Tracing] Transaction: " + spanstatus_1.SpanStatus.Cancelled + " -> since tab moved to the background, op: " + activeTransaction.op);
            if (!activeTransaction.status) {
              activeTransaction.setStatus(spanstatus_1.SpanStatus.Cancelled);
            }
            activeTransaction.setTag("visibilitychange", "document.hidden");
            activeTransaction.finish();
          }
        });
      } else {
        utils_1.logger.warn("[Tracing] Could not set up background tab detection due to lack of global document");
      }
    }
    exports2.registerBackgroundTabDetection = registerBackgroundTabDetection;
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/lib/bindReporter.js
var require_bindReporter = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/lib/bindReporter.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bindReporter = function(callback, metric, reportAllChanges) {
      var prevValue;
      return function(forceReport) {
        if (metric.value >= 0) {
          if (forceReport || reportAllChanges) {
            metric.delta = metric.value - (prevValue || 0);
            if (metric.delta || prevValue === void 0) {
              prevValue = metric.value;
              callback(metric);
            }
          }
        }
      };
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/lib/generateUniqueID.js
var require_generateUniqueID = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/lib/generateUniqueID.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateUniqueID = function() {
      return "v2-" + Date.now() + "-" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/lib/initMetric.js
var require_initMetric = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/lib/initMetric.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var generateUniqueID_1 = require_generateUniqueID();
    exports2.initMetric = function(name, value) {
      return {
        name,
        value: value !== null && value !== void 0 ? value : -1,
        delta: 0,
        entries: [],
        id: generateUniqueID_1.generateUniqueID()
      };
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/lib/observe.js
var require_observe = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/lib/observe.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observe = function(type, callback) {
      try {
        if (PerformanceObserver.supportedEntryTypes.includes(type)) {
          if (type === "first-input" && !("PerformanceEventTiming" in self)) {
            return;
          }
          var po = new PerformanceObserver(function(l) {
            return l.getEntries().map(callback);
          });
          po.observe({ type, buffered: true });
          return po;
        }
      } catch (e) {
      }
      return;
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/lib/onHidden.js
var require_onHidden = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/lib/onHidden.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_dist2();
    exports2.onHidden = function(cb, once) {
      var onHiddenOrPageHide = function(event) {
        if (event.type === "pagehide" || utils_1.getGlobalObject().document.visibilityState === "hidden") {
          cb(event);
          if (once) {
            removeEventListener("visibilitychange", onHiddenOrPageHide, true);
            removeEventListener("pagehide", onHiddenOrPageHide, true);
          }
        }
      };
      addEventListener("visibilitychange", onHiddenOrPageHide, true);
      addEventListener("pagehide", onHiddenOrPageHide, true);
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/getCLS.js
var require_getCLS = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/getCLS.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bindReporter_1 = require_bindReporter();
    var initMetric_1 = require_initMetric();
    var observe_1 = require_observe();
    var onHidden_1 = require_onHidden();
    exports2.getCLS = function(onReport, reportAllChanges) {
      var metric = initMetric_1.initMetric("CLS", 0);
      var report;
      var sessionValue = 0;
      var sessionEntries = [];
      var entryHandler = function(entry) {
        if (entry && !entry.hadRecentInput) {
          var firstSessionEntry = sessionEntries[0];
          var lastSessionEntry = sessionEntries[sessionEntries.length - 1];
          if (sessionValue && sessionEntries.length !== 0 && entry.startTime - lastSessionEntry.startTime < 1e3 && entry.startTime - firstSessionEntry.startTime < 5e3) {
            sessionValue += entry.value;
            sessionEntries.push(entry);
          } else {
            sessionValue = entry.value;
            sessionEntries = [entry];
          }
          if (sessionValue > metric.value) {
            metric.value = sessionValue;
            metric.entries = sessionEntries;
            if (report) {
              report();
            }
          }
        }
      };
      var po = observe_1.observe("layout-shift", entryHandler);
      if (po) {
        report = bindReporter_1.bindReporter(onReport, metric, reportAllChanges);
        onHidden_1.onHidden(function() {
          po.takeRecords().map(entryHandler);
          report(true);
        });
      }
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/lib/getVisibilityWatcher.js
var require_getVisibilityWatcher = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/lib/getVisibilityWatcher.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var onHidden_1 = require_onHidden();
    var firstHiddenTime = -1;
    var initHiddenTime = function() {
      return utils_1.getGlobalObject().document.visibilityState === "hidden" ? 0 : Infinity;
    };
    var trackChanges = function() {
      onHidden_1.onHidden(function(_a) {
        var timeStamp = _a.timeStamp;
        firstHiddenTime = timeStamp;
      }, true);
    };
    exports2.getVisibilityWatcher = function() {
      if (firstHiddenTime < 0) {
        firstHiddenTime = initHiddenTime();
        trackChanges();
      }
      return {
        get firstHiddenTime() {
          return firstHiddenTime;
        }
      };
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/getFID.js
var require_getFID = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/getFID.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bindReporter_1 = require_bindReporter();
    var getVisibilityWatcher_1 = require_getVisibilityWatcher();
    var initMetric_1 = require_initMetric();
    var observe_1 = require_observe();
    var onHidden_1 = require_onHidden();
    exports2.getFID = function(onReport, reportAllChanges) {
      var visibilityWatcher = getVisibilityWatcher_1.getVisibilityWatcher();
      var metric = initMetric_1.initMetric("FID");
      var report;
      var entryHandler = function(entry) {
        if (report && entry.startTime < visibilityWatcher.firstHiddenTime) {
          metric.value = entry.processingStart - entry.startTime;
          metric.entries.push(entry);
          report(true);
        }
      };
      var po = observe_1.observe("first-input", entryHandler);
      if (po) {
        report = bindReporter_1.bindReporter(onReport, metric, reportAllChanges);
        onHidden_1.onHidden(function() {
          po.takeRecords().map(entryHandler);
          po.disconnect();
        }, true);
      }
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/getLCP.js
var require_getLCP = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/getLCP.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bindReporter_1 = require_bindReporter();
    var getVisibilityWatcher_1 = require_getVisibilityWatcher();
    var initMetric_1 = require_initMetric();
    var observe_1 = require_observe();
    var onHidden_1 = require_onHidden();
    var reportedMetricIDs = {};
    exports2.getLCP = function(onReport, reportAllChanges) {
      var visibilityWatcher = getVisibilityWatcher_1.getVisibilityWatcher();
      var metric = initMetric_1.initMetric("LCP");
      var report;
      var entryHandler = function(entry) {
        var value = entry.startTime;
        if (value < visibilityWatcher.firstHiddenTime) {
          metric.value = value;
          metric.entries.push(entry);
        }
        if (report) {
          report();
        }
      };
      var po = observe_1.observe("largest-contentful-paint", entryHandler);
      if (po) {
        report = bindReporter_1.bindReporter(onReport, metric, reportAllChanges);
        var stopListening_1 = function() {
          if (!reportedMetricIDs[metric.id]) {
            po.takeRecords().map(entryHandler);
            po.disconnect();
            reportedMetricIDs[metric.id] = true;
            report(true);
          }
        };
        ["keydown", "click"].forEach(function(type) {
          addEventListener(type, stopListening_1, { once: true, capture: true });
        });
        onHidden_1.onHidden(stopListening_1, true);
      }
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/metrics.js
var require_metrics = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/metrics.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var utils_1 = require_dist2();
    var utils_2 = require_utils2();
    var getCLS_1 = require_getCLS();
    var getFID_1 = require_getFID();
    var getLCP_1 = require_getLCP();
    var getVisibilityWatcher_1 = require_getVisibilityWatcher();
    var global2 = utils_1.getGlobalObject();
    exports2.DEFAULT_METRICS_INSTR_OPTIONS = {
      _reportAllChanges: false
    };
    var MetricsInstrumentation = function() {
      function MetricsInstrumentation2(_options) {
        var _a, _b;
        this._measurements = {};
        this._performanceCursor = 0;
        if (!utils_1.isNodeEnv() && ((_a = global2) === null || _a === void 0 ? void 0 : _a.performance) && ((_b = global2) === null || _b === void 0 ? void 0 : _b.document)) {
          if (global2.performance.mark) {
            global2.performance.mark("sentry-tracing-init");
          }
          this._trackCLS();
          this._trackLCP(_options._reportAllChanges);
          this._trackFID();
        }
      }
      MetricsInstrumentation2.prototype.addPerformanceEntries = function(transaction2) {
        var _this = this;
        if (!global2 || !global2.performance || !global2.performance.getEntries || !utils_1.browserPerformanceTimeOrigin) {
          return;
        }
        utils_1.logger.log("[Tracing] Adding & adjusting spans using Performance API");
        var timeOrigin = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
        var entryScriptSrc;
        if (global2.document && global2.document.scripts) {
          for (var i = 0; i < global2.document.scripts.length; i++) {
            if (global2.document.scripts[i].dataset.entry === "true") {
              entryScriptSrc = global2.document.scripts[i].src;
              break;
            }
          }
        }
        var entryScriptStartTimestamp;
        var tracingInitMarkStartTime;
        var responseStartTimestamp;
        var requestStartTimestamp;
        global2.performance.getEntries().slice(this._performanceCursor).forEach(function(entry) {
          var startTime = utils_2.msToSec(entry.startTime);
          var duration = utils_2.msToSec(entry.duration);
          if (transaction2.op === "navigation" && timeOrigin + startTime < transaction2.startTimestamp) {
            return;
          }
          switch (entry.entryType) {
            case "navigation": {
              addNavigationSpans(transaction2, entry, timeOrigin);
              responseStartTimestamp = timeOrigin + utils_2.msToSec(entry.responseStart);
              requestStartTimestamp = timeOrigin + utils_2.msToSec(entry.requestStart);
              break;
            }
            case "mark":
            case "paint":
            case "measure": {
              var startTimestamp = addMeasureSpans(transaction2, entry, startTime, duration, timeOrigin);
              if (tracingInitMarkStartTime === void 0 && entry.name === "sentry-tracing-init") {
                tracingInitMarkStartTime = startTimestamp;
              }
              var firstHidden = getVisibilityWatcher_1.getVisibilityWatcher();
              var shouldRecord = entry.startTime < firstHidden.firstHiddenTime;
              if (entry.name === "first-paint" && shouldRecord) {
                utils_1.logger.log("[Measurements] Adding FP");
                _this._measurements["fp"] = { value: entry.startTime };
                _this._measurements["mark.fp"] = { value: startTimestamp };
              }
              if (entry.name === "first-contentful-paint" && shouldRecord) {
                utils_1.logger.log("[Measurements] Adding FCP");
                _this._measurements["fcp"] = { value: entry.startTime };
                _this._measurements["mark.fcp"] = { value: startTimestamp };
              }
              break;
            }
            case "resource": {
              var resourceName = entry.name.replace(global2.location.origin, "");
              var endTimestamp = addResourceSpans(transaction2, entry, resourceName, startTime, duration, timeOrigin);
              if (entryScriptStartTimestamp === void 0 && (entryScriptSrc || "").indexOf(resourceName) > -1) {
                entryScriptStartTimestamp = endTimestamp;
              }
              break;
            }
            default:
          }
        });
        if (entryScriptStartTimestamp !== void 0 && tracingInitMarkStartTime !== void 0) {
          _startChild(transaction2, {
            description: "evaluation",
            endTimestamp: tracingInitMarkStartTime,
            op: "script",
            startTimestamp: entryScriptStartTimestamp
          });
        }
        this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);
        this._trackNavigator(transaction2);
        if (transaction2.op === "pageload") {
          var timeOrigin_1 = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
          if (typeof responseStartTimestamp === "number") {
            utils_1.logger.log("[Measurements] Adding TTFB");
            this._measurements["ttfb"] = { value: (responseStartTimestamp - transaction2.startTimestamp) * 1e3 };
            if (typeof requestStartTimestamp === "number" && requestStartTimestamp <= responseStartTimestamp) {
              this._measurements["ttfb.requestTime"] = { value: (responseStartTimestamp - requestStartTimestamp) * 1e3 };
            }
          }
          ["fcp", "fp", "lcp"].forEach(function(name) {
            if (!_this._measurements[name] || timeOrigin_1 >= transaction2.startTimestamp) {
              return;
            }
            var oldValue = _this._measurements[name].value;
            var measurementTimestamp = timeOrigin_1 + utils_2.msToSec(oldValue);
            var normalizedValue = Math.abs((measurementTimestamp - transaction2.startTimestamp) * 1e3);
            var delta = normalizedValue - oldValue;
            utils_1.logger.log("[Measurements] Normalized " + name + " from " + oldValue + " to " + normalizedValue + " (" + delta + ")");
            _this._measurements[name].value = normalizedValue;
          });
          if (this._measurements["mark.fid"] && this._measurements["fid"]) {
            _startChild(transaction2, {
              description: "first input delay",
              endTimestamp: this._measurements["mark.fid"].value + utils_2.msToSec(this._measurements["fid"].value),
              op: "web.vitals",
              startTimestamp: this._measurements["mark.fid"].value
            });
          }
          if (!("fcp" in this._measurements)) {
            delete this._measurements.cls;
          }
          transaction2.setMeasurements(this._measurements);
          this._tagMetricInfo(transaction2);
        }
      };
      MetricsInstrumentation2.prototype._tagMetricInfo = function(transaction2) {
        if (this._lcpEntry) {
          utils_1.logger.log("[Measurements] Adding LCP Data");
          if (this._lcpEntry.element) {
            transaction2.setTag("lcp.element", utils_1.htmlTreeAsString(this._lcpEntry.element));
          }
          if (this._lcpEntry.id) {
            transaction2.setTag("lcp.id", this._lcpEntry.id);
          }
          if (this._lcpEntry.url) {
            transaction2.setTag("lcp.url", this._lcpEntry.url.trim().slice(0, 200));
          }
          transaction2.setTag("lcp.size", this._lcpEntry.size);
        }
        if (this._clsEntry && this._clsEntry.sources) {
          utils_1.logger.log("[Measurements] Adding CLS Data");
          this._clsEntry.sources.forEach(function(source, index) {
            return transaction2.setTag("cls.source." + (index + 1), utils_1.htmlTreeAsString(source.node));
          });
        }
      };
      MetricsInstrumentation2.prototype._trackCLS = function() {
        var _this = this;
        getCLS_1.getCLS(function(metric) {
          var entry = metric.entries.pop();
          if (!entry) {
            return;
          }
          utils_1.logger.log("[Measurements] Adding CLS");
          _this._measurements["cls"] = { value: metric.value };
          _this._clsEntry = entry;
        });
      };
      MetricsInstrumentation2.prototype._trackNavigator = function(transaction2) {
        var navigator2 = global2.navigator;
        if (!navigator2) {
          return;
        }
        var connection2 = navigator2.connection;
        if (connection2) {
          if (connection2.effectiveType) {
            transaction2.setTag("effectiveConnectionType", connection2.effectiveType);
          }
          if (connection2.type) {
            transaction2.setTag("connectionType", connection2.type);
          }
          if (isMeasurementValue(connection2.rtt)) {
            this._measurements["connection.rtt"] = { value: connection2.rtt };
          }
          if (isMeasurementValue(connection2.downlink)) {
            this._measurements["connection.downlink"] = { value: connection2.downlink };
          }
        }
        if (isMeasurementValue(navigator2.deviceMemory)) {
          transaction2.setTag("deviceMemory", String(navigator2.deviceMemory));
        }
        if (isMeasurementValue(navigator2.hardwareConcurrency)) {
          transaction2.setTag("hardwareConcurrency", String(navigator2.hardwareConcurrency));
        }
      };
      MetricsInstrumentation2.prototype._trackLCP = function(reportAllChanges) {
        var _this = this;
        getLCP_1.getLCP(function(metric) {
          var entry = metric.entries.pop();
          if (!entry) {
            return;
          }
          var timeOrigin = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
          var startTime = utils_2.msToSec(entry.startTime);
          utils_1.logger.log("[Measurements] Adding LCP");
          _this._measurements["lcp"] = { value: metric.value };
          _this._measurements["mark.lcp"] = { value: timeOrigin + startTime };
          _this._lcpEntry = entry;
        }, reportAllChanges);
      };
      MetricsInstrumentation2.prototype._trackFID = function() {
        var _this = this;
        getFID_1.getFID(function(metric) {
          var entry = metric.entries.pop();
          if (!entry) {
            return;
          }
          var timeOrigin = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
          var startTime = utils_2.msToSec(entry.startTime);
          utils_1.logger.log("[Measurements] Adding FID");
          _this._measurements["fid"] = { value: metric.value };
          _this._measurements["mark.fid"] = { value: timeOrigin + startTime };
        });
      };
      return MetricsInstrumentation2;
    }();
    exports2.MetricsInstrumentation = MetricsInstrumentation;
    function addNavigationSpans(transaction2, entry, timeOrigin) {
      addPerformanceNavigationTiming({ transaction: transaction2, entry, event: "unloadEvent", timeOrigin });
      addPerformanceNavigationTiming({ transaction: transaction2, entry, event: "redirect", timeOrigin });
      addPerformanceNavigationTiming({ transaction: transaction2, entry, event: "domContentLoadedEvent", timeOrigin });
      addPerformanceNavigationTiming({ transaction: transaction2, entry, event: "loadEvent", timeOrigin });
      addPerformanceNavigationTiming({ transaction: transaction2, entry, event: "connect", timeOrigin });
      addPerformanceNavigationTiming({
        transaction: transaction2,
        entry,
        event: "secureConnection",
        timeOrigin,
        eventEnd: "connectEnd",
        description: "TLS/SSL"
      });
      addPerformanceNavigationTiming({
        transaction: transaction2,
        entry,
        event: "fetch",
        timeOrigin,
        eventEnd: "domainLookupStart",
        description: "cache"
      });
      addPerformanceNavigationTiming({ transaction: transaction2, entry, event: "domainLookup", timeOrigin, description: "DNS" });
      addRequest(transaction2, entry, timeOrigin);
    }
    function addMeasureSpans(transaction2, entry, startTime, duration, timeOrigin) {
      var measureStartTimestamp = timeOrigin + startTime;
      var measureEndTimestamp = measureStartTimestamp + duration;
      _startChild(transaction2, {
        description: entry.name,
        endTimestamp: measureEndTimestamp,
        op: entry.entryType,
        startTimestamp: measureStartTimestamp
      });
      return measureStartTimestamp;
    }
    function addResourceSpans(transaction2, entry, resourceName, startTime, duration, timeOrigin) {
      if (entry.initiatorType === "xmlhttprequest" || entry.initiatorType === "fetch") {
        return void 0;
      }
      var data = {};
      if ("transferSize" in entry) {
        data["Transfer Size"] = entry.transferSize;
      }
      if ("encodedBodySize" in entry) {
        data["Encoded Body Size"] = entry.encodedBodySize;
      }
      if ("decodedBodySize" in entry) {
        data["Decoded Body Size"] = entry.decodedBodySize;
      }
      var startTimestamp = timeOrigin + startTime;
      var endTimestamp = startTimestamp + duration;
      _startChild(transaction2, {
        description: resourceName,
        endTimestamp,
        op: entry.initiatorType ? "resource." + entry.initiatorType : "resource",
        startTimestamp,
        data
      });
      return endTimestamp;
    }
    exports2.addResourceSpans = addResourceSpans;
    function addPerformanceNavigationTiming(props) {
      var transaction2 = props.transaction, entry = props.entry, event = props.event, timeOrigin = props.timeOrigin, eventEnd = props.eventEnd, description = props.description;
      var end = eventEnd ? entry[eventEnd] : entry[event + "End"];
      var start = entry[event + "Start"];
      if (!start || !end) {
        return;
      }
      _startChild(transaction2, {
        op: "browser",
        description: description !== null && description !== void 0 ? description : event,
        startTimestamp: timeOrigin + utils_2.msToSec(start),
        endTimestamp: timeOrigin + utils_2.msToSec(end)
      });
    }
    function addRequest(transaction2, entry, timeOrigin) {
      _startChild(transaction2, {
        op: "browser",
        description: "request",
        startTimestamp: timeOrigin + utils_2.msToSec(entry.requestStart),
        endTimestamp: timeOrigin + utils_2.msToSec(entry.responseEnd)
      });
      _startChild(transaction2, {
        op: "browser",
        description: "response",
        startTimestamp: timeOrigin + utils_2.msToSec(entry.responseStart),
        endTimestamp: timeOrigin + utils_2.msToSec(entry.responseEnd)
      });
    }
    function _startChild(transaction2, _a) {
      var startTimestamp = _a.startTimestamp, ctx = tslib_1.__rest(_a, ["startTimestamp"]);
      if (startTimestamp && transaction2.startTimestamp > startTimestamp) {
        transaction2.startTimestamp = startTimestamp;
      }
      return transaction2.startChild(tslib_1.__assign({ startTimestamp }, ctx));
    }
    exports2._startChild = _startChild;
    function isMeasurementValue(value) {
      return typeof value === "number" && isFinite(value);
    }
  }
});

// node_modules/@sentry/tracing/dist/browser/request.js
var require_request2 = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/request.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var utils_1 = require_dist2();
    var spanstatus_1 = require_spanstatus();
    var utils_2 = require_utils2();
    exports2.DEFAULT_TRACING_ORIGINS = ["localhost", /^\//];
    exports2.defaultRequestInstrumentationOptions = {
      traceFetch: true,
      traceXHR: true,
      tracingOrigins: exports2.DEFAULT_TRACING_ORIGINS
    };
    function instrumentOutgoingRequests(_options) {
      var _a = tslib_1.__assign(tslib_1.__assign({}, exports2.defaultRequestInstrumentationOptions), _options), traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
      var urlMap = {};
      var defaultShouldCreateSpan = function(url) {
        if (urlMap[url]) {
          return urlMap[url];
        }
        var origins = tracingOrigins;
        urlMap[url] = origins.some(function(origin) {
          return utils_1.isMatchingPattern(url, origin);
        }) && !utils_1.isMatchingPattern(url, "sentry_key");
        return urlMap[url];
      };
      var shouldCreateSpan = defaultShouldCreateSpan;
      if (typeof shouldCreateSpanForRequest === "function") {
        shouldCreateSpan = function(url) {
          return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);
        };
      }
      var spans = {};
      if (traceFetch) {
        utils_1.addInstrumentationHandler({
          callback: function(handlerData) {
            fetchCallback(handlerData, shouldCreateSpan, spans);
          },
          type: "fetch"
        });
      }
      if (traceXHR) {
        utils_1.addInstrumentationHandler({
          callback: function(handlerData) {
            xhrCallback(handlerData, shouldCreateSpan, spans);
          },
          type: "xhr"
        });
      }
    }
    exports2.instrumentOutgoingRequests = instrumentOutgoingRequests;
    function fetchCallback(handlerData, shouldCreateSpan, spans) {
      if (!utils_2.hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {
        return;
      }
      if (handlerData.endTimestamp && handlerData.fetchData.__span) {
        var span = spans[handlerData.fetchData.__span];
        if (span) {
          if (handlerData.response) {
            span.setHttpStatus(handlerData.response.status);
          } else if (handlerData.error) {
            span.setStatus(spanstatus_1.SpanStatus.InternalError);
          }
          span.finish();
          delete spans[handlerData.fetchData.__span];
        }
        return;
      }
      var activeTransaction = utils_2.getActiveTransaction();
      if (activeTransaction) {
        var span = activeTransaction.startChild({
          data: tslib_1.__assign(tslib_1.__assign({}, handlerData.fetchData), { type: "fetch" }),
          description: handlerData.fetchData.method + " " + handlerData.fetchData.url,
          op: "http.client"
        });
        handlerData.fetchData.__span = span.spanId;
        spans[span.spanId] = span;
        var request = handlerData.args[0] = handlerData.args[0];
        var options = handlerData.args[1] = handlerData.args[1] || {};
        var headers = options.headers;
        if (utils_1.isInstanceOf(request, Request)) {
          headers = request.headers;
        }
        if (headers) {
          if (typeof headers.append === "function") {
            headers.append("sentry-trace", span.toTraceparent());
          } else if (Array.isArray(headers)) {
            headers = tslib_1.__spread(headers, [["sentry-trace", span.toTraceparent()]]);
          } else {
            headers = tslib_1.__assign(tslib_1.__assign({}, headers), { "sentry-trace": span.toTraceparent() });
          }
        } else {
          headers = { "sentry-trace": span.toTraceparent() };
        }
        options.headers = headers;
      }
    }
    exports2.fetchCallback = fetchCallback;
    function xhrCallback(handlerData, shouldCreateSpan, spans) {
      var _a, _b;
      if (!utils_2.hasTracingEnabled() || ((_a = handlerData.xhr) === null || _a === void 0 ? void 0 : _a.__sentry_own_request__) || !(((_b = handlerData.xhr) === null || _b === void 0 ? void 0 : _b.__sentry_xhr__) && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))) {
        return;
      }
      var xhr = handlerData.xhr.__sentry_xhr__;
      if (handlerData.endTimestamp && handlerData.xhr.__sentry_xhr_span_id__) {
        var span = spans[handlerData.xhr.__sentry_xhr_span_id__];
        if (span) {
          span.setHttpStatus(xhr.status_code);
          span.finish();
          delete spans[handlerData.xhr.__sentry_xhr_span_id__];
        }
        return;
      }
      var activeTransaction = utils_2.getActiveTransaction();
      if (activeTransaction) {
        var span = activeTransaction.startChild({
          data: tslib_1.__assign(tslib_1.__assign({}, xhr.data), { type: "xhr", method: xhr.method, url: xhr.url }),
          description: xhr.method + " " + xhr.url,
          op: "http.client"
        });
        handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;
        spans[handlerData.xhr.__sentry_xhr_span_id__] = span;
        if (handlerData.xhr.setRequestHeader) {
          try {
            handlerData.xhr.setRequestHeader("sentry-trace", span.toTraceparent());
          } catch (_) {
          }
        }
      }
    }
    exports2.xhrCallback = xhrCallback;
  }
});

// node_modules/@sentry/tracing/dist/browser/router.js
var require_router = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/router.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var global2 = utils_1.getGlobalObject();
    function instrumentRoutingWithDefaults(customStartTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
      if (startTransactionOnPageLoad === void 0) {
        startTransactionOnPageLoad = true;
      }
      if (startTransactionOnLocationChange === void 0) {
        startTransactionOnLocationChange = true;
      }
      if (!global2 || !global2.location) {
        utils_1.logger.warn("Could not initialize routing instrumentation due to invalid location");
        return;
      }
      var startingUrl = global2.location.href;
      var activeTransaction;
      if (startTransactionOnPageLoad) {
        activeTransaction = customStartTransaction({ name: global2.location.pathname, op: "pageload" });
      }
      if (startTransactionOnLocationChange) {
        utils_1.addInstrumentationHandler({
          callback: function(_a) {
            var to = _a.to, from = _a.from;
            if (from === void 0 && startingUrl && startingUrl.indexOf(to) !== -1) {
              startingUrl = void 0;
              return;
            }
            if (from !== to) {
              startingUrl = void 0;
              if (activeTransaction) {
                utils_1.logger.log("[Tracing] Finishing current transaction with op: " + activeTransaction.op);
                activeTransaction.finish();
              }
              activeTransaction = customStartTransaction({ name: global2.location.pathname, op: "navigation" });
            }
          },
          type: "history"
        });
      }
    }
    exports2.instrumentRoutingWithDefaults = instrumentRoutingWithDefaults;
  }
});

// node_modules/@sentry/tracing/dist/browser/browsertracing.js
var require_browsertracing = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/browsertracing.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var utils_1 = require_dist2();
    var hubextensions_1 = require_hubextensions();
    var idletransaction_1 = require_idletransaction();
    var spanstatus_1 = require_spanstatus();
    var utils_2 = require_utils2();
    var backgroundtab_1 = require_backgroundtab();
    var metrics_1 = require_metrics();
    var request_1 = require_request2();
    var router_1 = require_router();
    exports2.DEFAULT_MAX_TRANSACTION_DURATION_SECONDS = 600;
    var DEFAULT_BROWSER_TRACING_OPTIONS = tslib_1.__assign({ idleTimeout: idletransaction_1.DEFAULT_IDLE_TIMEOUT, markBackgroundTransactions: true, maxTransactionDuration: exports2.DEFAULT_MAX_TRANSACTION_DURATION_SECONDS, routingInstrumentation: router_1.instrumentRoutingWithDefaults, startTransactionOnLocationChange: true, startTransactionOnPageLoad: true }, request_1.defaultRequestInstrumentationOptions);
    var BrowserTracing = function() {
      function BrowserTracing2(_options) {
        this.name = BrowserTracing2.id;
        this._emitOptionsWarning = false;
        var tracingOrigins = request_1.defaultRequestInstrumentationOptions.tracingOrigins;
        if (_options && _options.tracingOrigins && Array.isArray(_options.tracingOrigins) && _options.tracingOrigins.length !== 0) {
          tracingOrigins = _options.tracingOrigins;
        } else {
          this._emitOptionsWarning = true;
        }
        this.options = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, DEFAULT_BROWSER_TRACING_OPTIONS), _options), { tracingOrigins });
        this._metrics = new metrics_1.MetricsInstrumentation(tslib_1.__assign(tslib_1.__assign({}, metrics_1.DEFAULT_METRICS_INSTR_OPTIONS), this.options._metricOptions));
      }
      BrowserTracing2.prototype.setupOnce = function(_, getCurrentHub) {
        var _this = this;
        this._getCurrentHub = getCurrentHub;
        if (this._emitOptionsWarning) {
          utils_1.logger.warn("[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.");
          utils_1.logger.warn("[Tracing] We added a reasonable default for you: " + request_1.defaultRequestInstrumentationOptions.tracingOrigins);
        }
        var _a = this.options, instrumentRouting = _a.routingInstrumentation, startTransactionOnLocationChange = _a.startTransactionOnLocationChange, startTransactionOnPageLoad = _a.startTransactionOnPageLoad, markBackgroundTransactions = _a.markBackgroundTransactions, traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
        instrumentRouting(function(context) {
          return _this._createRouteTransaction(context);
        }, startTransactionOnPageLoad, startTransactionOnLocationChange);
        if (markBackgroundTransactions) {
          backgroundtab_1.registerBackgroundTabDetection();
        }
        request_1.instrumentOutgoingRequests({ traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest });
      };
      BrowserTracing2.prototype._createRouteTransaction = function(context) {
        var _this = this;
        if (!this._getCurrentHub) {
          utils_1.logger.warn("[Tracing] Did not create " + context.op + " transaction because _getCurrentHub is invalid.");
          return void 0;
        }
        var _a = this.options, beforeNavigate = _a.beforeNavigate, idleTimeout = _a.idleTimeout, maxTransactionDuration = _a.maxTransactionDuration;
        var parentContextFromHeader = context.op === "pageload" ? getHeaderContext() : void 0;
        var expandedContext = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, context), parentContextFromHeader), { trimEnd: true });
        var modifiedContext = typeof beforeNavigate === "function" ? beforeNavigate(expandedContext) : expandedContext;
        var finalContext = modifiedContext === void 0 ? tslib_1.__assign(tslib_1.__assign({}, expandedContext), { sampled: false }) : modifiedContext;
        if (finalContext.sampled === false) {
          utils_1.logger.log("[Tracing] Will not send " + finalContext.op + " transaction because of beforeNavigate.");
        }
        utils_1.logger.log("[Tracing] Starting " + finalContext.op + " transaction on scope");
        var hub = this._getCurrentHub();
        var location = utils_1.getGlobalObject().location;
        var idleTransaction = hubextensions_1.startIdleTransaction(hub, finalContext, idleTimeout, true, { location });
        idleTransaction.registerBeforeFinishCallback(function(transaction2, endTimestamp) {
          _this._metrics.addPerformanceEntries(transaction2);
          adjustTransactionDuration(utils_2.secToMs(maxTransactionDuration), transaction2, endTimestamp);
        });
        return idleTransaction;
      };
      BrowserTracing2.id = "BrowserTracing";
      return BrowserTracing2;
    }();
    exports2.BrowserTracing = BrowserTracing;
    function getHeaderContext() {
      var header = getMetaContent("sentry-trace");
      if (header) {
        return utils_2.extractTraceparentData(header);
      }
      return void 0;
    }
    exports2.getHeaderContext = getHeaderContext;
    function getMetaContent(metaName) {
      var el = utils_1.getGlobalObject().document.querySelector("meta[name=" + metaName + "]");
      return el ? el.getAttribute("content") : null;
    }
    exports2.getMetaContent = getMetaContent;
    function adjustTransactionDuration(maxDuration, transaction2, endTimestamp) {
      var diff = endTimestamp - transaction2.startTimestamp;
      var isOutdatedTransaction = endTimestamp && (diff > maxDuration || diff < 0);
      if (isOutdatedTransaction) {
        transaction2.setStatus(spanstatus_1.SpanStatus.DeadlineExceeded);
        transaction2.setTag("maxTransactionDurationExceeded", "true");
      }
    }
  }
});

// node_modules/@sentry/tracing/dist/browser/index.js
var require_browser3 = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var browsertracing_1 = require_browsertracing();
    exports2.BrowserTracing = browsertracing_1.BrowserTracing;
    var request_1 = require_request2();
    exports2.instrumentOutgoingRequests = request_1.instrumentOutgoingRequests;
    exports2.defaultRequestInstrumentationOptions = request_1.defaultRequestInstrumentationOptions;
  }
});

// node_modules/@sentry/tracing/dist/integrations/node/express.js
var require_express = __commonJS({
  "node_modules/@sentry/tracing/dist/integrations/node/express.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var utils_1 = require_dist2();
    var Express = function() {
      function Express2(options) {
        if (options === void 0) {
          options = {};
        }
        this.name = Express2.id;
        this._router = options.router || options.app;
        this._methods = (Array.isArray(options.methods) ? options.methods : []).concat("use");
      }
      Express2.prototype.setupOnce = function() {
        if (!this._router) {
          utils_1.logger.error("ExpressIntegration is missing an Express instance");
          return;
        }
        instrumentMiddlewares(this._router, this._methods);
      };
      Express2.id = "Express";
      return Express2;
    }();
    exports2.Express = Express;
    function wrap(fn, method) {
      var arity = fn.length;
      switch (arity) {
        case 2: {
          return function(req, res) {
            var transaction2 = res.__sentry_transaction;
            if (transaction2) {
              var span_1 = transaction2.startChild({
                description: fn.name,
                op: "middleware." + method
              });
              res.once("finish", function() {
                span_1.finish();
              });
            }
            return fn.call(this, req, res);
          };
        }
        case 3: {
          return function(req, res, next) {
            var _a;
            var transaction2 = res.__sentry_transaction;
            var span = (_a = transaction2) === null || _a === void 0 ? void 0 : _a.startChild({
              description: fn.name,
              op: "middleware." + method
            });
            fn.call(this, req, res, function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var _a2;
              (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
              next.call.apply(next, tslib_1.__spread([this], args));
            });
          };
        }
        case 4: {
          return function(err, req, res, next) {
            var _a;
            var transaction2 = res.__sentry_transaction;
            var span = (_a = transaction2) === null || _a === void 0 ? void 0 : _a.startChild({
              description: fn.name,
              op: "middleware." + method
            });
            fn.call(this, err, req, res, function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var _a2;
              (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
              next.call.apply(next, tslib_1.__spread([this], args));
            });
          };
        }
        default: {
          throw new Error("Express middleware takes 2-4 arguments. Got: " + arity);
        }
      }
    }
    function wrapMiddlewareArgs(args, method) {
      return args.map(function(arg) {
        if (typeof arg === "function") {
          return wrap(arg, method);
        }
        if (Array.isArray(arg)) {
          return arg.map(function(a) {
            if (typeof a === "function") {
              return wrap(a, method);
            }
            return a;
          });
        }
        return arg;
      });
    }
    function patchMiddleware(router, method) {
      var originalCallback = router[method];
      router[method] = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return originalCallback.call.apply(originalCallback, tslib_1.__spread([this], wrapMiddlewareArgs(args, method)));
      };
      return router;
    }
    function instrumentMiddlewares(router, methods) {
      if (methods === void 0) {
        methods = [];
      }
      methods.forEach(function(method) {
        return patchMiddleware(router, method);
      });
    }
  }
});

// node_modules/@sentry/tracing/dist/integrations/node/postgres.js
var require_postgres = __commonJS({
  "node_modules/@sentry/tracing/dist/integrations/node/postgres.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var Postgres = function() {
      function Postgres2(options) {
        if (options === void 0) {
          options = {};
        }
        this.name = Postgres2.id;
        this._usePgNative = !!options.usePgNative;
      }
      Postgres2.prototype.setupOnce = function(_, getCurrentHub) {
        var _a;
        var pkg = utils_1.loadModule("pg");
        if (!pkg) {
          utils_1.logger.error("Postgres Integration was unable to require `pg` package.");
          return;
        }
        if (this._usePgNative && !((_a = pkg.native) === null || _a === void 0 ? void 0 : _a.Client)) {
          utils_1.logger.error("Postgres Integration was unable to access 'pg-native' bindings.");
          return;
        }
        var Client = (this._usePgNative ? pkg.native : pkg).Client;
        utils_1.fill(Client.prototype, "query", function(orig) {
          return function(config3, values, callback) {
            var _a2, _b, _c;
            var scope = getCurrentHub().getScope();
            var parentSpan = (_a2 = scope) === null || _a2 === void 0 ? void 0 : _a2.getSpan();
            var span = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild({
              description: typeof config3 === "string" ? config3 : config3.text,
              op: "db"
            });
            if (typeof callback === "function") {
              return orig.call(this, config3, values, function(err, result) {
                var _a3;
                (_a3 = span) === null || _a3 === void 0 ? void 0 : _a3.finish();
                callback(err, result);
              });
            }
            if (typeof values === "function") {
              return orig.call(this, config3, function(err, result) {
                var _a3;
                (_a3 = span) === null || _a3 === void 0 ? void 0 : _a3.finish();
                values(err, result);
              });
            }
            var rv = typeof values !== "undefined" ? orig.call(this, config3, values) : orig.call(this, config3);
            if (utils_1.isThenable(rv)) {
              return rv.then(function(res) {
                var _a3;
                (_a3 = span) === null || _a3 === void 0 ? void 0 : _a3.finish();
                return res;
              });
            }
            (_c = span) === null || _c === void 0 ? void 0 : _c.finish();
            return rv;
          };
        });
      };
      Postgres2.id = "Postgres";
      return Postgres2;
    }();
    exports2.Postgres = Postgres;
  }
});

// node_modules/@sentry/tracing/dist/integrations/node/mysql.js
var require_mysql = __commonJS({
  "node_modules/@sentry/tracing/dist/integrations/node/mysql.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var Mysql = function() {
      function Mysql2() {
        this.name = Mysql2.id;
      }
      Mysql2.prototype.setupOnce = function(_, getCurrentHub) {
        var pkg = utils_1.loadModule("mysql/lib/Connection.js");
        if (!pkg) {
          utils_1.logger.error("Mysql Integration was unable to require `mysql` package.");
          return;
        }
        utils_1.fill(pkg, "createQuery", function(orig) {
          return function(options, values, callback) {
            var _a, _b;
            var scope = getCurrentHub().getScope();
            var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();
            var span = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild({
              description: typeof options === "string" ? options : options.sql,
              op: "db"
            });
            if (typeof callback === "function") {
              return orig.call(this, options, values, function(err, result, fields) {
                var _a2;
                (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
                callback(err, result, fields);
              });
            }
            if (typeof values === "function") {
              return orig.call(this, options, function(err, result, fields) {
                var _a2;
                (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
                values(err, result, fields);
              });
            }
            return orig.call(this, options, values, callback);
          };
        });
      };
      Mysql2.id = "Mysql";
      return Mysql2;
    }();
    exports2.Mysql = Mysql;
  }
});

// node_modules/@sentry/tracing/dist/integrations/node/mongo.js
var require_mongo = __commonJS({
  "node_modules/@sentry/tracing/dist/integrations/node/mongo.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var utils_1 = require_dist2();
    var OPERATIONS = [
      "aggregate",
      "bulkWrite",
      "countDocuments",
      "createIndex",
      "createIndexes",
      "deleteMany",
      "deleteOne",
      "distinct",
      "drop",
      "dropIndex",
      "dropIndexes",
      "estimatedDocumentCount",
      "find",
      "findOne",
      "findOneAndDelete",
      "findOneAndReplace",
      "findOneAndUpdate",
      "indexes",
      "indexExists",
      "indexInformation",
      "initializeOrderedBulkOp",
      "insertMany",
      "insertOne",
      "isCapped",
      "mapReduce",
      "options",
      "parallelCollectionScan",
      "rename",
      "replaceOne",
      "stats",
      "updateMany",
      "updateOne"
    ];
    var OPERATION_SIGNATURES = {
      bulkWrite: ["operations"],
      countDocuments: ["query"],
      createIndex: ["fieldOrSpec"],
      createIndexes: ["indexSpecs"],
      deleteMany: ["filter"],
      deleteOne: ["filter"],
      distinct: ["key", "query"],
      dropIndex: ["indexName"],
      find: ["query"],
      findOne: ["query"],
      findOneAndDelete: ["filter"],
      findOneAndReplace: ["filter", "replacement"],
      findOneAndUpdate: ["filter", "update"],
      indexExists: ["indexes"],
      insertMany: ["docs"],
      insertOne: ["doc"],
      mapReduce: ["map", "reduce"],
      rename: ["newName"],
      replaceOne: ["filter", "doc"],
      updateMany: ["filter", "update"],
      updateOne: ["filter", "update"]
    };
    var Mongo = function() {
      function Mongo2(options) {
        if (options === void 0) {
          options = {};
        }
        this.name = Mongo2.id;
        this._operations = Array.isArray(options.operations) ? options.operations : OPERATIONS;
        this._describeOperations = "describeOperations" in options ? options.describeOperations : true;
        this._useMongoose = !!options.useMongoose;
      }
      Mongo2.prototype.setupOnce = function(_, getCurrentHub) {
        var moduleName = this._useMongoose ? "mongoose" : "mongodb";
        var pkg = utils_1.loadModule(moduleName);
        if (!pkg) {
          utils_1.logger.error("Mongo Integration was unable to require `" + moduleName + "` package.");
          return;
        }
        this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);
      };
      Mongo2.prototype._instrumentOperations = function(collection, operations, getCurrentHub) {
        var _this = this;
        operations.forEach(function(operation) {
          return _this._patchOperation(collection, operation, getCurrentHub);
        });
      };
      Mongo2.prototype._patchOperation = function(collection, operation, getCurrentHub) {
        if (!(operation in collection.prototype))
          return;
        var getSpanContext = this._getSpanContextFromOperationArguments.bind(this);
        utils_1.fill(collection.prototype, operation, function(orig) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var _a, _b, _c, _d;
            var lastArg = args[args.length - 1];
            var scope = getCurrentHub().getScope();
            var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();
            if (typeof lastArg !== "function" || operation === "mapReduce" && args.length === 2) {
              var span_1 = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild(getSpanContext(this, operation, args));
              var maybePromise = orig.call.apply(orig, tslib_1.__spread([this], args));
              if (utils_1.isThenable(maybePromise)) {
                return maybePromise.then(function(res) {
                  var _a2;
                  (_a2 = span_1) === null || _a2 === void 0 ? void 0 : _a2.finish();
                  return res;
                });
              } else {
                (_c = span_1) === null || _c === void 0 ? void 0 : _c.finish();
                return maybePromise;
              }
            }
            var span = (_d = parentSpan) === null || _d === void 0 ? void 0 : _d.startChild(getSpanContext(this, operation, args.slice(0, -1)));
            return orig.call.apply(orig, tslib_1.__spread([this], args.slice(0, -1), [function(err, result) {
              var _a2;
              (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
              lastArg(err, result);
            }]));
          };
        });
      };
      Mongo2.prototype._getSpanContextFromOperationArguments = function(collection, operation, args) {
        var data = {
          collectionName: collection.collectionName,
          dbName: collection.dbName,
          namespace: collection.namespace
        };
        var spanContext = {
          op: "db",
          description: operation,
          data
        };
        var signature = OPERATION_SIGNATURES[operation];
        var shouldDescribe = Array.isArray(this._describeOperations) ? this._describeOperations.includes(operation) : this._describeOperations;
        if (!signature || !shouldDescribe) {
          return spanContext;
        }
        try {
          if (operation === "mapReduce") {
            var _a = tslib_1.__read(args, 2), map = _a[0], reduce = _a[1];
            data[signature[0]] = typeof map === "string" ? map : map.name || "<anonymous>";
            data[signature[1]] = typeof reduce === "string" ? reduce : reduce.name || "<anonymous>";
          } else {
            for (var i = 0; i < signature.length; i++) {
              data[signature[i]] = JSON.stringify(args[i]);
            }
          }
        } catch (_oO) {
        }
        return spanContext;
      };
      Mongo2.id = "Mongo";
      return Mongo2;
    }();
    exports2.Mongo = Mongo;
  }
});

// node_modules/@sentry/tracing/dist/integrations/index.js
var require_integrations3 = __commonJS({
  "node_modules/@sentry/tracing/dist/integrations/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var express_1 = require_express();
    exports2.Express = express_1.Express;
    var postgres_1 = require_postgres();
    exports2.Postgres = postgres_1.Postgres;
    var mysql_1 = require_mysql();
    exports2.Mysql = mysql_1.Mysql;
    var mongo_1 = require_mongo();
    exports2.Mongo = mongo_1.Mongo;
  }
});

// node_modules/@sentry/tracing/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/@sentry/tracing/dist/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var browser_1 = require_browser3();
    var hubextensions_1 = require_hubextensions();
    exports2.addExtensionMethods = hubextensions_1.addExtensionMethods;
    var TracingIntegrations = require_integrations3();
    var Integrations = tslib_1.__assign(tslib_1.__assign({}, TracingIntegrations), { BrowserTracing: browser_1.BrowserTracing });
    exports2.Integrations = Integrations;
    var span_1 = require_span();
    exports2.Span = span_1.Span;
    var transaction_1 = require_transaction2();
    exports2.Transaction = transaction_1.Transaction;
    var browser_2 = require_browser3();
    exports2.registerRequestInstrumentation = browser_2.instrumentOutgoingRequests;
    exports2.defaultRequestInstrumentationOptions = browser_2.defaultRequestInstrumentationOptions;
    var spanstatus_1 = require_spanstatus();
    exports2.SpanStatus = spanstatus_1.SpanStatus;
    var idletransaction_1 = require_idletransaction();
    exports2.IdleTransaction = idletransaction_1.IdleTransaction;
    var hubextensions_2 = require_hubextensions();
    exports2.startIdleTransaction = hubextensions_2.startIdleTransaction;
    hubextensions_1.addExtensionMethods();
    var utils_1 = require_utils2();
    exports2.extractTraceparentData = utils_1.extractTraceparentData;
    exports2.getActiveTransaction = utils_1.getActiveTransaction;
    exports2.hasTracingEnabled = utils_1.hasTracingEnabled;
    exports2.stripUrlQueryAndFragment = utils_1.stripUrlQueryAndFragment;
    exports2.TRACEPARENT_REGEXP = utils_1.TRACEPARENT_REGEXP;
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports2) {
    "use strict";
    exports2.parse = parse;
    exports2.serialize = serialize;
    var decode = decodeURIComponent;
    var encode = encodeURIComponent;
    var pairSplitRegExp = /; */;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var pairs = str.split(pairSplitRegExp);
      var dec = opt.decode || decode;
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        var eq_idx = pair.indexOf("=");
        if (eq_idx < 0) {
          continue;
        }
        var key = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();
        if (val[0] == '"') {
          val = val.slice(1, -1);
        }
        if (obj[key] == void 0) {
          obj[key] = tryDecode(val, dec);
        }
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (opt.maxAge != null) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// node_modules/@sentry/node/dist/handlers.js
var require_handlers = __commonJS({
  "node_modules/@sentry/node/dist/handlers.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var tracing_1 = require_dist7();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var cookie = require_cookie();
    var domain = require("domain");
    var os = require("os");
    var url = require("url");
    var sdk_1 = require_sdk2();
    function tracingHandler() {
      return function sentryTracingMiddleware(req, res, next) {
        var traceparentData;
        if (req.headers && utils_1.isString(req.headers["sentry-trace"])) {
          traceparentData = tracing_1.extractTraceparentData(req.headers["sentry-trace"]);
        }
        var transaction2 = core_1.startTransaction(tslib_1.__assign({ name: extractExpressTransactionName(req, { path: true, method: true }), op: "http.server" }, traceparentData), { request: extractRequestData(req) });
        core_1.getCurrentHub().configureScope(function(scope) {
          scope.setSpan(transaction2);
        });
        res.__sentry_transaction = transaction2;
        res.once("finish", function() {
          setImmediate(function() {
            addExpressReqToTransaction(transaction2, req);
            transaction2.setHttpStatus(res.statusCode);
            transaction2.finish();
          });
        });
        next();
      };
    }
    exports2.tracingHandler = tracingHandler;
    function addExpressReqToTransaction(transaction2, req) {
      if (!transaction2)
        return;
      transaction2.name = extractExpressTransactionName(req, { path: true, method: true });
      transaction2.setData("url", req.originalUrl);
      transaction2.setData("baseUrl", req.baseUrl);
      transaction2.setData("query", req.query);
    }
    function extractExpressTransactionName(req, options) {
      if (options === void 0) {
        options = {};
      }
      var _a;
      var method = (_a = req.method) === null || _a === void 0 ? void 0 : _a.toUpperCase();
      var path = "";
      if (req.route) {
        path = "" + (req.baseUrl || "") + req.route.path;
      } else if (req.originalUrl || req.url) {
        path = utils_1.stripUrlQueryAndFragment(req.originalUrl || req.url || "");
      }
      var info = "";
      if (options.method && method) {
        info += method;
      }
      if (options.method && options.path) {
        info += " ";
      }
      if (options.path && path) {
        info += path;
      }
      return info;
    }
    function extractTransaction(req, type) {
      var _a;
      switch (type) {
        case "path": {
          return extractExpressTransactionName(req, { path: true });
        }
        case "handler": {
          return ((_a = req.route) === null || _a === void 0 ? void 0 : _a.stack[0].name) || "<anonymous>";
        }
        case "methodPath":
        default: {
          return extractExpressTransactionName(req, { path: true, method: true });
        }
      }
    }
    var DEFAULT_USER_KEYS = ["id", "username", "email"];
    function extractUserData(user, keys) {
      var extractedUser = {};
      var attributes = Array.isArray(keys) ? keys : DEFAULT_USER_KEYS;
      attributes.forEach(function(key) {
        if (user && key in user) {
          extractedUser[key] = user[key];
        }
      });
      return extractedUser;
    }
    var DEFAULT_REQUEST_KEYS = ["cookies", "data", "headers", "method", "query_string", "url"];
    function extractRequestData(req, keys) {
      if (keys === void 0) {
        keys = DEFAULT_REQUEST_KEYS;
      }
      var requestData = {};
      var headers = req.headers || req.header || {};
      var method = req.method;
      var host = req.hostname || req.host || headers.host || "<no host>";
      var protocol = req.protocol === "https" || req.secure || (req.socket || {}).encrypted ? "https" : "http";
      var originalUrl = req.originalUrl || req.url || "";
      var absoluteUrl = protocol + "://" + host + originalUrl;
      keys.forEach(function(key) {
        switch (key) {
          case "headers":
            requestData.headers = headers;
            break;
          case "method":
            requestData.method = method;
            break;
          case "url":
            requestData.url = absoluteUrl;
            break;
          case "cookies":
            requestData.cookies = req.cookies || cookie.parse(headers.cookie || "");
            break;
          case "query_string":
            requestData.query_string = req.query || url.parse(originalUrl || "", false).query;
            break;
          case "data":
            if (method === "GET" || method === "HEAD") {
              break;
            }
            if (req.body !== void 0) {
              requestData.data = utils_1.isString(req.body) ? req.body : JSON.stringify(utils_1.normalize(req.body));
            }
            break;
          default:
            if ({}.hasOwnProperty.call(req, key)) {
              requestData[key] = req[key];
            }
        }
      });
      return requestData;
    }
    exports2.extractRequestData = extractRequestData;
    function parseRequest(event, req, options) {
      options = tslib_1.__assign({ ip: false, request: true, serverName: true, transaction: true, user: true, version: true }, options);
      if (options.version) {
        event.contexts = tslib_1.__assign(tslib_1.__assign({}, event.contexts), { runtime: {
          name: "node",
          version: global.process.version
        } });
      }
      if (options.request) {
        var extractedRequestData = Array.isArray(options.request) ? extractRequestData(req, options.request) : extractRequestData(req);
        event.request = tslib_1.__assign(tslib_1.__assign({}, event.request), extractedRequestData);
      }
      if (options.serverName && !event.server_name) {
        event.server_name = global.process.env.SENTRY_NAME || os.hostname();
      }
      if (options.user) {
        var extractedUser = req.user && utils_1.isPlainObject(req.user) ? extractUserData(req.user, options.user) : {};
        if (Object.keys(extractedUser)) {
          event.user = tslib_1.__assign(tslib_1.__assign({}, event.user), extractedUser);
        }
      }
      if (options.ip) {
        var ip = req.ip || req.connection && req.connection.remoteAddress;
        if (ip) {
          event.user = tslib_1.__assign(tslib_1.__assign({}, event.user), { ip_address: ip });
        }
      }
      if (options.transaction && !event.transaction) {
        event.transaction = extractTransaction(req, options.transaction);
      }
      return event;
    }
    exports2.parseRequest = parseRequest;
    function requestHandler(options) {
      var currentHub = core_1.getCurrentHub();
      var client = currentHub.getClient();
      if (client && sdk_1.isAutoSessionTrackingEnabled(client)) {
        client.initSessionFlusher();
        var scope = currentHub.getScope();
        if (scope && scope.getSession()) {
          scope.setSession();
        }
      }
      return function sentryRequestMiddleware(req, res, next) {
        if (options && options.flushTimeout && options.flushTimeout > 0) {
          var _end_1 = res.end;
          res.end = function(chunk, encoding, cb) {
            var _this = this;
            void sdk_1.flush(options.flushTimeout).then(function() {
              _end_1.call(_this, chunk, encoding, cb);
            }).then(null, function(e) {
              utils_1.logger.error(e);
            });
          };
        }
        var local = domain.create();
        local.add(req);
        local.add(res);
        local.on("error", next);
        local.run(function() {
          var currentHub2 = core_1.getCurrentHub();
          currentHub2.configureScope(function(scope2) {
            scope2.addEventProcessor(function(event) {
              return parseRequest(event, req, options);
            });
            var client2 = currentHub2.getClient();
            if (sdk_1.isAutoSessionTrackingEnabled(client2)) {
              var scope_1 = currentHub2.getScope();
              if (scope_1) {
                scope_1.setRequestSession({ status: types_1.RequestSessionStatus.Ok });
              }
            }
          });
          res.once("finish", function() {
            var client2 = currentHub2.getClient();
            if (sdk_1.isAutoSessionTrackingEnabled(client2)) {
              setImmediate(function() {
                if (client2 && client2._captureRequestSession) {
                  client2._captureRequestSession();
                }
              });
            }
          });
          next();
        });
      };
    }
    exports2.requestHandler = requestHandler;
    function getStatusCodeFromResponse(error2) {
      var statusCode = error2.status || error2.statusCode || error2.status_code || error2.output && error2.output.statusCode;
      return statusCode ? parseInt(statusCode, 10) : 500;
    }
    function defaultShouldHandleError(error2) {
      var status = getStatusCodeFromResponse(error2);
      return status >= 500;
    }
    function errorHandler(options) {
      return function sentryErrorMiddleware(error2, _req, res, next) {
        var shouldHandleError = options && options.shouldHandleError || defaultShouldHandleError;
        if (shouldHandleError(error2)) {
          core_1.withScope(function(_scope) {
            var transaction2 = res.__sentry_transaction;
            if (transaction2 && _scope.getSpan() === void 0) {
              _scope.setSpan(transaction2);
            }
            var client = core_1.getCurrentHub().getClient();
            if (client && sdk_1.isAutoSessionTrackingEnabled(client)) {
              var isSessionAggregatesMode = client._sessionFlusher !== void 0;
              if (isSessionAggregatesMode) {
                var requestSession = _scope.getRequestSession();
                if (requestSession && requestSession.status !== void 0)
                  requestSession.status = types_1.RequestSessionStatus.Crashed;
              }
            }
            var eventId = core_1.captureException(error2);
            res.sentry = eventId;
            next(error2);
          });
          return;
        }
        next(error2);
      };
    }
    exports2.errorHandler = errorHandler;
  }
});

// node_modules/@sentry/node/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/@sentry/node/dist/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var types_1 = require_dist();
    exports2.Severity = types_1.Severity;
    exports2.Status = types_1.Status;
    var core_1 = require_dist5();
    exports2.addGlobalEventProcessor = core_1.addGlobalEventProcessor;
    exports2.addBreadcrumb = core_1.addBreadcrumb;
    exports2.captureException = core_1.captureException;
    exports2.captureEvent = core_1.captureEvent;
    exports2.captureMessage = core_1.captureMessage;
    exports2.configureScope = core_1.configureScope;
    exports2.getHubFromCarrier = core_1.getHubFromCarrier;
    exports2.getCurrentHub = core_1.getCurrentHub;
    exports2.Hub = core_1.Hub;
    exports2.makeMain = core_1.makeMain;
    exports2.Scope = core_1.Scope;
    exports2.startTransaction = core_1.startTransaction;
    exports2.SDK_VERSION = core_1.SDK_VERSION;
    exports2.setContext = core_1.setContext;
    exports2.setExtra = core_1.setExtra;
    exports2.setExtras = core_1.setExtras;
    exports2.setTag = core_1.setTag;
    exports2.setTags = core_1.setTags;
    exports2.setUser = core_1.setUser;
    exports2.withScope = core_1.withScope;
    var backend_1 = require_backend();
    exports2.NodeBackend = backend_1.NodeBackend;
    var client_1 = require_client();
    exports2.NodeClient = client_1.NodeClient;
    var sdk_1 = require_sdk2();
    exports2.defaultIntegrations = sdk_1.defaultIntegrations;
    exports2.init = sdk_1.init;
    exports2.lastEventId = sdk_1.lastEventId;
    exports2.flush = sdk_1.flush;
    exports2.close = sdk_1.close;
    exports2.getSentryRelease = sdk_1.getSentryRelease;
    var utils_1 = require_utils();
    exports2.deepReadDirSync = utils_1.deepReadDirSync;
    var version_1 = require_version2();
    exports2.SDK_NAME = version_1.SDK_NAME;
    var core_2 = require_dist5();
    var hub_1 = require_dist3();
    var domain = require("domain");
    var Handlers = require_handlers();
    exports2.Handlers = Handlers;
    var NodeIntegrations = require_integrations2();
    var Transports = require_transports();
    exports2.Transports = Transports;
    var INTEGRATIONS = tslib_1.__assign(tslib_1.__assign({}, core_2.Integrations), NodeIntegrations);
    exports2.Integrations = INTEGRATIONS;
    var carrier = hub_1.getMainCarrier();
    if (carrier.__SENTRY__) {
      carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
      carrier.__SENTRY__.extensions.domain = carrier.__SENTRY__.extensions.domain || domain;
    }
  }
});

// node_modules/dtrace-provider/dtrace-provider.js
var require_dtrace_provider = __commonJS({
  "node_modules/dtrace-provider/dtrace-provider.js"(exports2) {
    var DTraceProvider;
    function DTraceProviderStub() {
    }
    DTraceProviderStub.prototype.addProbe = function(name) {
      var p = { "fire": function() {
      } };
      this[name] = p;
      return p;
    };
    DTraceProviderStub.prototype.enable = function() {
    };
    DTraceProviderStub.prototype.fire = function() {
    };
    DTraceProviderStub.prototype.disable = function() {
    };
    var builds = ["Release", "default", "Debug"];
    var err = null;
    for (i = 0; i < builds.length; i++) {
      try {
        binding = require("./src/build/" + builds[i] + "/DTraceProviderBindings");
        DTraceProvider = binding.DTraceProvider;
        break;
      } catch (e) {
        if (err === null) {
          err = e;
        }
      }
    }
    var binding;
    var i;
    if (!DTraceProvider) {
      if (process.env.NODE_DTRACE_PROVIDER_REQUIRE === "hard") {
        throw err;
      } else {
        DTraceProvider = DTraceProviderStub;
      }
    }
    exports2.DTraceProvider = DTraceProvider;
    exports2.createDTraceProvider = function(name, module3) {
      if (arguments.length == 2)
        return new exports2.DTraceProvider(name, module3);
      return new exports2.DTraceProvider(name);
    };
  }
});

// node_modules/safe-json-stringify/index.js
var require_safe_json_stringify = __commonJS({
  "node_modules/safe-json-stringify/index.js"(exports2, module2) {
    var hasProp = Object.prototype.hasOwnProperty;
    function throwsMessage(err) {
      return "[Throws: " + (err ? err.message : "?") + "]";
    }
    function safeGetValueFromPropertyOnObject(obj, property) {
      if (hasProp.call(obj, property)) {
        try {
          return obj[property];
        } catch (err) {
          return throwsMessage(err);
        }
      }
      return obj[property];
    }
    function ensureProperties(obj) {
      var seen = [];
      function visit(obj2) {
        if (obj2 === null || typeof obj2 !== "object") {
          return obj2;
        }
        if (seen.indexOf(obj2) !== -1) {
          return "[Circular]";
        }
        seen.push(obj2);
        if (typeof obj2.toJSON === "function") {
          try {
            var fResult = visit(obj2.toJSON());
            seen.pop();
            return fResult;
          } catch (err) {
            return throwsMessage(err);
          }
        }
        if (Array.isArray(obj2)) {
          var aResult = obj2.map(visit);
          seen.pop();
          return aResult;
        }
        var result = Object.keys(obj2).reduce(function(result2, prop) {
          result2[prop] = visit(safeGetValueFromPropertyOnObject(obj2, prop));
          return result2;
        }, {});
        seen.pop();
        return result;
      }
      ;
      return visit(obj);
    }
    module2.exports = function(data, replacer, space) {
      return JSON.stringify(ensureProperties(data), replacer, space);
    };
    module2.exports.ensureProperties = ensureProperties;
  }
});

// node_modules/ncp/lib/ncp.js
var require_ncp = __commonJS({
  "node_modules/ncp/lib/ncp.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    module2.exports = ncp;
    ncp.ncp = ncp;
    function ncp(source, dest, options, callback) {
      var cback = callback;
      if (!callback) {
        cback = options;
        options = {};
      }
      var basePath = process.cwd(), currentPath = path.resolve(basePath, source), targetPath = path.resolve(basePath, dest), filter = options.filter, rename = options.rename, transform = options.transform, clobber = options.clobber !== false, modified = options.modified, dereference = options.dereference, errs = null, started = 0, finished = 0, running = 0, limit = options.limit || ncp.limit || 16;
      limit = limit < 1 ? 1 : limit > 512 ? 512 : limit;
      startCopy(currentPath);
      function startCopy(source2) {
        started++;
        if (filter) {
          if (filter instanceof RegExp) {
            if (!filter.test(source2)) {
              return cb(true);
            }
          } else if (typeof filter === "function") {
            if (!filter(source2)) {
              return cb(true);
            }
          }
        }
        return getStats(source2);
      }
      function getStats(source2) {
        var stat = dereference ? fs.stat : fs.lstat;
        if (running >= limit) {
          return setImmediate(function() {
            getStats(source2);
          });
        }
        running++;
        stat(source2, function(err, stats) {
          var item = {};
          if (err) {
            return onError(err);
          }
          item.name = source2;
          item.mode = stats.mode;
          item.mtime = stats.mtime;
          item.atime = stats.atime;
          if (stats.isDirectory()) {
            return onDir(item);
          } else if (stats.isFile()) {
            return onFile(item);
          } else if (stats.isSymbolicLink()) {
            return onLink(source2);
          }
        });
      }
      function onFile(file) {
        var target = file.name.replace(currentPath, targetPath);
        if (rename) {
          target = rename(target);
        }
        isWritable(target, function(writable) {
          if (writable) {
            return copyFile(file, target);
          }
          if (clobber) {
            rmFile(target, function() {
              copyFile(file, target);
            });
          }
          if (modified) {
            var stat = dereference ? fs.stat : fs.lstat;
            stat(target, function(err, stats) {
              if (file.mtime.getTime() > stats.mtime.getTime())
                copyFile(file, target);
              else
                return cb();
            });
          } else {
            return cb();
          }
        });
      }
      function copyFile(file, target) {
        var readStream = fs.createReadStream(file.name), writeStream = fs.createWriteStream(target, { mode: file.mode });
        readStream.on("error", onError);
        writeStream.on("error", onError);
        if (transform) {
          transform(readStream, writeStream, file);
        } else {
          writeStream.on("open", function() {
            readStream.pipe(writeStream);
          });
        }
        writeStream.once("finish", function() {
          if (modified) {
            fs.utimesSync(target, file.atime, file.mtime);
            cb();
          } else
            cb();
        });
      }
      function rmFile(file, done) {
        fs.unlink(file, function(err) {
          if (err) {
            return onError(err);
          }
          return done();
        });
      }
      function onDir(dir) {
        var target = dir.name.replace(currentPath, targetPath);
        isWritable(target, function(writable) {
          if (writable) {
            return mkDir(dir, target);
          }
          copyDir(dir.name);
        });
      }
      function mkDir(dir, target) {
        fs.mkdir(target, dir.mode, function(err) {
          if (err) {
            return onError(err);
          }
          copyDir(dir.name);
        });
      }
      function copyDir(dir) {
        fs.readdir(dir, function(err, items) {
          if (err) {
            return onError(err);
          }
          items.forEach(function(item) {
            startCopy(path.join(dir, item));
          });
          return cb();
        });
      }
      function onLink(link) {
        var target = link.replace(currentPath, targetPath);
        fs.readlink(link, function(err, resolvedPath) {
          if (err) {
            return onError(err);
          }
          checkLink(resolvedPath, target);
        });
      }
      function checkLink(resolvedPath, target) {
        if (dereference) {
          resolvedPath = path.resolve(basePath, resolvedPath);
        }
        isWritable(target, function(writable) {
          if (writable) {
            return makeLink(resolvedPath, target);
          }
          fs.readlink(target, function(err, targetDest) {
            if (err) {
              return onError(err);
            }
            if (dereference) {
              targetDest = path.resolve(basePath, targetDest);
            }
            if (targetDest === resolvedPath) {
              return cb();
            }
            return rmFile(target, function() {
              makeLink(resolvedPath, target);
            });
          });
        });
      }
      function makeLink(linkPath, target) {
        fs.symlink(linkPath, target, function(err) {
          if (err) {
            return onError(err);
          }
          return cb();
        });
      }
      function isWritable(path2, done) {
        fs.lstat(path2, function(err) {
          if (err) {
            if (err.code === "ENOENT")
              return done(true);
            return done(false);
          }
          return done(false);
        });
      }
      function onError(err) {
        if (options.stopOnError) {
          return cback(err);
        } else if (!errs && options.errs) {
          errs = fs.createWriteStream(options.errs);
        } else if (!errs) {
          errs = [];
        }
        if (typeof errs.write === "undefined") {
          errs.push(err);
        } else {
          errs.write(err.stack + "\n\n");
        }
        return cb();
      }
      function cb(skipped) {
        if (!skipped)
          running--;
        finished++;
        if (started === finished && running === 0) {
          if (cback !== void 0) {
            return errs ? cback(errs) : cback(null);
          }
        }
      }
    }
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = { sep: "/" };
    try {
      path = require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match2;
    function match2(f, partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { "this": this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports2, module2) {
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/mv/node_modules/glob/common.js
var require_common2 = __commonJS({
  "node_modules/mv/node_modules/glob/common.js"(exports2) {
    exports2.alphasort = alphasort;
    exports2.alphasorti = alphasorti;
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var path = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasorti(a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase());
    }
    function alphasort(a, b) {
      return a.localeCompare(b);
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && pattern.indexOf("/") === -1) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || Object.create(null);
      self2.statCache = options.statCache || Object.create(null);
      self2.symlinks = options.symlinks || Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = options.cwd;
        self2.changedCwd = path.resolve(options.cwd) !== cwd;
      }
      self2.root = options.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(self2.nocase ? alphasorti : alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            return !/\/$/.test(e);
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// node_modules/mv/node_modules/glob/sync.js
var require_sync = __commonJS({
  "node_modules/mv/node_modules/glob/sync.js"(exports2, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var fs = require("fs");
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common2();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = fs.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this.matches[index][e] = true;
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[this._makeAbs(e)];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = fs.lstatSync(abs);
      } catch (er) {
        return null;
      }
      var isSym = lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          this.cache[this._makeAbs(f)] = "FILE";
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this.matches[index][prefix] = true;
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = fs.lstatSync(abs);
        } catch (er) {
          return false;
        }
        if (lstat.isSymbolicLink()) {
          try {
            stat = fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c !== "DIR")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/inflight/inflight.js"(exports2, module2) {
    var wrappy = require_wrappy();
    var reqs = Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// node_modules/mv/node_modules/glob/glob.js
var require_glob = __commonJS({
  "node_modules/mv/node_modules/glob/glob.js"(exports2, module2) {
    module2.exports = glob;
    var fs = require("fs");
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common2();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      var n = this.minimatch.set.length;
      this._processing = 0;
      this.matches = new Array(n);
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      function done() {
        --self2._processing;
        if (self2._processing <= 0)
          self2._finish();
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        fs.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (this.matches[index][e])
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = this._makeAbs(e);
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      if (this.mark)
        e = this._mark(e);
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er)
          return cb();
        var isSym = lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          this.cache[this._makeAbs(f)] = "FILE";
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && !stat.isDirectory())
        return cb(null, false, stat);
      var c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c !== "DIR")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// node_modules/mv/node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/mv/node_modules/rimraf/rimraf.js"(exports2, module2) {
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
    var assert = require("assert");
    var path = require("path");
    var fs = require("fs");
    var glob = require_glob();
    var globOpts = {
      nosort: true,
      nocomment: true,
      nonegate: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    function defaults(options) {
      var methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach(function(m) {
        options[m] = options[m] || fs[m];
        m = m + "Sync";
        options[m] = options[m] || fs[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      options.disableGlob = options.disableGlob || false;
    }
    function rimraf(p, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      defaults(options);
      var busyTries = 0;
      var errState = null;
      var n = 0;
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      fs.lstat(p, function(er, stat) {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, globOpts, afterGlob);
      });
      function next(er) {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      }
      function afterGlob(er, results) {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach(function(p2) {
          rimraf_(p2, options, function CB(er2) {
            if (er2) {
              if (isWindows && (er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                var time = busyTries * 100;
                return setTimeout(function() {
                  rimraf_(p2, options, CB);
                }, time);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(function() {
                  rimraf_(p2, options, CB);
                }, timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          });
        });
      }
    }
    function rimraf_(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, function(er, st) {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, function(er2) {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      if (er)
        assert(er instanceof Error);
      options.chmod(p, 666, function(er2) {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, function(er3, stats) {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    }
    function fixWinEPERMSync(p, options, er) {
      assert(p);
      assert(options);
      if (er)
        assert(er instanceof Error);
      try {
        options.chmodSync(p, 666);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      try {
        var stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    }
    function rmdir(p, options, originalEr, cb) {
      assert(p);
      assert(options);
      if (originalEr)
        assert(originalEr instanceof Error);
      assert(typeof cb === "function");
      options.rmdir(p, function(er) {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    }
    function rmkids(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, function(er, files) {
        if (er)
          return cb(er);
        var n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        var errState;
        files.forEach(function(f) {
          rimraf(path.join(p, f), options, function(er2) {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    }
    function rimrafSync(p, options) {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      var results;
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          fs.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, globOpts);
        }
      }
      if (!results.length)
        return;
      for (var i = 0; i < results.length; i++) {
        var p = results[i];
        try {
          var st = options.lstatSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p, options, null);
          else
            options.unlinkSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p, options, er);
        }
      }
    }
    function rmdirSync(p, options, originalEr) {
      assert(p);
      assert(options);
      if (originalEr)
        assert(originalEr instanceof Error);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach(function(f) {
        rimrafSync(path.join(p, f), options);
      });
      options.rmdirSync(p, options);
    }
  }
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "node_modules/mkdirp/index.js"(exports2, module2) {
    var path = require("path");
    var fs = require("fs");
    var _0777 = parseInt("0777", 8);
    module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    function mkdirP(p, opts, f, made) {
      if (typeof opts === "function") {
        f = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      var cb = f || function() {
      };
      p = path.resolve(p);
      xfs.mkdir(p, mode, function(er) {
        if (!er) {
          made = made || p;
          return cb(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path.dirname(p) === p)
              return cb(er);
            mkdirP(path.dirname(p), opts, function(er2, made2) {
              if (er2)
                cb(er2, made2);
              else
                mkdirP(p, opts, cb, made2);
            });
            break;
          default:
            xfs.stat(p, function(er2, stat) {
              if (er2 || !stat.isDirectory())
                cb(er, made);
              else
                cb(null, made);
            });
            break;
        }
      });
    }
    mkdirP.sync = function sync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      p = path.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        switch (err0.code) {
          case "ENOENT":
            made = sync(path.dirname(p), opts, made);
            sync(p, opts, made);
            break;
          default:
            var stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0;
            }
            if (!stat.isDirectory())
              throw err0;
            break;
        }
      }
      return made;
    };
  }
});

// node_modules/mv/index.js
var require_mv = __commonJS({
  "node_modules/mv/index.js"(exports2, module2) {
    var fs = require("fs");
    var ncp = require_ncp().ncp;
    var path = require("path");
    var rimraf = require_rimraf();
    var mkdirp = require_mkdirp();
    module2.exports = mv;
    function mv(source, dest, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      var shouldMkdirp = !!options.mkdirp;
      var clobber = options.clobber !== false;
      var limit = options.limit || 16;
      if (shouldMkdirp) {
        mkdirs();
      } else {
        doRename();
      }
      function mkdirs() {
        mkdirp(path.dirname(dest), function(err) {
          if (err)
            return cb(err);
          doRename();
        });
      }
      function doRename() {
        if (clobber) {
          fs.rename(source, dest, function(err) {
            if (!err)
              return cb();
            if (err.code !== "EXDEV")
              return cb(err);
            moveFileAcrossDevice(source, dest, clobber, limit, cb);
          });
        } else {
          fs.link(source, dest, function(err) {
            if (err) {
              if (err.code === "EXDEV") {
                moveFileAcrossDevice(source, dest, clobber, limit, cb);
                return;
              }
              if (err.code === "EISDIR" || err.code === "EPERM") {
                moveDirAcrossDevice(source, dest, clobber, limit, cb);
                return;
              }
              cb(err);
              return;
            }
            fs.unlink(source, cb);
          });
        }
      }
    }
    function moveFileAcrossDevice(source, dest, clobber, limit, cb) {
      var outFlags = clobber ? "w" : "wx";
      var ins = fs.createReadStream(source);
      var outs = fs.createWriteStream(dest, { flags: outFlags });
      ins.on("error", function(err) {
        ins.destroy();
        outs.destroy();
        outs.removeListener("close", onClose);
        if (err.code === "EISDIR" || err.code === "EPERM") {
          moveDirAcrossDevice(source, dest, clobber, limit, cb);
        } else {
          cb(err);
        }
      });
      outs.on("error", function(err) {
        ins.destroy();
        outs.destroy();
        outs.removeListener("close", onClose);
        cb(err);
      });
      outs.once("close", onClose);
      ins.pipe(outs);
      function onClose() {
        fs.unlink(source, cb);
      }
    }
    function moveDirAcrossDevice(source, dest, clobber, limit, cb) {
      var options = {
        stopOnErr: true,
        clobber: false,
        limit
      };
      if (clobber) {
        rimraf(dest, { disableGlob: true }, function(err) {
          if (err)
            return cb(err);
          startNcp();
        });
      } else {
        startNcp();
      }
      function startNcp() {
        ncp(source, dest, options, function(errList) {
          if (errList)
            return cb(errList[0]);
          rimraf(source, { disableGlob: true }, cb);
        });
      }
    }
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map/lib/base64.js"(exports2) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports2.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map/lib/base64-vlq.js"(exports2) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map/lib/util.js"(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match2 = aUrl.match(urlRegexp);
      if (!match2) {
        return null;
      }
      return {
        scheme: match2[1],
        auth: match2[2],
        host: match2[3],
        port: match2[4],
        path: match2[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports2.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports2.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports2.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = function() {
      var obj = Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map/lib/array-set.js"(exports2) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports2.ArraySet = ArraySet;
  }
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map/lib/mapping-list.js"(exports2) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports2.MappingList = MappingList;
  }
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map/lib/source-map-generator.js"(exports2) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map/lib/binary-search.js"(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports2.GREATEST_LOWER_BOUND);
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map/lib/quick-sort.js"(exports2) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports2.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map/lib/source-map-consumer.js"(exports2) {
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports2.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
        var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }
        return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      });
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map/lib/source-node.js"(exports2) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports2.SourceNode = SourceNode;
  }
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map/source-map.js"(exports2) {
    exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports2.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "node_modules/buffer-from/index.js"(exports2, module2) {
    var toString = Object.prototype.toString;
    var isModern = typeof Buffer !== "undefined" && typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
    function isArrayBuffer(input) {
      return toString.call(input).slice(8, -1) === "ArrayBuffer";
    }
    function fromArrayBuffer(obj, byteOffset, length) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (length === void 0) {
        length = maxLength;
      } else {
        length >>>= 0;
        if (length > maxLength) {
          throw new RangeError("'length' is out of bounds");
        }
      }
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
    }
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    function bufferFrom(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (isArrayBuffer(value)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      return isModern ? Buffer.from(value) : new Buffer(value);
    }
    module2.exports = bufferFrom;
  }
});

// node_modules/source-map-support/source-map-support.js
var require_source_map_support = __commonJS({
  "node_modules/source-map-support/source-map-support.js"(exports2, module2) {
    var SourceMapConsumer = require_source_map().SourceMapConsumer;
    var path = require("path");
    var fs;
    try {
      fs = require("fs");
      if (!fs.existsSync || !fs.readFileSync) {
        fs = null;
      }
    } catch (err) {
    }
    var bufferFrom = require_buffer_from();
    function dynamicRequire(mod, request) {
      return mod.require(request);
    }
    var errorFormatterInstalled = false;
    var uncaughtShimInstalled = false;
    var emptyCacheBetweenOperations = false;
    var environment = "auto";
    var fileContentsCache = {};
    var sourceMapCache = {};
    var reSourceMap = /^data:application\/json[^,]+base64,/;
    var retrieveFileHandlers = [];
    var retrieveMapHandlers = [];
    function isInBrowser() {
      if (environment === "browser")
        return true;
      if (environment === "node")
        return false;
      return typeof window !== "undefined" && typeof XMLHttpRequest === "function" && !(window.require && window.module && window.process && window.process.type === "renderer");
    }
    function hasGlobalProcessEventEmitter() {
      return typeof process === "object" && process !== null && typeof process.on === "function";
    }
    function globalProcessVersion() {
      if (typeof process === "object" && process !== null) {
        return process.version;
      } else {
        return "";
      }
    }
    function globalProcessStderr() {
      if (typeof process === "object" && process !== null) {
        return process.stderr;
      }
    }
    function globalProcessExit(code) {
      if (typeof process === "object" && process !== null && typeof process.exit === "function") {
        return process.exit(code);
      }
    }
    function handlerExec(list) {
      return function(arg) {
        for (var i = 0; i < list.length; i++) {
          var ret = list[i](arg);
          if (ret) {
            return ret;
          }
        }
        return null;
      };
    }
    var retrieveFile = handlerExec(retrieveFileHandlers);
    retrieveFileHandlers.push(function(path2) {
      path2 = path2.trim();
      if (/^file:/.test(path2)) {
        path2 = path2.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
          return drive ? "" : "/";
        });
      }
      if (path2 in fileContentsCache) {
        return fileContentsCache[path2];
      }
      var contents = "";
      try {
        if (!fs) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path2, false);
          xhr.send(null);
          if (xhr.readyState === 4 && xhr.status === 200) {
            contents = xhr.responseText;
          }
        } else if (fs.existsSync(path2)) {
          contents = fs.readFileSync(path2, "utf8");
        }
      } catch (er) {
      }
      return fileContentsCache[path2] = contents;
    });
    function supportRelativeURL(file, url) {
      if (!file)
        return url;
      var dir = path.dirname(file);
      var match2 = /^\w+:\/\/[^\/]*/.exec(dir);
      var protocol = match2 ? match2[0] : "";
      var startPath = dir.slice(protocol.length);
      if (protocol && /^\/\w\:/.test(startPath)) {
        protocol += "/";
        return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, "/");
      }
      return protocol + path.resolve(dir.slice(protocol.length), url);
    }
    function retrieveSourceMapURL(source) {
      var fileData;
      if (isInBrowser()) {
        try {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", source, false);
          xhr.send(null);
          fileData = xhr.readyState === 4 ? xhr.responseText : null;
          var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
          if (sourceMapHeader) {
            return sourceMapHeader;
          }
        } catch (e) {
        }
      }
      fileData = retrieveFile(source);
      var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
      var lastMatch, match2;
      while (match2 = re.exec(fileData))
        lastMatch = match2;
      if (!lastMatch)
        return null;
      return lastMatch[1];
    }
    var retrieveSourceMap = handlerExec(retrieveMapHandlers);
    retrieveMapHandlers.push(function(source) {
      var sourceMappingURL = retrieveSourceMapURL(source);
      if (!sourceMappingURL)
        return null;
      var sourceMapData;
      if (reSourceMap.test(sourceMappingURL)) {
        var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1);
        sourceMapData = bufferFrom(rawData, "base64").toString();
        sourceMappingURL = source;
      } else {
        sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
        sourceMapData = retrieveFile(sourceMappingURL);
      }
      if (!sourceMapData) {
        return null;
      }
      return {
        url: sourceMappingURL,
        map: sourceMapData
      };
    });
    function mapSourcePosition(position) {
      var sourceMap = sourceMapCache[position.source];
      if (!sourceMap) {
        var urlAndMap = retrieveSourceMap(position.source);
        if (urlAndMap) {
          sourceMap = sourceMapCache[position.source] = {
            url: urlAndMap.url,
            map: new SourceMapConsumer(urlAndMap.map)
          };
          if (sourceMap.map.sourcesContent) {
            sourceMap.map.sources.forEach(function(source, i) {
              var contents = sourceMap.map.sourcesContent[i];
              if (contents) {
                var url = supportRelativeURL(sourceMap.url, source);
                fileContentsCache[url] = contents;
              }
            });
          }
        } else {
          sourceMap = sourceMapCache[position.source] = {
            url: null,
            map: null
          };
        }
      }
      if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor === "function") {
        var originalPosition = sourceMap.map.originalPositionFor(position);
        if (originalPosition.source !== null) {
          originalPosition.source = supportRelativeURL(sourceMap.url, originalPosition.source);
          return originalPosition;
        }
      }
      return position;
    }
    function mapEvalOrigin(origin) {
      var match2 = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
      if (match2) {
        var position = mapSourcePosition({
          source: match2[2],
          line: +match2[3],
          column: match2[4] - 1
        });
        return "eval at " + match2[1] + " (" + position.source + ":" + position.line + ":" + (position.column + 1) + ")";
      }
      match2 = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
      if (match2) {
        return "eval at " + match2[1] + " (" + mapEvalOrigin(match2[2]) + ")";
      }
      return origin;
    }
    function CallSiteToString() {
      var fileName;
      var fileLocation = "";
      if (this.isNative()) {
        fileLocation = "native";
      } else {
        fileName = this.getScriptNameOrSourceURL();
        if (!fileName && this.isEval()) {
          fileLocation = this.getEvalOrigin();
          fileLocation += ", ";
        }
        if (fileName) {
          fileLocation += fileName;
        } else {
          fileLocation += "<anonymous>";
        }
        var lineNumber = this.getLineNumber();
        if (lineNumber != null) {
          fileLocation += ":" + lineNumber;
          var columnNumber = this.getColumnNumber();
          if (columnNumber) {
            fileLocation += ":" + columnNumber;
          }
        }
      }
      var line = "";
      var functionName = this.getFunctionName();
      var addSuffix = true;
      var isConstructor = this.isConstructor();
      var isMethodCall = !(this.isToplevel() || isConstructor);
      if (isMethodCall) {
        var typeName = this.getTypeName();
        if (typeName === "[object Object]") {
          typeName = "null";
        }
        var methodName = this.getMethodName();
        if (functionName) {
          if (typeName && functionName.indexOf(typeName) != 0) {
            line += typeName + ".";
          }
          line += functionName;
          if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
            line += " [as " + methodName + "]";
          }
        } else {
          line += typeName + "." + (methodName || "<anonymous>");
        }
      } else if (isConstructor) {
        line += "new " + (functionName || "<anonymous>");
      } else if (functionName) {
        line += functionName;
      } else {
        line += fileLocation;
        addSuffix = false;
      }
      if (addSuffix) {
        line += " (" + fileLocation + ")";
      }
      return line;
    }
    function cloneCallSite(frame) {
      var object = {};
      Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
        object[name] = /^(?:is|get)/.test(name) ? function() {
          return frame[name].call(frame);
        } : frame[name];
      });
      object.toString = CallSiteToString;
      return object;
    }
    function wrapCallSite(frame, state) {
      if (state === void 0) {
        state = { nextPosition: null, curPosition: null };
      }
      if (frame.isNative()) {
        state.curPosition = null;
        return frame;
      }
      var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
      if (source) {
        var line = frame.getLineNumber();
        var column = frame.getColumnNumber() - 1;
        var noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
        var headerLength = noHeader.test(globalProcessVersion()) ? 0 : 62;
        if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
          column -= headerLength;
        }
        var position = mapSourcePosition({
          source,
          line,
          column
        });
        state.curPosition = position;
        frame = cloneCallSite(frame);
        var originalFunctionName = frame.getFunctionName;
        frame.getFunctionName = function() {
          if (state.nextPosition == null) {
            return originalFunctionName();
          }
          return state.nextPosition.name || originalFunctionName();
        };
        frame.getFileName = function() {
          return position.source;
        };
        frame.getLineNumber = function() {
          return position.line;
        };
        frame.getColumnNumber = function() {
          return position.column + 1;
        };
        frame.getScriptNameOrSourceURL = function() {
          return position.source;
        };
        return frame;
      }
      var origin = frame.isEval() && frame.getEvalOrigin();
      if (origin) {
        origin = mapEvalOrigin(origin);
        frame = cloneCallSite(frame);
        frame.getEvalOrigin = function() {
          return origin;
        };
        return frame;
      }
      return frame;
    }
    function prepareStackTrace(error2, stack) {
      if (emptyCacheBetweenOperations) {
        fileContentsCache = {};
        sourceMapCache = {};
      }
      var name = error2.name || "Error";
      var message = error2.message || "";
      var errorString = name + ": " + message;
      var state = { nextPosition: null, curPosition: null };
      var processedStack = [];
      for (var i = stack.length - 1; i >= 0; i--) {
        processedStack.push("\n    at " + wrapCallSite(stack[i], state));
        state.nextPosition = state.curPosition;
      }
      state.curPosition = state.nextPosition = null;
      return errorString + processedStack.reverse().join("");
    }
    function getErrorSource(error2) {
      var match2 = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error2.stack);
      if (match2) {
        var source = match2[1];
        var line = +match2[2];
        var column = +match2[3];
        var contents = fileContentsCache[source];
        if (!contents && fs && fs.existsSync(source)) {
          try {
            contents = fs.readFileSync(source, "utf8");
          } catch (er) {
            contents = "";
          }
        }
        if (contents) {
          var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
          if (code) {
            return source + ":" + line + "\n" + code + "\n" + new Array(column).join(" ") + "^";
          }
        }
      }
      return null;
    }
    function printErrorAndExit(error2) {
      var source = getErrorSource(error2);
      var stderr = globalProcessStderr();
      if (stderr && stderr._handle && stderr._handle.setBlocking) {
        stderr._handle.setBlocking(true);
      }
      if (source) {
        console.error();
        console.error(source);
      }
      console.error(error2.stack);
      globalProcessExit(1);
    }
    function shimEmitUncaughtException() {
      var origEmit = process.emit;
      process.emit = function(type) {
        if (type === "uncaughtException") {
          var hasStack = arguments[1] && arguments[1].stack;
          var hasListeners = this.listeners(type).length > 0;
          if (hasStack && !hasListeners) {
            return printErrorAndExit(arguments[1]);
          }
        }
        return origEmit.apply(this, arguments);
      };
    }
    var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);
    var originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);
    exports2.wrapCallSite = wrapCallSite;
    exports2.getErrorSource = getErrorSource;
    exports2.mapSourcePosition = mapSourcePosition;
    exports2.retrieveSourceMap = retrieveSourceMap;
    exports2.install = function(options) {
      options = options || {};
      if (options.environment) {
        environment = options.environment;
        if (["node", "browser", "auto"].indexOf(environment) === -1) {
          throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
        }
      }
      if (options.retrieveFile) {
        if (options.overrideRetrieveFile) {
          retrieveFileHandlers.length = 0;
        }
        retrieveFileHandlers.unshift(options.retrieveFile);
      }
      if (options.retrieveSourceMap) {
        if (options.overrideRetrieveSourceMap) {
          retrieveMapHandlers.length = 0;
        }
        retrieveMapHandlers.unshift(options.retrieveSourceMap);
      }
      if (options.hookRequire && !isInBrowser()) {
        var Module = dynamicRequire(module2, "module");
        var $compile = Module.prototype._compile;
        if (!$compile.__sourceMapSupport) {
          Module.prototype._compile = function(content, filename) {
            fileContentsCache[filename] = content;
            sourceMapCache[filename] = void 0;
            return $compile.call(this, content, filename);
          };
          Module.prototype._compile.__sourceMapSupport = true;
        }
      }
      if (!emptyCacheBetweenOperations) {
        emptyCacheBetweenOperations = "emptyCacheBetweenOperations" in options ? options.emptyCacheBetweenOperations : false;
      }
      if (!errorFormatterInstalled) {
        errorFormatterInstalled = true;
        Error.prepareStackTrace = prepareStackTrace;
      }
      if (!uncaughtShimInstalled) {
        var installHandler = "handleUncaughtExceptions" in options ? options.handleUncaughtExceptions : true;
        try {
          var worker_threads = dynamicRequire(module2, "worker_threads");
          if (worker_threads.isMainThread === false) {
            installHandler = false;
          }
        } catch (e) {
        }
        if (installHandler && hasGlobalProcessEventEmitter()) {
          uncaughtShimInstalled = true;
          shimEmitUncaughtException();
        }
      }
    };
    exports2.resetRetrieveHandlers = function() {
      retrieveFileHandlers.length = 0;
      retrieveMapHandlers.length = 0;
      retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);
      retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);
      retrieveSourceMap = handlerExec(retrieveMapHandlers);
      retrieveFile = handlerExec(retrieveFileHandlers);
    };
  }
});

// node_modules/bunyan/lib/bunyan.js
var require_bunyan = __commonJS({
  "node_modules/bunyan/lib/bunyan.js"(exports2, module2) {
    var VERSION = "1.8.15";
    var LOG_VERSION = 0;
    var xxx = function xxx2(s) {
      var args = ["XXX: " + s].concat(Array.prototype.slice.call(arguments, 1));
      console.error.apply(this, args);
    };
    var xxx = function xxx2() {
    };
    var runtimeEnv;
    if (typeof process !== "undefined" && process.versions) {
      if (process.versions.nw) {
        runtimeEnv = "nw";
      } else if (process.versions.node) {
        runtimeEnv = "node";
      }
    }
    if (!runtimeEnv && typeof window !== "undefined" && window.window === window) {
      runtimeEnv = "browser";
    }
    if (!runtimeEnv) {
      throw new Error("unknown runtime environment");
    }
    var os;
    var fs;
    var dtrace;
    if (runtimeEnv === "browser") {
      os = {
        hostname: function() {
          return window.location.host;
        }
      };
      fs = {};
      dtrace = null;
    } else {
      os = require("os");
      fs = require("fs");
      try {
        dtrace = require_dtrace_provider();
      } catch (e) {
        dtrace = null;
      }
    }
    var util = require("util");
    var assert = require("assert");
    var EventEmitter2 = require("events").EventEmitter;
    var stream = require("stream");
    try {
      safeJsonStringify = require_safe_json_stringify();
    } catch (e) {
      safeJsonStringify = null;
    }
    var safeJsonStringify;
    if (process.env.BUNYAN_TEST_NO_SAFE_JSON_STRINGIFY) {
      safeJsonStringify = null;
    }
    try {
      mv = require_mv();
    } catch (e) {
      mv = null;
    }
    var mv;
    try {
      sourceMapSupport = require_source_map_support();
    } catch (_) {
      sourceMapSupport = null;
    }
    var sourceMapSupport;
    function objCopy(obj) {
      if (obj == null) {
        return obj;
      } else if (Array.isArray(obj)) {
        return obj.slice();
      } else if (typeof obj === "object") {
        var copy = {};
        Object.keys(obj).forEach(function(k) {
          copy[k] = obj[k];
        });
        return copy;
      } else {
        return obj;
      }
    }
    var format2 = util.format;
    if (!format2) {
      inspect = util.inspect;
      formatRegExp = /%[sdj%]/g;
      format2 = function format3(f) {
        if (typeof f !== "string") {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (i >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              return fastAndSafeJsonStringify(args[i++]);
            case "%%":
              return "%";
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (x === null || typeof x !== "object") {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
    }
    var inspect;
    var formatRegExp;
    function getCaller3Info() {
      if (this === void 0) {
        return;
      }
      var obj = {};
      var saveLimit = Error.stackTraceLimit;
      var savePrepare = Error.prepareStackTrace;
      Error.stackTraceLimit = 3;
      Error.prepareStackTrace = function(_, stack) {
        var caller = stack[2];
        if (sourceMapSupport) {
          caller = sourceMapSupport.wrapCallSite(caller);
        }
        obj.file = caller.getFileName();
        obj.line = caller.getLineNumber();
        var func = caller.getFunctionName();
        if (func)
          obj.func = func;
      };
      Error.captureStackTrace(this, getCaller3Info);
      this.stack;
      Error.stackTraceLimit = saveLimit;
      Error.prepareStackTrace = savePrepare;
      return obj;
    }
    function _indent(s, indent) {
      if (!indent)
        indent = "    ";
      var lines = s.split(/\r?\n/g);
      return indent + lines.join("\n" + indent);
    }
    function _warn(msg, dedupKey) {
      assert.ok(msg);
      if (dedupKey) {
        if (_warned[dedupKey]) {
          return;
        }
        _warned[dedupKey] = true;
      }
      process.stderr.write(msg + "\n");
    }
    function _haveWarned(dedupKey) {
      return _warned[dedupKey];
    }
    var _warned = {};
    function ConsoleRawStream() {
    }
    ConsoleRawStream.prototype.write = function(rec) {
      if (rec.level < INFO) {
        console.log(rec);
      } else if (rec.level < WARN) {
        console.info(rec);
      } else if (rec.level < ERROR) {
        console.warn(rec);
      } else {
        console.error(rec);
      }
    };
    var TRACE = 10;
    var DEBUG = 20;
    var INFO = 30;
    var WARN = 40;
    var ERROR = 50;
    var FATAL = 60;
    var levelFromName = {
      "trace": TRACE,
      "debug": DEBUG,
      "info": INFO,
      "warn": WARN,
      "error": ERROR,
      "fatal": FATAL
    };
    var nameFromLevel = {};
    Object.keys(levelFromName).forEach(function(name) {
      nameFromLevel[levelFromName[name]] = name;
    });
    var dtp = void 0;
    var probes = dtrace && {};
    function resolveLevel(nameOrNum) {
      var level;
      var type = typeof nameOrNum;
      if (type === "string") {
        level = levelFromName[nameOrNum.toLowerCase()];
        if (!level) {
          throw new Error(format2('unknown level name: "%s"', nameOrNum));
        }
      } else if (type !== "number") {
        throw new TypeError(format2("cannot resolve level: invalid arg (%s):", type, nameOrNum));
      } else if (nameOrNum < 0 || Math.floor(nameOrNum) !== nameOrNum) {
        throw new TypeError(format2("level is not a positive integer: %s", nameOrNum));
      } else {
        level = nameOrNum;
      }
      return level;
    }
    function isWritable(obj) {
      if (obj instanceof stream.Writable) {
        return true;
      }
      return typeof obj.write === "function";
    }
    function Logger(options, _childOptions, _childSimple) {
      xxx("Logger start:", options);
      if (!(this instanceof Logger)) {
        return new Logger(options, _childOptions);
      }
      var parent;
      if (_childOptions !== void 0) {
        parent = options;
        options = _childOptions;
        if (!(parent instanceof Logger)) {
          throw new TypeError("invalid Logger creation: do not pass a second arg");
        }
      }
      if (!options) {
        throw new TypeError("options (object) is required");
      }
      if (!parent) {
        if (!options.name) {
          throw new TypeError("options.name (string) is required");
        }
      } else {
        if (options.name) {
          throw new TypeError("invalid options.name: child cannot set logger name");
        }
      }
      if (options.stream && options.streams) {
        throw new TypeError('cannot mix "streams" and "stream" options');
      }
      if (options.streams && !Array.isArray(options.streams)) {
        throw new TypeError("invalid options.streams: must be an array");
      }
      if (options.serializers && (typeof options.serializers !== "object" || Array.isArray(options.serializers))) {
        throw new TypeError("invalid options.serializers: must be an object");
      }
      EventEmitter2.call(this);
      if (parent && _childSimple) {
        this._isSimpleChild = true;
        this._level = parent._level;
        this.streams = parent.streams;
        this.serializers = parent.serializers;
        this.src = parent.src;
        var fields = this.fields = {};
        var parentFieldNames = Object.keys(parent.fields);
        for (var i = 0; i < parentFieldNames.length; i++) {
          var name = parentFieldNames[i];
          fields[name] = parent.fields[name];
        }
        var names = Object.keys(options);
        for (var i = 0; i < names.length; i++) {
          var name = names[i];
          fields[name] = options[name];
        }
        return;
      }
      var self2 = this;
      if (parent) {
        this._level = parent._level;
        this.streams = [];
        for (var i = 0; i < parent.streams.length; i++) {
          var s = objCopy(parent.streams[i]);
          s.closeOnExit = false;
          this.streams.push(s);
        }
        this.serializers = objCopy(parent.serializers);
        this.src = parent.src;
        this.fields = objCopy(parent.fields);
        if (options.level) {
          this.level(options.level);
        }
      } else {
        this._level = Number.POSITIVE_INFINITY;
        this.streams = [];
        this.serializers = null;
        this.src = false;
        this.fields = {};
      }
      if (!dtp && dtrace) {
        dtp = dtrace.createDTraceProvider("bunyan");
        for (var level in levelFromName) {
          var probe;
          probes[levelFromName[level]] = probe = dtp.addProbe("log-" + level, "char *");
          probe.dtp = dtp;
        }
        dtp.enable();
      }
      if (options.stream) {
        self2.addStream({
          type: "stream",
          stream: options.stream,
          closeOnExit: false,
          level: options.level
        });
      } else if (options.streams) {
        options.streams.forEach(function(s2) {
          self2.addStream(s2, options.level);
        });
      } else if (parent && options.level) {
        this.level(options.level);
      } else if (!parent) {
        if (runtimeEnv === "browser") {
          self2.addStream({
            type: "raw",
            stream: new ConsoleRawStream(),
            closeOnExit: false,
            level: options.level
          });
        } else {
          self2.addStream({
            type: "stream",
            stream: process.stdout,
            closeOnExit: false,
            level: options.level
          });
        }
      }
      if (options.serializers) {
        self2.addSerializers(options.serializers);
      }
      if (options.src) {
        this.src = true;
      }
      xxx("Logger: ", self2);
      var fields = objCopy(options);
      delete fields.stream;
      delete fields.level;
      delete fields.streams;
      delete fields.serializers;
      delete fields.src;
      if (this.serializers) {
        this._applySerializers(fields);
      }
      if (!fields.hostname && !self2.fields.hostname) {
        fields.hostname = os.hostname();
      }
      if (!fields.pid) {
        fields.pid = process.pid;
      }
      Object.keys(fields).forEach(function(k) {
        self2.fields[k] = fields[k];
      });
    }
    util.inherits(Logger, EventEmitter2);
    Logger.prototype.addStream = function addStream(s, defaultLevel) {
      var self2 = this;
      if (defaultLevel === null || defaultLevel === void 0) {
        defaultLevel = INFO;
      }
      s = objCopy(s);
      if (!s.type) {
        if (s.stream) {
          s.type = "stream";
        } else if (s.path) {
          s.type = "file";
        }
      }
      s.raw = s.type === "raw";
      if (s.level !== void 0) {
        s.level = resolveLevel(s.level);
      } else {
        s.level = resolveLevel(defaultLevel);
      }
      if (s.level < self2._level) {
        self2._level = s.level;
      }
      switch (s.type) {
        case "stream":
          assert.ok(isWritable(s.stream), '"stream" stream is not writable: ' + util.inspect(s.stream));
          if (!s.closeOnExit) {
            s.closeOnExit = false;
          }
          break;
        case "file":
          if (s.reemitErrorEvents === void 0) {
            s.reemitErrorEvents = true;
          }
          if (!s.stream) {
            s.stream = fs.createWriteStream(s.path, { flags: "a", encoding: "utf8" });
            if (!s.closeOnExit) {
              s.closeOnExit = true;
            }
          } else {
            if (!s.closeOnExit) {
              s.closeOnExit = false;
            }
          }
          break;
        case "rotating-file":
          assert.ok(!s.stream, '"rotating-file" stream should not give a "stream"');
          assert.ok(s.path);
          assert.ok(mv, '"rotating-file" stream type is not supported: missing "mv" module');
          s.stream = new RotatingFileStream2(s);
          if (!s.closeOnExit) {
            s.closeOnExit = true;
          }
          break;
        case "raw":
          if (!s.closeOnExit) {
            s.closeOnExit = false;
          }
          break;
        default:
          throw new TypeError('unknown stream type "' + s.type + '"');
      }
      if (s.reemitErrorEvents && typeof s.stream.on === "function") {
        s.stream.on("error", function onStreamError(err) {
          self2.emit("error", err, s);
        });
      }
      self2.streams.push(s);
      delete self2.haveNonRawStreams;
    };
    Logger.prototype.addSerializers = function addSerializers(serializers) {
      var self2 = this;
      if (!self2.serializers) {
        self2.serializers = {};
      }
      Object.keys(serializers).forEach(function(field) {
        var serializer = serializers[field];
        if (typeof serializer !== "function") {
          throw new TypeError(format2('invalid serializer for "%s" field: must be a function', field));
        } else {
          self2.serializers[field] = serializer;
        }
      });
    };
    Logger.prototype.child = function(options, simple) {
      return new this.constructor(this, options || {}, simple);
    };
    Logger.prototype.reopenFileStreams = function() {
      var self2 = this;
      self2.streams.forEach(function(s) {
        if (s.type === "file") {
          if (s.stream) {
            s.stream.end();
            s.stream.destroySoon();
            delete s.stream;
          }
          s.stream = fs.createWriteStream(s.path, { flags: "a", encoding: "utf8" });
          s.stream.on("error", function(err) {
            self2.emit("error", err, s);
          });
        }
      });
    };
    Logger.prototype.level = function level(value) {
      if (value === void 0) {
        return this._level;
      }
      var newLevel = resolveLevel(value);
      var len = this.streams.length;
      for (var i = 0; i < len; i++) {
        this.streams[i].level = newLevel;
      }
      this._level = newLevel;
    };
    Logger.prototype.levels = function levels(name, value) {
      if (name === void 0) {
        assert.equal(value, void 0);
        return this.streams.map(function(s2) {
          return s2.level;
        });
      }
      var stream2;
      if (typeof name === "number") {
        stream2 = this.streams[name];
        if (stream2 === void 0) {
          throw new Error("invalid stream index: " + name);
        }
      } else {
        var len = this.streams.length;
        for (var i = 0; i < len; i++) {
          var s = this.streams[i];
          if (s.name === name) {
            stream2 = s;
            break;
          }
        }
        if (!stream2) {
          throw new Error(format2('no stream with name "%s"', name));
        }
      }
      if (value === void 0) {
        return stream2.level;
      } else {
        var newLevel = resolveLevel(value);
        stream2.level = newLevel;
        if (newLevel < this._level) {
          this._level = newLevel;
        }
      }
    };
    Logger.prototype._applySerializers = function(fields, excludeFields) {
      var self2 = this;
      xxx("_applySerializers: excludeFields", excludeFields);
      Object.keys(this.serializers).forEach(function(name) {
        if (fields[name] === void 0 || excludeFields && excludeFields[name]) {
          return;
        }
        xxx('_applySerializers; apply to "%s" key', name);
        try {
          fields[name] = self2.serializers[name](fields[name]);
        } catch (err) {
          _warn(format2('bunyan: ERROR: Exception thrown from the "%s" Bunyan serializer. This should never happen. This is a bug in that serializer function.\n%s', name, err.stack || err));
          fields[name] = format2('(Error in Bunyan log "%s" serializer broke field. See stderr for details.)', name);
        }
      });
    };
    Logger.prototype._emit = function(rec, noemit) {
      var i;
      if (this.haveNonRawStreams === void 0) {
        this.haveNonRawStreams = false;
        for (i = 0; i < this.streams.length; i++) {
          if (!this.streams[i].raw) {
            this.haveNonRawStreams = true;
            break;
          }
        }
      }
      var str;
      if (noemit || this.haveNonRawStreams) {
        str = fastAndSafeJsonStringify(rec) + os.EOL;
      }
      if (noemit)
        return str;
      var level = rec.level;
      for (i = 0; i < this.streams.length; i++) {
        var s = this.streams[i];
        if (s.level <= level) {
          xxx('writing log rec "%s" to "%s" stream (%d <= %d): %j', rec.msg, s.type, s.level, level, rec);
          s.stream.write(s.raw ? rec : str);
        }
      }
      ;
      return str;
    };
    function mkRecord(log2, minLevel, args) {
      var excludeFields, fields, msgArgs;
      if (args[0] instanceof Error) {
        fields = {
          err: log2.serializers && log2.serializers.err ? log2.serializers.err(args[0]) : Logger.stdSerializers.err(args[0])
        };
        excludeFields = { err: true };
        if (args.length === 1) {
          msgArgs = [fields.err.message];
        } else {
          msgArgs = args.slice(1);
        }
      } else if (typeof args[0] !== "object" || Array.isArray(args[0])) {
        fields = null;
        msgArgs = args.slice();
      } else if (Buffer.isBuffer(args[0])) {
        fields = null;
        msgArgs = args.slice();
        msgArgs[0] = util.inspect(msgArgs[0]);
      } else {
        fields = args[0];
        if (fields && args.length === 1 && fields.err && fields.err instanceof Error) {
          msgArgs = [fields.err.message];
        } else {
          msgArgs = args.slice(1);
        }
      }
      var rec = objCopy(log2.fields);
      var level = rec.level = minLevel;
      var recFields = fields ? objCopy(fields) : null;
      if (recFields) {
        if (log2.serializers) {
          log2._applySerializers(recFields, excludeFields);
        }
        Object.keys(recFields).forEach(function(k) {
          rec[k] = recFields[k];
        });
      }
      rec.msg = format2.apply(log2, msgArgs);
      if (!rec.time) {
        rec.time = new Date();
      }
      if (log2.src && !rec.src) {
        rec.src = getCaller3Info();
      }
      rec.v = LOG_VERSION;
      return rec;
    }
    function mkProbeArgs(str, log2, minLevel, msgArgs) {
      return [str || log2._emit(mkRecord(log2, minLevel, msgArgs), true)];
    }
    function mkLogEmitter(minLevel) {
      return function() {
        var log2 = this;
        var str = null;
        var rec = null;
        if (!this._emit) {
          var dedupKey = "unbound";
          if (!_haveWarned[dedupKey]) {
            var caller = getCaller3Info();
            _warn(format2("bunyan usage error: %s:%s: attempt to log with an unbound log method: `this` is: %s", caller.file, caller.line, util.inspect(this)), dedupKey);
          }
          return;
        } else if (arguments.length === 0) {
          return this._level <= minLevel;
        }
        var msgArgs = new Array(arguments.length);
        for (var i = 0; i < msgArgs.length; ++i) {
          msgArgs[i] = arguments[i];
        }
        if (this._level <= minLevel) {
          rec = mkRecord(log2, minLevel, msgArgs);
          str = this._emit(rec);
        }
        if (probes) {
          probes[minLevel].fire(mkProbeArgs, str, log2, minLevel, msgArgs);
        }
      };
    }
    Logger.prototype.trace = mkLogEmitter(TRACE);
    Logger.prototype.debug = mkLogEmitter(DEBUG);
    Logger.prototype.info = mkLogEmitter(INFO);
    Logger.prototype.warn = mkLogEmitter(WARN);
    Logger.prototype.error = mkLogEmitter(ERROR);
    Logger.prototype.fatal = mkLogEmitter(FATAL);
    Logger.stdSerializers = {};
    Logger.stdSerializers.req = function(req) {
      if (!req || !req.connection)
        return req;
      return {
        method: req.method,
        url: req.originalUrl || req.url,
        headers: req.headers,
        remoteAddress: req.connection.remoteAddress,
        remotePort: req.connection.remotePort
      };
    };
    Logger.stdSerializers.res = function(res) {
      if (!res || !res.statusCode)
        return res;
      return {
        statusCode: res.statusCode,
        header: res._header
      };
    };
    function getFullErrorStack(ex) {
      var ret = ex.stack || ex.toString();
      if (ex.cause && typeof ex.cause === "function") {
        var cex = ex.cause();
        if (cex) {
          ret += "\nCaused by: " + getFullErrorStack(cex);
        }
      }
      return ret;
    }
    var errSerializer = Logger.stdSerializers.err = function(err) {
      if (!err || !err.stack)
        return err;
      var obj = {
        message: err.message,
        name: err.name,
        stack: getFullErrorStack(err),
        code: err.code,
        signal: err.signal
      };
      return obj;
    };
    function safeCyclesSet() {
      var seen = /* @__PURE__ */ new Set();
      return function(key, val) {
        if (!val || typeof val !== "object") {
          return val;
        }
        if (seen.has(val)) {
          return "[Circular]";
        }
        seen.add(val);
        return val;
      };
    }
    function safeCyclesArray() {
      var seen = [];
      return function(key, val) {
        if (!val || typeof val !== "object") {
          return val;
        }
        if (seen.indexOf(val) !== -1) {
          return "[Circular]";
        }
        seen.push(val);
        return val;
      };
    }
    var safeCycles = typeof Set !== "undefined" ? safeCyclesSet : safeCyclesArray;
    function fastAndSafeJsonStringify(rec) {
      try {
        return JSON.stringify(rec);
      } catch (ex) {
        try {
          return JSON.stringify(rec, safeCycles());
        } catch (e) {
          if (safeJsonStringify) {
            return safeJsonStringify(rec);
          } else {
            var dedupKey = e.stack.split(/\n/g, 3).join("\n");
            _warn('bunyan: ERROR: Exception in `JSON.stringify(rec)`. You can install the "safe-json-stringify" module to have Bunyan fallback to safer stringification. Record:\n' + _indent(format2("%s\n%s", util.inspect(rec), e.stack)), dedupKey);
            return format2("(Exception in JSON.stringify(rec): %j. See stderr for details.)", e.message);
          }
        }
      }
    }
    var RotatingFileStream2 = null;
    if (mv) {
      RotatingFileStream2 = function RotatingFileStream3(options) {
        this.path = options.path;
        this.count = options.count == null ? 10 : options.count;
        assert.equal(typeof this.count, "number", format2('rotating-file stream "count" is not a number: %j (%s) in %j', this.count, typeof this.count, this));
        assert.ok(this.count >= 0, format2('rotating-file stream "count" is not >= 0: %j in %j', this.count, this));
        if (options.period) {
          var period = {
            "hourly": "1h",
            "daily": "1d",
            "weekly": "1w",
            "monthly": "1m",
            "yearly": "1y"
          }[options.period] || options.period;
          var m = /^([1-9][0-9]*)([hdwmy]|ms)$/.exec(period);
          if (!m) {
            throw new Error(format2('invalid period: "%s"', options.period));
          }
          this.periodNum = Number(m[1]);
          this.periodScope = m[2];
        } else {
          this.periodNum = 1;
          this.periodScope = "d";
        }
        var lastModified = null;
        try {
          var fileInfo = fs.statSync(this.path);
          lastModified = fileInfo.mtime.getTime();
        } catch (err) {
        }
        var rotateAfterOpen = false;
        if (lastModified) {
          var lastRotTime = this._calcRotTime(0);
          if (lastModified < lastRotTime) {
            rotateAfterOpen = true;
          }
        }
        this.stream = fs.createWriteStream(this.path, { flags: "a", encoding: "utf8" });
        this.rotQueue = [];
        this.rotating = false;
        if (rotateAfterOpen) {
          this._debug("rotateAfterOpen -> call rotate()");
          this.rotate();
        } else {
          this._setupNextRot();
        }
      };
      util.inherits(RotatingFileStream2, EventEmitter2);
      RotatingFileStream2.prototype._debug = function() {
        if (false) {
          if (arguments.length === 0) {
            return true;
          }
          var args = Array.prototype.slice.call(arguments);
          args[0] = "[" + new Date().toISOString() + ", " + this.path + "] " + args[0];
          console.log.apply(this, args);
        } else {
          return false;
        }
      };
      RotatingFileStream2.prototype._setupNextRot = function() {
        this.rotAt = this._calcRotTime(1);
        this._setRotationTimer();
      };
      RotatingFileStream2.prototype._setRotationTimer = function() {
        var self2 = this;
        var delay = this.rotAt - Date.now();
        var TIMEOUT_MAX = 2147483647;
        if (delay > TIMEOUT_MAX) {
          delay = TIMEOUT_MAX;
        }
        this.timeout = setTimeout(function() {
          self2._debug("_setRotationTimer timeout -> call rotate()");
          self2.rotate();
        }, delay);
        if (typeof this.timeout.unref === "function") {
          this.timeout.unref();
        }
      };
      RotatingFileStream2.prototype._calcRotTime = function _calcRotTime(periodOffset) {
        this._debug("_calcRotTime: %s%s", this.periodNum, this.periodScope);
        var d = new Date();
        this._debug("  now local: %s", d);
        this._debug("    now utc: %s", d.toISOString());
        var rotAt;
        switch (this.periodScope) {
          case "ms":
            if (this.rotAt) {
              rotAt = this.rotAt + this.periodNum * periodOffset;
            } else {
              rotAt = Date.now() + this.periodNum * periodOffset;
            }
            break;
          case "h":
            if (this.rotAt) {
              rotAt = this.rotAt + this.periodNum * 60 * 60 * 1e3 * periodOffset;
            } else {
              rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours() + periodOffset);
            }
            break;
          case "d":
            if (this.rotAt) {
              rotAt = this.rotAt + this.periodNum * 24 * 60 * 60 * 1e3 * periodOffset;
            } else {
              rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate() + periodOffset);
            }
            break;
          case "w":
            if (this.rotAt) {
              rotAt = this.rotAt + this.periodNum * 7 * 24 * 60 * 60 * 1e3 * periodOffset;
            } else {
              var dayOffset = 7 - d.getUTCDay();
              if (periodOffset < 1) {
                dayOffset = -d.getUTCDay();
              }
              if (periodOffset > 1 || periodOffset < -1) {
                dayOffset += 7 * periodOffset;
              }
              rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate() + dayOffset);
            }
            break;
          case "m":
            if (this.rotAt) {
              rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth() + this.periodNum * periodOffset, 1);
            } else {
              rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth() + periodOffset, 1);
            }
            break;
          case "y":
            if (this.rotAt) {
              rotAt = Date.UTC(d.getUTCFullYear() + this.periodNum * periodOffset, 0, 1);
            } else {
              rotAt = Date.UTC(d.getUTCFullYear() + periodOffset, 0, 1);
            }
            break;
          default:
            assert.fail(format2('invalid period scope: "%s"', this.periodScope));
        }
        if (this._debug()) {
          this._debug("  **rotAt**: %s (utc: %s)", rotAt, new Date(rotAt).toUTCString());
          var now = Date.now();
          this._debug("        now: %s (%sms == %smin == %sh to go)", now, rotAt - now, (rotAt - now) / 1e3 / 60, (rotAt - now) / 1e3 / 60 / 60);
        }
        return rotAt;
      };
      RotatingFileStream2.prototype.rotate = function rotate() {
        var self2 = this;
        if (self2.rotAt && self2.rotAt > Date.now()) {
          return self2._setRotationTimer();
        }
        this._debug("rotate");
        if (self2.rotating) {
          throw new TypeError("cannot start a rotation when already rotating");
        }
        self2.rotating = true;
        self2.stream.end();
        function del() {
          var toDel = self2.path + "." + String(n - 1);
          if (n === 0) {
            toDel = self2.path;
          }
          n -= 1;
          self2._debug("  rm %s", toDel);
          fs.unlink(toDel, function(delErr) {
            moves();
          });
        }
        function moves() {
          if (self2.count === 0 || n < 0) {
            return finish();
          }
          var before = self2.path;
          var after = self2.path + "." + String(n);
          if (n > 0) {
            before += "." + String(n - 1);
          }
          n -= 1;
          fs.exists(before, function(exists) {
            if (!exists) {
              moves();
            } else {
              self2._debug("  mv %s %s", before, after);
              mv(before, after, function(mvErr) {
                if (mvErr) {
                  self2.emit("error", mvErr);
                  finish();
                } else {
                  moves();
                }
              });
            }
          });
        }
        function finish() {
          self2._debug("  open %s", self2.path);
          self2.stream = fs.createWriteStream(self2.path, { flags: "a", encoding: "utf8" });
          var q = self2.rotQueue, len = q.length;
          for (var i = 0; i < len; i++) {
            self2.stream.write(q[i]);
          }
          self2.rotQueue = [];
          self2.rotating = false;
          self2.emit("drain");
          self2._setupNextRot();
        }
        var n = this.count;
        del();
      };
      RotatingFileStream2.prototype.write = function write(s) {
        if (this.rotating) {
          this.rotQueue.push(s);
          return false;
        } else {
          return this.stream.write(s);
        }
      };
      RotatingFileStream2.prototype.end = function end(s) {
        this.stream.end();
      };
      RotatingFileStream2.prototype.destroy = function destroy(s) {
        this.stream.destroy();
      };
      RotatingFileStream2.prototype.destroySoon = function destroySoon(s) {
        this.stream.destroySoon();
      };
    }
    function RingBuffer(options) {
      this.limit = options && options.limit ? options.limit : 100;
      this.writable = true;
      this.records = [];
      EventEmitter2.call(this);
    }
    util.inherits(RingBuffer, EventEmitter2);
    RingBuffer.prototype.write = function(record) {
      if (!this.writable)
        throw new Error("RingBuffer has been ended already");
      this.records.push(record);
      if (this.records.length > this.limit)
        this.records.shift();
      return true;
    };
    RingBuffer.prototype.end = function() {
      if (arguments.length > 0)
        this.write.apply(this, Array.prototype.slice.call(arguments));
      this.writable = false;
    };
    RingBuffer.prototype.destroy = function() {
      this.writable = false;
      this.emit("close");
    };
    RingBuffer.prototype.destroySoon = function() {
      this.destroy();
    };
    module2.exports = Logger;
    module2.exports.TRACE = TRACE;
    module2.exports.DEBUG = DEBUG;
    module2.exports.INFO = INFO;
    module2.exports.WARN = WARN;
    module2.exports.ERROR = ERROR;
    module2.exports.FATAL = FATAL;
    module2.exports.resolveLevel = resolveLevel;
    module2.exports.levelFromName = levelFromName;
    module2.exports.nameFromLevel = nameFromLevel;
    module2.exports.VERSION = VERSION;
    module2.exports.LOG_VERSION = LOG_VERSION;
    module2.exports.createLogger = function createLogger(options) {
      return new Logger(options);
    };
    module2.exports.RingBuffer = RingBuffer;
    module2.exports.RotatingFileStream = RotatingFileStream2;
    module2.exports.safeCycles = safeCycles;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/async/dist/async.js
var require_async2 = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/async/dist/async.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.async = {});
    })(exports2, function(exports3) {
      "use strict";
      function apply(fn, ...args) {
        return (...callArgs) => fn(...args, ...callArgs);
      }
      function initialParams(fn) {
        return function(...args) {
          var callback = args.pop();
          return fn.call(this, args, callback);
        };
      }
      var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
      var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
      var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
      function fallback(fn) {
        setTimeout(fn, 0);
      }
      function wrap(defer) {
        return (fn, ...args) => defer(() => fn(...args));
      }
      var _defer;
      if (hasQueueMicrotask) {
        _defer = queueMicrotask;
      } else if (hasSetImmediate) {
        _defer = setImmediate;
      } else if (hasNextTick) {
        _defer = process.nextTick;
      } else {
        _defer = fallback;
      }
      var setImmediate$1 = wrap(_defer);
      function asyncify(func) {
        if (isAsync(func)) {
          return function(...args) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback);
          };
        }
        return initialParams(function(args, callback) {
          var result;
          try {
            result = func.apply(this, args);
          } catch (e) {
            return callback(e);
          }
          if (result && typeof result.then === "function") {
            return handlePromise(result, callback);
          } else {
            callback(null, result);
          }
        });
      }
      function handlePromise(promise, callback) {
        return promise.then((value) => {
          invokeCallback(callback, null, value);
        }, (err) => {
          invokeCallback(callback, err && err.message ? err : new Error(err));
        });
      }
      function invokeCallback(callback, error2, value) {
        try {
          callback(error2, value);
        } catch (err) {
          setImmediate$1((e) => {
            throw e;
          }, err);
        }
      }
      function isAsync(fn) {
        return fn[Symbol.toStringTag] === "AsyncFunction";
      }
      function isAsyncGenerator(fn) {
        return fn[Symbol.toStringTag] === "AsyncGenerator";
      }
      function isAsyncIterable(obj) {
        return typeof obj[Symbol.asyncIterator] === "function";
      }
      function wrapAsync(asyncFn) {
        if (typeof asyncFn !== "function")
          throw new Error("expected a function");
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
      }
      function awaitify(asyncFn, arity = asyncFn.length) {
        if (!arity)
          throw new Error("arity is undefined");
        function awaitable(...args) {
          if (typeof args[arity - 1] === "function") {
            return asyncFn.apply(this, args);
          }
          return new Promise((resolve, reject2) => {
            args[arity - 1] = (err, ...cbArgs) => {
              if (err)
                return reject2(err);
              resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
          });
        }
        return awaitable;
      }
      function applyEach(eachfn) {
        return function applyEach2(fns, ...callArgs) {
          const go = awaitify(function(callback) {
            var that = this;
            return eachfn(fns, (fn, cb) => {
              wrapAsync(fn).apply(that, callArgs.concat(cb));
            }, callback);
          });
          return go;
        };
      }
      function _asyncMap(eachfn, arr, iteratee, callback) {
        arr = arr || [];
        var results = [];
        var counter = 0;
        var _iteratee = wrapAsync(iteratee);
        return eachfn(arr, (value, _, iterCb) => {
          var index2 = counter++;
          _iteratee(value, (err, v) => {
            results[index2] = v;
            iterCb(err);
          });
        }, (err) => {
          callback(err, results);
        });
      }
      function isArrayLike(value) {
        return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
      }
      const breakLoop = {};
      function once(fn) {
        function wrapper(...args) {
          if (fn === null)
            return;
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        }
        Object.assign(wrapper, fn);
        return wrapper;
      }
      function getIterator(coll) {
        return coll[Symbol.iterator] && coll[Symbol.iterator]();
      }
      function createArrayIterator(coll) {
        var i = -1;
        var len = coll.length;
        return function next() {
          return ++i < len ? { value: coll[i], key: i } : null;
        };
      }
      function createES2015Iterator(iterator) {
        var i = -1;
        return function next() {
          var item = iterator.next();
          if (item.done)
            return null;
          i++;
          return { value: item.value, key: i };
        };
      }
      function createObjectIterator(obj) {
        var okeys = obj ? Object.keys(obj) : [];
        var i = -1;
        var len = okeys.length;
        return function next() {
          var key = okeys[++i];
          if (key === "__proto__") {
            return next();
          }
          return i < len ? { value: obj[key], key } : null;
        };
      }
      function createIterator(coll) {
        if (isArrayLike(coll)) {
          return createArrayIterator(coll);
        }
        var iterator = getIterator(coll);
        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
      }
      function onlyOnce(fn) {
        return function(...args) {
          if (fn === null)
            throw new Error("Callback was already called.");
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        };
      }
      function asyncEachOfLimit(generator, limit, iteratee, callback) {
        let done = false;
        let canceled = false;
        let awaiting = false;
        let running = 0;
        let idx = 0;
        function replenish() {
          if (running >= limit || awaiting || done)
            return;
          awaiting = true;
          generator.next().then(({ value, done: iterDone }) => {
            if (canceled || done)
              return;
            awaiting = false;
            if (iterDone) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
          }).catch(handleError);
        }
        function iterateeCallback(err, result) {
          running -= 1;
          if (canceled)
            return;
          if (err)
            return handleError(err);
          if (err === false) {
            done = true;
            canceled = true;
            return;
          }
          if (result === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          }
          replenish();
        }
        function handleError(err) {
          if (canceled)
            return;
          awaiting = false;
          done = true;
          callback(err);
        }
        replenish();
      }
      var eachOfLimit = (limit) => {
        return (obj, iteratee, callback) => {
          callback = once(callback);
          if (limit <= 0) {
            throw new RangeError("concurrency limit cannot be less than 1");
          }
          if (!obj) {
            return callback(null);
          }
          if (isAsyncGenerator(obj)) {
            return asyncEachOfLimit(obj, limit, iteratee, callback);
          }
          if (isAsyncIterable(obj)) {
            return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
          }
          var nextElem = createIterator(obj);
          var done = false;
          var canceled = false;
          var running = 0;
          var looping = false;
          function iterateeCallback(err, value) {
            if (canceled)
              return;
            running -= 1;
            if (err) {
              done = true;
              callback(err);
            } else if (err === false) {
              done = true;
              canceled = true;
            } else if (value === breakLoop || done && running <= 0) {
              done = true;
              return callback(null);
            } else if (!looping) {
              replenish();
            }
          }
          function replenish() {
            looping = true;
            while (running < limit && !done) {
              var elem = nextElem();
              if (elem === null) {
                done = true;
                if (running <= 0) {
                  callback(null);
                }
                return;
              }
              running += 1;
              iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
          }
          replenish();
        };
      };
      function eachOfLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
      }
      var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);
      function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback);
        var index2 = 0, completed = 0, { length } = coll, canceled = false;
        if (length === 0) {
          callback(null);
        }
        function iteratorCallback(err, value) {
          if (err === false) {
            canceled = true;
          }
          if (canceled === true)
            return;
          if (err) {
            callback(err);
          } else if (++completed === length || value === breakLoop) {
            callback(null);
          }
        }
        for (; index2 < length; index2++) {
          iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
        }
      }
      function eachOfGeneric(coll, iteratee, callback) {
        return eachOfLimit$2(coll, Infinity, iteratee, callback);
      }
      function eachOf(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        return eachOfImplementation(coll, wrapAsync(iteratee), callback);
      }
      var eachOf$1 = awaitify(eachOf, 3);
      function map(coll, iteratee, callback) {
        return _asyncMap(eachOf$1, coll, iteratee, callback);
      }
      var map$1 = awaitify(map, 3);
      var applyEach$1 = applyEach(map$1);
      function eachOfSeries(coll, iteratee, callback) {
        return eachOfLimit$2(coll, 1, iteratee, callback);
      }
      var eachOfSeries$1 = awaitify(eachOfSeries, 3);
      function mapSeries(coll, iteratee, callback) {
        return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
      }
      var mapSeries$1 = awaitify(mapSeries, 3);
      var applyEachSeries = applyEach(mapSeries$1);
      const PROMISE_SYMBOL = Symbol("promiseCallback");
      function promiseCallback() {
        let resolve, reject2;
        function callback(err, ...args) {
          if (err)
            return reject2(err);
          resolve(args.length > 1 ? args : args[0]);
        }
        callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
          resolve = res, reject2 = rej;
        });
        return callback;
      }
      function auto(tasks, concurrency, callback) {
        if (typeof concurrency !== "number") {
          callback = concurrency;
          concurrency = null;
        }
        callback = once(callback || promiseCallback());
        var numTasks = Object.keys(tasks).length;
        if (!numTasks) {
          return callback(null);
        }
        if (!concurrency) {
          concurrency = numTasks;
        }
        var results = {};
        var runningTasks = 0;
        var canceled = false;
        var hasError = false;
        var listeners = Object.create(null);
        var readyTasks = [];
        var readyToCheck = [];
        var uncheckedDependencies = {};
        Object.keys(tasks).forEach((key) => {
          var task = tasks[key];
          if (!Array.isArray(task)) {
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
          }
          var dependencies = task.slice(0, task.length - 1);
          var remainingDependencies = dependencies.length;
          if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
          }
          uncheckedDependencies[key] = remainingDependencies;
          dependencies.forEach((dependencyName) => {
            if (!tasks[dependencyName]) {
              throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
            }
            addListener(dependencyName, () => {
              remainingDependencies--;
              if (remainingDependencies === 0) {
                enqueueTask(key, task);
              }
            });
          });
        });
        checkForDeadlocks();
        processQueue();
        function enqueueTask(key, task) {
          readyTasks.push(() => runTask(key, task));
        }
        function processQueue() {
          if (canceled)
            return;
          if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
          }
          while (readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
          }
        }
        function addListener(taskName, fn) {
          var taskListeners = listeners[taskName];
          if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
          }
          taskListeners.push(fn);
        }
        function taskComplete(taskName) {
          var taskListeners = listeners[taskName] || [];
          taskListeners.forEach((fn) => fn());
          processQueue();
        }
        function runTask(key, task) {
          if (hasError)
            return;
          var taskCallback = onlyOnce((err, ...result) => {
            runningTasks--;
            if (err === false) {
              canceled = true;
              return;
            }
            if (result.length < 2) {
              [result] = result;
            }
            if (err) {
              var safeResults = {};
              Object.keys(results).forEach((rkey) => {
                safeResults[rkey] = results[rkey];
              });
              safeResults[key] = result;
              hasError = true;
              listeners = Object.create(null);
              if (canceled)
                return;
              callback(err, safeResults);
            } else {
              results[key] = result;
              taskComplete(key);
            }
          });
          runningTasks++;
          var taskFn = wrapAsync(task[task.length - 1]);
          if (task.length > 1) {
            taskFn(results, taskCallback);
          } else {
            taskFn(taskCallback);
          }
        }
        function checkForDeadlocks() {
          var currentTask;
          var counter = 0;
          while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            getDependents(currentTask).forEach((dependent) => {
              if (--uncheckedDependencies[dependent] === 0) {
                readyToCheck.push(dependent);
              }
            });
          }
          if (counter !== numTasks) {
            throw new Error("async.auto cannot execute tasks due to a recursive dependency");
          }
        }
        function getDependents(taskName) {
          var result = [];
          Object.keys(tasks).forEach((key) => {
            const task = tasks[key];
            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
              result.push(key);
            }
          });
          return result;
        }
        return callback[PROMISE_SYMBOL];
      }
      var FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
      var ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /(=.+)?(\s*)$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      function parseParams(func) {
        const src = func.toString().replace(STRIP_COMMENTS, "");
        let match2 = src.match(FN_ARGS);
        if (!match2) {
          match2 = src.match(ARROW_FN_ARGS);
        }
        if (!match2)
          throw new Error("could not parse args in autoInject\nSource:\n" + src);
        let [, args] = match2;
        return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
      }
      function autoInject(tasks, callback) {
        var newTasks = {};
        Object.keys(tasks).forEach((key) => {
          var taskFn = tasks[key];
          var params;
          var fnIsAsync = isAsync(taskFn);
          var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
          if (Array.isArray(taskFn)) {
            params = [...taskFn];
            taskFn = params.pop();
            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
          } else if (hasNoDeps) {
            newTasks[key] = taskFn;
          } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
              throw new Error("autoInject task functions require explicit parameters.");
            }
            if (!fnIsAsync)
              params.pop();
            newTasks[key] = params.concat(newTask);
          }
          function newTask(results, taskCb) {
            var newArgs = params.map((name) => results[name]);
            newArgs.push(taskCb);
            wrapAsync(taskFn)(...newArgs);
          }
        });
        return auto(newTasks, callback);
      }
      class DLL {
        constructor() {
          this.head = this.tail = null;
          this.length = 0;
        }
        removeLink(node) {
          if (node.prev)
            node.prev.next = node.next;
          else
            this.head = node.next;
          if (node.next)
            node.next.prev = node.prev;
          else
            this.tail = node.prev;
          node.prev = node.next = null;
          this.length -= 1;
          return node;
        }
        empty() {
          while (this.head)
            this.shift();
          return this;
        }
        insertAfter(node, newNode) {
          newNode.prev = node;
          newNode.next = node.next;
          if (node.next)
            node.next.prev = newNode;
          else
            this.tail = newNode;
          node.next = newNode;
          this.length += 1;
        }
        insertBefore(node, newNode) {
          newNode.prev = node.prev;
          newNode.next = node;
          if (node.prev)
            node.prev.next = newNode;
          else
            this.head = newNode;
          node.prev = newNode;
          this.length += 1;
        }
        unshift(node) {
          if (this.head)
            this.insertBefore(this.head, node);
          else
            setInitial(this, node);
        }
        push(node) {
          if (this.tail)
            this.insertAfter(this.tail, node);
          else
            setInitial(this, node);
        }
        shift() {
          return this.head && this.removeLink(this.head);
        }
        pop() {
          return this.tail && this.removeLink(this.tail);
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          var cur = this.head;
          while (cur) {
            yield cur.data;
            cur = cur.next;
          }
        }
        remove(testFn) {
          var curr = this.head;
          while (curr) {
            var { next } = curr;
            if (testFn(curr)) {
              this.removeLink(curr);
            }
            curr = next;
          }
          return this;
        }
      }
      function setInitial(dll, node) {
        dll.length = 1;
        dll.head = dll.tail = node;
      }
      function queue(worker, concurrency, payload) {
        if (concurrency == null) {
          concurrency = 1;
        } else if (concurrency === 0) {
          throw new RangeError("Concurrency must not be zero");
        }
        var _worker = wrapAsync(worker);
        var numRunning = 0;
        var workersList = [];
        const events = {
          error: [],
          drain: [],
          saturated: [],
          unsaturated: [],
          empty: []
        };
        function on(event, handler) {
          events[event].push(handler);
        }
        function once2(event, handler) {
          const handleAndRemove = (...args) => {
            off(event, handleAndRemove);
            handler(...args);
          };
          events[event].push(handleAndRemove);
        }
        function off(event, handler) {
          if (!event)
            return Object.keys(events).forEach((ev) => events[ev] = []);
          if (!handler)
            return events[event] = [];
          events[event] = events[event].filter((ev) => ev !== handler);
        }
        function trigger(event, ...args) {
          events[event].forEach((handler) => handler(...args));
        }
        var processingScheduled = false;
        function _insert(data, insertAtFront, rejectOnError, callback) {
          if (callback != null && typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          var res, rej;
          function promiseCallback2(err, ...args) {
            if (err)
              return rejectOnError ? rej(err) : res();
            if (args.length <= 1)
              return res(args[0]);
            res(args);
          }
          var item = {
            data,
            callback: rejectOnError ? promiseCallback2 : callback || promiseCallback2
          };
          if (insertAtFront) {
            q._tasks.unshift(item);
          } else {
            q._tasks.push(item);
          }
          if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(() => {
              processingScheduled = false;
              q.process();
            });
          }
          if (rejectOnError || !callback) {
            return new Promise((resolve, reject2) => {
              res = resolve;
              rej = reject2;
            });
          }
        }
        function _createCB(tasks) {
          return function(err, ...args) {
            numRunning -= 1;
            for (var i = 0, l = tasks.length; i < l; i++) {
              var task = tasks[i];
              var index2 = workersList.indexOf(task);
              if (index2 === 0) {
                workersList.shift();
              } else if (index2 > 0) {
                workersList.splice(index2, 1);
              }
              task.callback(err, ...args);
              if (err != null) {
                trigger("error", err, task.data);
              }
            }
            if (numRunning <= q.concurrency - q.buffer) {
              trigger("unsaturated");
            }
            if (q.idle()) {
              trigger("drain");
            }
            q.process();
          };
        }
        function _maybeDrain(data) {
          if (data.length === 0 && q.idle()) {
            setImmediate$1(() => trigger("drain"));
            return true;
          }
          return false;
        }
        const eventMethod = (name) => (handler) => {
          if (!handler) {
            return new Promise((resolve, reject2) => {
              once2(name, (err, data) => {
                if (err)
                  return reject2(err);
                resolve(data);
              });
            });
          }
          off(name);
          on(name, handler);
        };
        var isProcessing = false;
        var q = {
          _tasks: new DLL(),
          *[Symbol.iterator]() {
            yield* q._tasks[Symbol.iterator]();
          },
          concurrency,
          payload,
          buffer: concurrency / 4,
          started: false,
          paused: false,
          push(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, false, false, callback));
            }
            return _insert(data, false, false, callback);
          },
          pushAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, false, true, callback));
            }
            return _insert(data, false, true, callback);
          },
          kill() {
            off();
            q._tasks.empty();
          },
          unshift(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, true, false, callback));
            }
            return _insert(data, true, false, callback);
          },
          unshiftAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, true, true, callback));
            }
            return _insert(data, true, true, callback);
          },
          remove(testFn) {
            q._tasks.remove(testFn);
          },
          process() {
            if (isProcessing) {
              return;
            }
            isProcessing = true;
            while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
              var tasks = [], data = [];
              var l = q._tasks.length;
              if (q.payload)
                l = Math.min(l, q.payload);
              for (var i = 0; i < l; i++) {
                var node = q._tasks.shift();
                tasks.push(node);
                workersList.push(node);
                data.push(node.data);
              }
              numRunning += 1;
              if (q._tasks.length === 0) {
                trigger("empty");
              }
              if (numRunning === q.concurrency) {
                trigger("saturated");
              }
              var cb = onlyOnce(_createCB(tasks));
              _worker(data, cb);
            }
            isProcessing = false;
          },
          length() {
            return q._tasks.length;
          },
          running() {
            return numRunning;
          },
          workersList() {
            return workersList;
          },
          idle() {
            return q._tasks.length + numRunning === 0;
          },
          pause() {
            q.paused = true;
          },
          resume() {
            if (q.paused === false) {
              return;
            }
            q.paused = false;
            setImmediate$1(q.process);
          }
        };
        Object.defineProperties(q, {
          saturated: {
            writable: false,
            value: eventMethod("saturated")
          },
          unsaturated: {
            writable: false,
            value: eventMethod("unsaturated")
          },
          empty: {
            writable: false,
            value: eventMethod("empty")
          },
          drain: {
            writable: false,
            value: eventMethod("drain")
          },
          error: {
            writable: false,
            value: eventMethod("error")
          }
        });
        return q;
      }
      function cargo(worker, payload) {
        return queue(worker, 1, payload);
      }
      function cargo$1(worker, concurrency, payload) {
        return queue(worker, concurrency, payload);
      }
      function reduce(coll, memo, iteratee, callback) {
        callback = once(callback);
        var _iteratee = wrapAsync(iteratee);
        return eachOfSeries$1(coll, (x, i, iterCb) => {
          _iteratee(memo, x, (err, v) => {
            memo = v;
            iterCb(err);
          });
        }, (err) => callback(err, memo));
      }
      var reduce$1 = awaitify(reduce, 4);
      function seq(...functions) {
        var _functions = functions.map(wrapAsync);
        return function(...args) {
          var that = this;
          var cb = args[args.length - 1];
          if (typeof cb == "function") {
            args.pop();
          } else {
            cb = promiseCallback();
          }
          reduce$1(_functions, args, (newargs, fn, iterCb) => {
            fn.apply(that, newargs.concat((err, ...nextargs) => {
              iterCb(err, nextargs);
            }));
          }, (err, results) => cb(err, ...results));
          return cb[PROMISE_SYMBOL];
        };
      }
      function compose(...args) {
        return seq(...args.reverse());
      }
      function mapLimit(coll, limit, iteratee, callback) {
        return _asyncMap(eachOfLimit(limit), coll, iteratee, callback);
      }
      var mapLimit$1 = awaitify(mapLimit, 4);
      function concatLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, ...args) => {
            if (err)
              return iterCb(err);
            return iterCb(err, args);
          });
        }, (err, mapResults) => {
          var result = [];
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              result = result.concat(...mapResults[i]);
            }
          }
          return callback(err, result);
        });
      }
      var concatLimit$1 = awaitify(concatLimit, 4);
      function concat(coll, iteratee, callback) {
        return concatLimit$1(coll, Infinity, iteratee, callback);
      }
      var concat$1 = awaitify(concat, 3);
      function concatSeries(coll, iteratee, callback) {
        return concatLimit$1(coll, 1, iteratee, callback);
      }
      var concatSeries$1 = awaitify(concatSeries, 3);
      function constant(...args) {
        return function(...ignoredArgs) {
          var callback = ignoredArgs.pop();
          return callback(null, ...args);
        };
      }
      function _createTester(check, getResult) {
        return (eachfn, arr, _iteratee, cb) => {
          var testPassed = false;
          var testResult;
          const iteratee = wrapAsync(_iteratee);
          eachfn(arr, (value, _, callback) => {
            iteratee(value, (err, result) => {
              if (err || err === false)
                return callback(err);
              if (check(result) && !testResult) {
                testPassed = true;
                testResult = getResult(true, value);
                return callback(null, breakLoop);
              }
              callback();
            });
          }, (err) => {
            if (err)
              return cb(err);
            cb(null, testPassed ? testResult : getResult(false));
          });
        };
      }
      function detect(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
      }
      var detect$1 = awaitify(detect, 3);
      function detectLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var detectLimit$1 = awaitify(detectLimit, 4);
      function detectSeries(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback);
      }
      var detectSeries$1 = awaitify(detectSeries, 3);
      function consoleFunc(name) {
        return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
          if (typeof console === "object") {
            if (err) {
              if (console.error) {
                console.error(err);
              }
            } else if (console[name]) {
              resultArgs.forEach((x) => console[name](x));
            }
          }
        });
      }
      var dir = consoleFunc("dir");
      function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results;
        function next(err, ...args) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          results = args;
          _test(...args, check);
        }
        function check(err, truth) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          if (!truth)
            return callback(null, ...results);
          _fn(next);
        }
        return check(null, true);
      }
      var doWhilst$1 = awaitify(doWhilst, 3);
      function doUntil(iteratee, test, callback) {
        const _test = wrapAsync(test);
        return doWhilst$1(iteratee, (...args) => {
          const cb = args.pop();
          _test(...args, (err, truth) => cb(err, !truth));
        }, callback);
      }
      function _withoutIndex(iteratee) {
        return (value, index2, callback) => iteratee(value, callback);
      }
      function eachLimit(coll, iteratee, callback) {
        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var each = awaitify(eachLimit, 3);
      function eachLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var eachLimit$2 = awaitify(eachLimit$1, 4);
      function eachSeries(coll, iteratee, callback) {
        return eachLimit$2(coll, 1, iteratee, callback);
      }
      var eachSeries$1 = awaitify(eachSeries, 3);
      function ensureAsync(fn) {
        if (isAsync(fn))
          return fn;
        return function(...args) {
          var callback = args.pop();
          var sync = true;
          args.push((...innerArgs) => {
            if (sync) {
              setImmediate$1(() => callback(...innerArgs));
            } else {
              callback(...innerArgs);
            }
          });
          fn.apply(this, args);
          sync = false;
        };
      }
      function every(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
      }
      var every$1 = awaitify(every, 3);
      function everyLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var everyLimit$1 = awaitify(everyLimit, 4);
      function everySeries(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var everySeries$1 = awaitify(everySeries, 3);
      function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            truthValues[index2] = !!v;
            iterCb(err);
          });
        }, (err) => {
          if (err)
            return callback(err);
          var results = [];
          for (var i = 0; i < arr.length; i++) {
            if (truthValues[i])
              results.push(arr[i]);
          }
          callback(null, results);
        });
      }
      function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            if (err)
              return iterCb(err);
            if (v) {
              results.push({ index: index2, value: x });
            }
            iterCb(err);
          });
        }, (err) => {
          if (err)
            return callback(err);
          callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
        });
      }
      function _filter(eachfn, coll, iteratee, callback) {
        var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
        return filter2(eachfn, coll, wrapAsync(iteratee), callback);
      }
      function filter(coll, iteratee, callback) {
        return _filter(eachOf$1, coll, iteratee, callback);
      }
      var filter$1 = awaitify(filter, 3);
      function filterLimit(coll, limit, iteratee, callback) {
        return _filter(eachOfLimit(limit), coll, iteratee, callback);
      }
      var filterLimit$1 = awaitify(filterLimit, 4);
      function filterSeries(coll, iteratee, callback) {
        return _filter(eachOfSeries$1, coll, iteratee, callback);
      }
      var filterSeries$1 = awaitify(filterSeries, 3);
      function forever(fn, errback) {
        var done = onlyOnce(errback);
        var task = wrapAsync(ensureAsync(fn));
        function next(err) {
          if (err)
            return done(err);
          if (err === false)
            return;
          task(next);
        }
        return next();
      }
      var forever$1 = awaitify(forever, 2);
      function groupByLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, key) => {
            if (err)
              return iterCb(err);
            return iterCb(err, { key, val });
          });
        }, (err, mapResults) => {
          var result = {};
          var { hasOwnProperty } = Object.prototype;
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              var { key } = mapResults[i];
              var { val } = mapResults[i];
              if (hasOwnProperty.call(result, key)) {
                result[key].push(val);
              } else {
                result[key] = [val];
              }
            }
          }
          return callback(err, result);
        });
      }
      var groupByLimit$1 = awaitify(groupByLimit, 4);
      function groupBy(coll, iteratee, callback) {
        return groupByLimit$1(coll, Infinity, iteratee, callback);
      }
      function groupBySeries(coll, iteratee, callback) {
        return groupByLimit$1(coll, 1, iteratee, callback);
      }
      var log2 = consoleFunc("log");
      function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback);
        var newObj = {};
        var _iteratee = wrapAsync(iteratee);
        return eachOfLimit(limit)(obj, (val, key, next) => {
          _iteratee(val, key, (err, result) => {
            if (err)
              return next(err);
            newObj[key] = result;
            next(err);
          });
        }, (err) => callback(err, newObj));
      }
      var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
      function mapValues(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, Infinity, iteratee, callback);
      }
      function mapValuesSeries(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, 1, iteratee, callback);
      }
      function memoize(fn, hasher = (v) => v) {
        var memo = Object.create(null);
        var queues = Object.create(null);
        var _fn = wrapAsync(fn);
        var memoized = initialParams((args, callback) => {
          var key = hasher(...args);
          if (key in memo) {
            setImmediate$1(() => callback(null, ...memo[key]));
          } else if (key in queues) {
            queues[key].push(callback);
          } else {
            queues[key] = [callback];
            _fn(...args, (err, ...resultArgs) => {
              if (!err) {
                memo[key] = resultArgs;
              }
              var q = queues[key];
              delete queues[key];
              for (var i = 0, l = q.length; i < l; i++) {
                q[i](err, ...resultArgs);
              }
            });
          }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      }
      var _defer$1;
      if (hasNextTick) {
        _defer$1 = process.nextTick;
      } else if (hasSetImmediate) {
        _defer$1 = setImmediate;
      } else {
        _defer$1 = fallback;
      }
      var nextTick = wrap(_defer$1);
      var _parallel = awaitify((eachfn, tasks, callback) => {
        var results = isArrayLike(tasks) ? [] : {};
        eachfn(tasks, (task, key, taskCb) => {
          wrapAsync(task)((err, ...result) => {
            if (result.length < 2) {
              [result] = result;
            }
            results[key] = result;
            taskCb(err);
          });
        }, (err) => callback(err, results));
      }, 3);
      function parallel(tasks, callback) {
        return _parallel(eachOf$1, tasks, callback);
      }
      function parallelLimit(tasks, limit, callback) {
        return _parallel(eachOfLimit(limit), tasks, callback);
      }
      function queue$1(worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue((items, cb) => {
          _worker(items[0], cb);
        }, concurrency, 1);
      }
      class Heap {
        constructor() {
          this.heap = [];
          this.pushCount = Number.MIN_SAFE_INTEGER;
        }
        get length() {
          return this.heap.length;
        }
        empty() {
          this.heap = [];
          return this;
        }
        percUp(index2) {
          let p;
          while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
            let t = this.heap[index2];
            this.heap[index2] = this.heap[p];
            this.heap[p] = t;
            index2 = p;
          }
        }
        percDown(index2) {
          let l;
          while ((l = leftChi(index2)) < this.heap.length) {
            if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
              l = l + 1;
            }
            if (smaller(this.heap[index2], this.heap[l])) {
              break;
            }
            let t = this.heap[index2];
            this.heap[index2] = this.heap[l];
            this.heap[l] = t;
            index2 = l;
          }
        }
        push(node) {
          node.pushCount = ++this.pushCount;
          this.heap.push(node);
          this.percUp(this.heap.length - 1);
        }
        unshift(node) {
          return this.heap.push(node);
        }
        shift() {
          let [top] = this.heap;
          this.heap[0] = this.heap[this.heap.length - 1];
          this.heap.pop();
          this.percDown(0);
          return top;
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          for (let i = 0; i < this.heap.length; i++) {
            yield this.heap[i].data;
          }
        }
        remove(testFn) {
          let j = 0;
          for (let i = 0; i < this.heap.length; i++) {
            if (!testFn(this.heap[i])) {
              this.heap[j] = this.heap[i];
              j++;
            }
          }
          this.heap.splice(j);
          for (let i = parent(this.heap.length - 1); i >= 0; i--) {
            this.percDown(i);
          }
          return this;
        }
      }
      function leftChi(i) {
        return (i << 1) + 1;
      }
      function parent(i) {
        return (i + 1 >> 1) - 1;
      }
      function smaller(x, y) {
        if (x.priority !== y.priority) {
          return x.priority < y.priority;
        } else {
          return x.pushCount < y.pushCount;
        }
      }
      function priorityQueue(worker, concurrency) {
        var q = queue$1(worker, concurrency);
        var processingScheduled = false;
        q._tasks = new Heap();
        q.push = function(data, priority = 0, callback = () => {
        }) {
          if (typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          if (!Array.isArray(data)) {
            data = [data];
          }
          if (data.length === 0 && q.idle()) {
            return setImmediate$1(() => q.drain());
          }
          for (var i = 0, l = data.length; i < l; i++) {
            var item = {
              data: data[i],
              priority,
              callback
            };
            q._tasks.push(item);
          }
          if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(() => {
              processingScheduled = false;
              q.process();
            });
          }
        };
        delete q.unshift;
        return q;
      }
      function race(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks))
          return callback(new TypeError("First argument to race must be an array of functions"));
        if (!tasks.length)
          return callback();
        for (var i = 0, l = tasks.length; i < l; i++) {
          wrapAsync(tasks[i])(callback);
        }
      }
      var race$1 = awaitify(race, 2);
      function reduceRight(array, memo, iteratee, callback) {
        var reversed = [...array].reverse();
        return reduce$1(reversed, memo, iteratee, callback);
      }
      function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function reflectOn(args, reflectCallback) {
          args.push((error2, ...cbArgs) => {
            let retVal = {};
            if (error2) {
              retVal.error = error2;
            }
            if (cbArgs.length > 0) {
              var value = cbArgs;
              if (cbArgs.length <= 1) {
                [value] = cbArgs;
              }
              retVal.value = value;
            }
            reflectCallback(null, retVal);
          });
          return _fn.apply(this, args);
        });
      }
      function reflectAll(tasks) {
        var results;
        if (Array.isArray(tasks)) {
          results = tasks.map(reflect);
        } else {
          results = {};
          Object.keys(tasks).forEach((key) => {
            results[key] = reflect.call(this, tasks[key]);
          });
        }
        return results;
      }
      function reject(eachfn, arr, _iteratee, callback) {
        const iteratee = wrapAsync(_iteratee);
        return _filter(eachfn, arr, (value, cb) => {
          iteratee(value, (err, v) => {
            cb(err, !v);
          });
        }, callback);
      }
      function reject$1(coll, iteratee, callback) {
        return reject(eachOf$1, coll, iteratee, callback);
      }
      var reject$2 = awaitify(reject$1, 3);
      function rejectLimit(coll, limit, iteratee, callback) {
        return reject(eachOfLimit(limit), coll, iteratee, callback);
      }
      var rejectLimit$1 = awaitify(rejectLimit, 4);
      function rejectSeries(coll, iteratee, callback) {
        return reject(eachOfSeries$1, coll, iteratee, callback);
      }
      var rejectSeries$1 = awaitify(rejectSeries, 3);
      function constant$1(value) {
        return function() {
          return value;
        };
      }
      const DEFAULT_TIMES = 5;
      const DEFAULT_INTERVAL = 0;
      function retry(opts, task, callback) {
        var options = {
          times: DEFAULT_TIMES,
          intervalFunc: constant$1(DEFAULT_INTERVAL)
        };
        if (arguments.length < 3 && typeof opts === "function") {
          callback = task || promiseCallback();
          task = opts;
        } else {
          parseTimes(options, opts);
          callback = callback || promiseCallback();
        }
        if (typeof task !== "function") {
          throw new Error("Invalid arguments for async.retry");
        }
        var _task = wrapAsync(task);
        var attempt = 1;
        function retryAttempt() {
          _task((err, ...args) => {
            if (err === false)
              return;
            if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
              setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
            } else {
              callback(err, ...args);
            }
          });
        }
        retryAttempt();
        return callback[PROMISE_SYMBOL];
      }
      function parseTimes(acc, t) {
        if (typeof t === "object") {
          acc.times = +t.times || DEFAULT_TIMES;
          acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
          acc.errorFilter = t.errorFilter;
        } else if (typeof t === "number" || typeof t === "string") {
          acc.times = +t || DEFAULT_TIMES;
        } else {
          throw new Error("Invalid arguments for async.retry");
        }
      }
      function retryable(opts, task) {
        if (!task) {
          task = opts;
          opts = null;
        }
        let arity = opts && opts.arity || task.length;
        if (isAsync(task)) {
          arity += 1;
        }
        var _task = wrapAsync(task);
        return initialParams((args, callback) => {
          if (args.length < arity - 1 || callback == null) {
            args.push(callback);
            callback = promiseCallback();
          }
          function taskFn(cb) {
            _task(...args, cb);
          }
          if (opts)
            retry(opts, taskFn, callback);
          else
            retry(taskFn, callback);
          return callback[PROMISE_SYMBOL];
        });
      }
      function series(tasks, callback) {
        return _parallel(eachOfSeries$1, tasks, callback);
      }
      function some(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
      }
      var some$1 = awaitify(some, 3);
      function someLimit(coll, limit, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var someLimit$1 = awaitify(someLimit, 4);
      function someSeries(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var someSeries$1 = awaitify(someSeries, 3);
      function sortBy(coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return map$1(coll, (x, iterCb) => {
          _iteratee(x, (err, criteria) => {
            if (err)
              return iterCb(err);
            iterCb(err, { value: x, criteria });
          });
        }, (err, results) => {
          if (err)
            return callback(err);
          callback(null, results.sort(comparator).map((v) => v.value));
        });
        function comparator(left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        }
      }
      var sortBy$1 = awaitify(sortBy, 3);
      function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);
        return initialParams((args, callback) => {
          var timedOut = false;
          var timer;
          function timeoutCallback() {
            var name = asyncFn.name || "anonymous";
            var error2 = new Error('Callback function "' + name + '" timed out.');
            error2.code = "ETIMEDOUT";
            if (info) {
              error2.info = info;
            }
            timedOut = true;
            callback(error2);
          }
          args.push((...cbArgs) => {
            if (!timedOut) {
              callback(...cbArgs);
              clearTimeout(timer);
            }
          });
          timer = setTimeout(timeoutCallback, milliseconds);
          fn(...args);
        });
      }
      function range(size) {
        var result = Array(size);
        while (size--) {
          result[size] = size;
        }
        return result;
      }
      function timesLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(range(count), limit, _iteratee, callback);
      }
      function times(n, iteratee, callback) {
        return timesLimit(n, Infinity, iteratee, callback);
      }
      function timesSeries(n, iteratee, callback) {
        return timesLimit(n, 1, iteratee, callback);
      }
      function transform(coll, accumulator, iteratee, callback) {
        if (arguments.length <= 3 && typeof accumulator === "function") {
          callback = iteratee;
          iteratee = accumulator;
          accumulator = Array.isArray(coll) ? [] : {};
        }
        callback = once(callback || promiseCallback());
        var _iteratee = wrapAsync(iteratee);
        eachOf$1(coll, (v, k, cb) => {
          _iteratee(accumulator, v, k, cb);
        }, (err) => callback(err, accumulator));
        return callback[PROMISE_SYMBOL];
      }
      function tryEach(tasks, callback) {
        var error2 = null;
        var result;
        return eachSeries$1(tasks, (task, taskCb) => {
          wrapAsync(task)((err, ...args) => {
            if (err === false)
              return taskCb(err);
            if (args.length < 2) {
              [result] = args;
            } else {
              result = args;
            }
            error2 = err;
            taskCb(err ? null : {});
          });
        }, () => callback(error2, result));
      }
      var tryEach$1 = awaitify(tryEach);
      function unmemoize(fn) {
        return (...args) => {
          return (fn.unmemoized || fn)(...args);
        };
      }
      function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results = [];
        function next(err, ...rest) {
          if (err)
            return callback(err);
          results = rest;
          if (err === false)
            return;
          _test(check);
        }
        function check(err, truth) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          if (!truth)
            return callback(null, ...results);
          _fn(next);
        }
        return _test(check);
      }
      var whilst$1 = awaitify(whilst, 3);
      function until(test, iteratee, callback) {
        const _test = wrapAsync(test);
        return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
      }
      function waterfall(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks))
          return callback(new Error("First argument to waterfall must be an array of functions"));
        if (!tasks.length)
          return callback();
        var taskIndex = 0;
        function nextTask(args) {
          var task = wrapAsync(tasks[taskIndex++]);
          task(...args, onlyOnce(next));
        }
        function next(err, ...args) {
          if (err === false)
            return;
          if (err || taskIndex === tasks.length) {
            return callback(err, ...args);
          }
          nextTask(args);
        }
        nextTask([]);
      }
      var waterfall$1 = awaitify(waterfall);
      var index = {
        apply,
        applyEach: applyEach$1,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo,
        cargoQueue: cargo$1,
        compose,
        concat: concat$1,
        concatLimit: concatLimit$1,
        concatSeries: concatSeries$1,
        constant,
        detect: detect$1,
        detectLimit: detectLimit$1,
        detectSeries: detectSeries$1,
        dir,
        doUntil,
        doWhilst: doWhilst$1,
        each,
        eachLimit: eachLimit$2,
        eachOf: eachOf$1,
        eachOfLimit: eachOfLimit$2,
        eachOfSeries: eachOfSeries$1,
        eachSeries: eachSeries$1,
        ensureAsync,
        every: every$1,
        everyLimit: everyLimit$1,
        everySeries: everySeries$1,
        filter: filter$1,
        filterLimit: filterLimit$1,
        filterSeries: filterSeries$1,
        forever: forever$1,
        groupBy,
        groupByLimit: groupByLimit$1,
        groupBySeries,
        log: log2,
        map: map$1,
        mapLimit: mapLimit$1,
        mapSeries: mapSeries$1,
        mapValues,
        mapValuesLimit: mapValuesLimit$1,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel,
        parallelLimit,
        priorityQueue,
        queue: queue$1,
        race: race$1,
        reduce: reduce$1,
        reduceRight,
        reflect,
        reflectAll,
        reject: reject$2,
        rejectLimit: rejectLimit$1,
        rejectSeries: rejectSeries$1,
        retry,
        retryable,
        seq,
        series,
        setImmediate: setImmediate$1,
        some: some$1,
        someLimit: someLimit$1,
        someSeries: someSeries$1,
        sortBy: sortBy$1,
        timeout,
        times,
        timesLimit,
        timesSeries,
        transform,
        tryEach: tryEach$1,
        unmemoize,
        until,
        waterfall: waterfall$1,
        whilst: whilst$1,
        all: every$1,
        allLimit: everyLimit$1,
        allSeries: everySeries$1,
        any: some$1,
        anyLimit: someLimit$1,
        anySeries: someSeries$1,
        find: detect$1,
        findLimit: detectLimit$1,
        findSeries: detectSeries$1,
        flatMap: concat$1,
        flatMapLimit: concatLimit$1,
        flatMapSeries: concatSeries$1,
        forEach: each,
        forEachSeries: eachSeries$1,
        forEachLimit: eachLimit$2,
        forEachOf: eachOf$1,
        forEachOfSeries: eachOfSeries$1,
        forEachOfLimit: eachOfLimit$2,
        inject: reduce$1,
        foldl: reduce$1,
        foldr: reduceRight,
        select: filter$1,
        selectLimit: filterLimit$1,
        selectSeries: filterSeries$1,
        wrapSync: asyncify,
        during: whilst$1,
        doDuring: doWhilst$1
      };
      exports3.default = index;
      exports3.apply = apply;
      exports3.applyEach = applyEach$1;
      exports3.applyEachSeries = applyEachSeries;
      exports3.asyncify = asyncify;
      exports3.auto = auto;
      exports3.autoInject = autoInject;
      exports3.cargo = cargo;
      exports3.cargoQueue = cargo$1;
      exports3.compose = compose;
      exports3.concat = concat$1;
      exports3.concatLimit = concatLimit$1;
      exports3.concatSeries = concatSeries$1;
      exports3.constant = constant;
      exports3.detect = detect$1;
      exports3.detectLimit = detectLimit$1;
      exports3.detectSeries = detectSeries$1;
      exports3.dir = dir;
      exports3.doUntil = doUntil;
      exports3.doWhilst = doWhilst$1;
      exports3.each = each;
      exports3.eachLimit = eachLimit$2;
      exports3.eachOf = eachOf$1;
      exports3.eachOfLimit = eachOfLimit$2;
      exports3.eachOfSeries = eachOfSeries$1;
      exports3.eachSeries = eachSeries$1;
      exports3.ensureAsync = ensureAsync;
      exports3.every = every$1;
      exports3.everyLimit = everyLimit$1;
      exports3.everySeries = everySeries$1;
      exports3.filter = filter$1;
      exports3.filterLimit = filterLimit$1;
      exports3.filterSeries = filterSeries$1;
      exports3.forever = forever$1;
      exports3.groupBy = groupBy;
      exports3.groupByLimit = groupByLimit$1;
      exports3.groupBySeries = groupBySeries;
      exports3.log = log2;
      exports3.map = map$1;
      exports3.mapLimit = mapLimit$1;
      exports3.mapSeries = mapSeries$1;
      exports3.mapValues = mapValues;
      exports3.mapValuesLimit = mapValuesLimit$1;
      exports3.mapValuesSeries = mapValuesSeries;
      exports3.memoize = memoize;
      exports3.nextTick = nextTick;
      exports3.parallel = parallel;
      exports3.parallelLimit = parallelLimit;
      exports3.priorityQueue = priorityQueue;
      exports3.queue = queue$1;
      exports3.race = race$1;
      exports3.reduce = reduce$1;
      exports3.reduceRight = reduceRight;
      exports3.reflect = reflect;
      exports3.reflectAll = reflectAll;
      exports3.reject = reject$2;
      exports3.rejectLimit = rejectLimit$1;
      exports3.rejectSeries = rejectSeries$1;
      exports3.retry = retry;
      exports3.retryable = retryable;
      exports3.seq = seq;
      exports3.series = series;
      exports3.setImmediate = setImmediate$1;
      exports3.some = some$1;
      exports3.someLimit = someLimit$1;
      exports3.someSeries = someSeries$1;
      exports3.sortBy = sortBy$1;
      exports3.timeout = timeout;
      exports3.times = times;
      exports3.timesLimit = timesLimit;
      exports3.timesSeries = timesSeries;
      exports3.transform = transform;
      exports3.tryEach = tryEach$1;
      exports3.unmemoize = unmemoize;
      exports3.until = until;
      exports3.waterfall = waterfall$1;
      exports3.whilst = whilst$1;
      exports3.all = every$1;
      exports3.allLimit = everyLimit$1;
      exports3.allSeries = everySeries$1;
      exports3.any = some$1;
      exports3.anyLimit = someLimit$1;
      exports3.anySeries = someSeries$1;
      exports3.find = detect$1;
      exports3.findLimit = detectLimit$1;
      exports3.findSeries = detectSeries$1;
      exports3.flatMap = concat$1;
      exports3.flatMapLimit = concatLimit$1;
      exports3.flatMapSeries = concatSeries$1;
      exports3.forEach = each;
      exports3.forEachSeries = eachSeries$1;
      exports3.forEachLimit = eachLimit$2;
      exports3.forEachOf = eachOf$1;
      exports3.forEachOfSeries = eachOfSeries$1;
      exports3.forEachOfLimit = eachOfLimit$2;
      exports3.inject = reduce$1;
      exports3.foldl = reduce$1;
      exports3.foldr = reduceRight;
      exports3.select = filter$1;
      exports3.selectLimit = filterLimit$1;
      exports3.selectSeries = filterSeries$1;
      exports3.wrapSync = asyncify;
      exports3.during = whilst$1;
      exports3.doDuring = doWhilst$1;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports2, module2) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          "escape": reEscape,
          "evaluate": reEvaluate,
          "interpolate": reInterpolate,
          "variable": "",
          "imports": {
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger2(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger2(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger2(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger2(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger2(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match2 = source.match(reWrapDetails);
          return match2 ? match2[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match2, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger2(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger2(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger2(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex2(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger2(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger2(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger2(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger2(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger2(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger2(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger2(start);
            end = end === undefined2 ? length : toInteger2(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger2(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger2(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex2);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger2(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger2(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger2(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger2(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger2(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger2(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger2(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger2(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey2(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger2(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger2(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger2(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger2(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger2(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger2(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match2.length;
            return match2;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger2(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match2, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match2 = separator.exec(substring)) {
                var newEnd = match2.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger2(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger2(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex2;
        lodash.findKey = findKey2;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate2;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger2;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger2(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger2(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger2(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports2);
  }
});

// node_modules/bunyan-rotating-file-stream/lib/optionParser.js
var require_optionParser = __commonJS({
  "node_modules/bunyan-rotating-file-stream/lib/optionParser.js"(exports2, module2) {
    "use strict";
    var multipliers = {
      "b": 1,
      "k": 1024,
      "m": 1024 * 1024,
      "g": 1024 * 1024 * 1024
    };
    function parsePeriod(period) {
      var result = {
        periodNum: 1,
        periodScope: "d"
      };
      if (period) {
        var crackedperiod = {
          "hourly": "1h",
          "daily": "1d",
          "weekly": "1w",
          "monthly": "1m",
          "yearly": "1y"
        }[period] || period;
        var m = /^([1-9][0-9]*)([hdwmy]|ms)$/.exec(crackedperiod);
        if (!m) {
          throw new Error('invalid period: "' + period + '"');
        }
        result.periodNum = Number(m[1]);
        result.periodScope = m[2];
      }
      return result;
    }
    function parseSize(size) {
      if (typeof size === "string") {
        var threshold = size;
        var m = /^([1-9][0-9]*)([bkmg])$/.exec(threshold);
        if (!m) {
          throw new Error('invalid threshold: "' + size + '"');
        }
        return Number(m[1]) * multipliers[m[2]];
      } else {
        return size;
      }
    }
    module2.exports = { parseSize, parsePeriod };
  }
});

// node_modules/bunyan-rotating-file-stream/lib/limitedqueue.js
var require_limitedqueue = __commonJS({
  "node_modules/bunyan-rotating-file-stream/lib/limitedqueue.js"(exports2, module2) {
    "use strict";
    var async = require_async2();
    var _ = require_lodash();
    var EventEmitter2 = require("events").EventEmitter;
    function LimitedQueue(worker) {
      var base = new EventEmitter2();
      var maxQueueLength = 1e5;
      var queueClearingThreshold = 0.8;
      var throwLogsAway = false;
      var joiners = [];
      var queue = async.cargo(function(s, callback) {
        var queueLowerThreshold = maxQueueLength * queueClearingThreshold;
        if (throwLogsAway && queue.length() < queueLowerThreshold) {
          var notification = {
            "name": "rfs",
            "time": new Date(Date.now()).toISOString(),
            "event": "desaturated",
            "message": "Write queue clearing, allowing new log events",
            "v": 0
          };
          var inplace = _.extend({}, { immediatelog: false }, notification);
          queue.push(JSON.stringify(inplace) + "\n");
          var immediate = _.extend({}, { immediatelog: true }, notification);
          queue.unshift(JSON.stringify(immediate) + "\n");
          console.log(notification.message);
          throwLogsAway = false;
          base.emit("caughtup");
        }
        worker(s, callback);
      }, 2e3);
      function push(s) {
        if (!throwLogsAway) {
          if (queue.length() > maxQueueLength) {
            var notification = {
              "name": "rfs",
              "time": new Date(Date.now()).toISOString(),
              "event": "saturated",
              "message": "Write queue saturated, stopping logging",
              "v": 0
            };
            var inplace = _.extend({}, { immediatelog: false }, notification);
            queue.push(JSON.stringify(inplace) + "\n");
            var immediate = _.extend({}, { immediatelog: true }, notification);
            queue.unshift(JSON.stringify(immediate) + "\n");
            console.log(notification.message);
            throwLogsAway = true;
            base.emit("losingdata");
          } else {
            queue.push(s);
          }
        }
        return queue.length();
      }
      queue.drain(function() {
        if (throwLogsAway) {
          var notification = {
            "name": "rfs",
            "time": new Date(Date.now()).toISOString(),
            "event": "desaturated",
            "message": "Write queue cleared, allowing new log events",
            "v": 0
          };
          var message = _.extend({}, { immediatelog: false }, notification);
          queue.push(JSON.stringify(message) + "\n");
          console.log(notification.message);
          throwLogsAway = false;
          base.emit("caughtup");
        }
        if (joiners.length > 0) {
          for (var i = 0; i < joiners.length; i += 1) {
            joiners[i]();
          }
          joiners = [];
        }
      });
      function isEmpty() {
        return queue.length() === 0;
      }
      function paused() {
        return queue.paused;
      }
      function join(cb) {
        if (queue.length() === 0) {
          cb();
        } else {
          joiners.push(cb);
        }
      }
      return _.extend({}, {
        push,
        paused,
        pause: queue.pause,
        resume: queue.resume,
        unshift: queue.unshift,
        join,
        isEmpty,
        length: queue.length
      }, base);
    }
    module2.exports = LimitedQueue;
  }
});

// node_modules/bunyan-rotating-file-stream/lib/numberedfileops.js
var require_numberedfileops = __commonJS({
  "node_modules/bunyan-rotating-file-stream/lib/numberedfileops.js"(exports2, module2) {
    var fs = require("fs");
    var async = require_async2();
    var path = require("path");
    var _DEBUG = false;
    function NumberedFileOps(logpath, totalFiles, totalSize, gzip) {
      function getNumberedFile(n, zipped) {
        var parsed = path.parse(logpath);
        var result = "";
        if (n === 0) {
          result = parsed.name.replace(".%N", "").replace("_%N", "").replace("-%N", "").replace("%N", "") + parsed.ext;
        } else if (parsed.name.indexOf("%N") >= 0) {
          result = parsed.name.replace("%N", String(n)) + parsed.ext;
        } else {
          result = parsed.base + "." + String(n);
        }
        if (zipped) {
          result += ".gz";
        }
        return path.join(parsed.dir, result);
      }
      function recursiveFindFilesToDelete(currentFileNumber, cumulativeSize, foundFiles, next) {
        var fileToFind = getNumberedFile(currentFileNumber, gzip);
        fs.stat(fileToFind, function(err, stat) {
          if (err && err.code === "ENOENT") {
            next(null, foundFiles);
          } else if (err) {
            next(err);
          } else {
            cumulativeSize += stat.size;
            if (totalSize > 0 && cumulativeSize > totalSize || totalFiles > 0 && currentFileNumber > totalFiles) {
              foundFiles.push(fileToFind);
            }
            recursiveFindFilesToDelete(currentFileNumber + 1, cumulativeSize, foundFiles, next);
          }
        });
      }
      function findFilesToDelete(next) {
        var foundFiles = [];
        recursiveFindFilesToDelete(1, 0, foundFiles, next);
      }
      function deleteFiles(next) {
        findFilesToDelete(function(err, foundFiles) {
          if (err) {
            next(err);
          } else {
            async.eachSeries(foundFiles, function(toDel, callback) {
              if (_DEBUG)
                console.log("rm %s", toDel);
              fs.unlink(toDel, ignoreFileNotFound(callback));
            }, next);
          }
        });
      }
      ;
      function ignoreFileNotFound(next) {
        return function(err) {
          if (!err || err.code === "ENOENT") {
            next();
          } else {
            next(err);
          }
        };
      }
      function recursiveFindFilesToMove(currentFileNumber, foundFiles, next) {
        var fileToFind = getNumberedFile(currentFileNumber, gzip);
        fs.stat(fileToFind, function(err, stat) {
          if (err && err.code === "ENOENT") {
            next(null, foundFiles);
          } else if (err) {
            next(err);
          } else {
            foundFiles.unshift(currentFileNumber);
            recursiveFindFilesToMove(currentFileNumber + 1, foundFiles, next);
          }
        });
      }
      function moveFile(numberToMove, next) {
        var before = getNumberedFile(numberToMove, gzip);
        var after = getNumberedFile(numberToMove + 1, gzip);
        fs.rename(before, after, ignoreFileNotFound(next));
      }
      function moveIntermediateFiles(next) {
        var toMove = [];
        recursiveFindFilesToMove(0, toMove, function(err) {
          if (err) {
            return next(err);
          }
          async.eachSeries(toMove, moveFile, next);
        });
      }
      ;
      function getStreamFilepath(gzipped) {
        return getNumberedFile(0, gzipped);
      }
      function newStreamFilepath(triggerinfo, next) {
        var startNewFile = !triggerinfo.hasOwnProperty("startNewFile") || triggerinfo.startNewFile;
        if (startNewFile) {
          moveIntermediateFiles(function(err) {
            if (err) {
              return next(err);
            }
            next(null, getNumberedFile(0, false));
          });
        } else {
          next(null, getNumberedFile(0, false));
        }
      }
      return {
        getStreamFilepath,
        newStreamFilepath,
        deleteFiles,
        moveIntermediateFiles
      };
    }
    module2.exports = NumberedFileOps;
  }
});

// node_modules/strftime/strftime.js
var require_strftime = __commonJS({
  "node_modules/strftime/strftime.js"(exports2, module2) {
    (function() {
      var Locales = {
        de_DE: {
          days: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
          shortDays: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          months: ["Januar", "Februar", "M\xE4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
          shortMonths: ["Jan", "Feb", "M\xE4r", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
          AM: "AM",
          PM: "PM",
          am: "am",
          pm: "pm",
          formats: {
            c: "%a %d %b %Y %X %Z",
            D: "%d.%m.%Y",
            F: "%Y-%m-%d",
            R: "%H:%M",
            r: "%I:%M:%S %p",
            T: "%H:%M:%S",
            v: "%e-%b-%Y",
            X: "%T",
            x: "%D"
          }
        },
        en_CA: {
          days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
          shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          ordinalSuffixes: [
            "st",
            "nd",
            "rd",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "st",
            "nd",
            "rd",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "st"
          ],
          AM: "AM",
          PM: "PM",
          am: "am",
          pm: "pm",
          formats: {
            c: "%a %d %b %Y %X %Z",
            D: "%d/%m/%y",
            F: "%Y-%m-%d",
            R: "%H:%M",
            r: "%I:%M:%S %p",
            T: "%H:%M:%S",
            v: "%e-%b-%Y",
            X: "%r",
            x: "%D"
          }
        },
        en_US: {
          days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
          shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          ordinalSuffixes: [
            "st",
            "nd",
            "rd",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "st",
            "nd",
            "rd",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "th",
            "st"
          ],
          AM: "AM",
          PM: "PM",
          am: "am",
          pm: "pm",
          formats: {
            c: "%a %d %b %Y %X %Z",
            D: "%m/%d/%y",
            F: "%Y-%m-%d",
            R: "%H:%M",
            r: "%I:%M:%S %p",
            T: "%H:%M:%S",
            v: "%e-%b-%Y",
            X: "%r",
            x: "%D"
          }
        },
        es_MX: {
          days: ["domingo", "lunes", "martes", "mi\xE9rcoles", "jueves", "viernes", "s\xE1bado"],
          shortDays: ["dom", "lun", "mar", "mi\xE9", "jue", "vie", "s\xE1b"],
          months: ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", " diciembre"],
          shortMonths: ["ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic"],
          AM: "AM",
          PM: "PM",
          am: "am",
          pm: "pm",
          formats: {
            c: "%a %d %b %Y %X %Z",
            D: "%d/%m/%Y",
            F: "%Y-%m-%d",
            R: "%H:%M",
            r: "%I:%M:%S %p",
            T: "%H:%M:%S",
            v: "%e-%b-%Y",
            X: "%T",
            x: "%D"
          }
        },
        fr_FR: {
          days: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
          shortDays: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
          months: ["janvier", "f\xE9vrier", "mars", "avril", "mai", "juin", "juillet", "ao\xFBt", "septembre", "octobre", "novembre", "d\xE9cembre"],
          shortMonths: ["janv.", "f\xE9vr.", "mars", "avril", "mai", "juin", "juil.", "ao\xFBt", "sept.", "oct.", "nov.", "d\xE9c."],
          AM: "AM",
          PM: "PM",
          am: "am",
          pm: "pm",
          formats: {
            c: "%a %d %b %Y %X %Z",
            D: "%d/%m/%Y",
            F: "%Y-%m-%d",
            R: "%H:%M",
            r: "%I:%M:%S %p",
            T: "%H:%M:%S",
            v: "%e-%b-%Y",
            X: "%T",
            x: "%D"
          }
        },
        it_IT: {
          days: ["domenica", "luned\xEC", "marted\xEC", "mercoled\xEC", "gioved\xEC", "venerd\xEC", "sabato"],
          shortDays: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
          months: ["gennaio", "febbraio", "marzo", "aprile", "maggio", "giugno", "luglio", "agosto", "settembre", "ottobre", "novembre", "dicembre"],
          shortMonths: ["pr", "mag", "giu", "lug", "ago", "set", "ott", "nov", "dic"],
          AM: "AM",
          PM: "PM",
          am: "am",
          pm: "pm",
          formats: {
            c: "%a %d %b %Y %X %Z",
            D: "%d/%m/%Y",
            F: "%Y-%m-%d",
            R: "%H:%M",
            r: "%I:%M:%S %p",
            T: "%H:%M:%S",
            v: "%e-%b-%Y",
            X: "%T",
            x: "%D"
          }
        },
        nl_NL: {
          days: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"],
          shortDays: ["zo", "ma", "di", "wo", "do", "vr", "za"],
          months: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
          shortMonths: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec"],
          AM: "AM",
          PM: "PM",
          am: "am",
          pm: "pm",
          formats: {
            c: "%a %d %b %Y %X %Z",
            D: "%d-%m-%y",
            F: "%Y-%m-%d",
            R: "%H:%M",
            r: "%I:%M:%S %p",
            T: "%H:%M:%S",
            v: "%e-%b-%Y",
            X: "%T",
            x: "%D"
          }
        },
        pt_BR: {
          days: ["domingo", "segunda", "ter\xE7a", "quarta", "quinta", "sexta", "s\xE1bado"],
          shortDays: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S\xE1b"],
          months: ["janeiro", "fevereiro", "mar\xE7o", "abril", "maio", "junho", "julho", "agosto", "setembro", "outubro", "novembro", "dezembro"],
          shortMonths: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
          AM: "AM",
          PM: "PM",
          am: "am",
          pm: "pm",
          formats: {
            c: "%a %d %b %Y %X %Z",
            D: "%d-%m-%Y",
            F: "%Y-%m-%d",
            R: "%H:%M",
            r: "%I:%M:%S %p",
            T: "%H:%M:%S",
            v: "%e-%b-%Y",
            X: "%T",
            x: "%D"
          }
        },
        ru_RU: {
          days: ["\u0412\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435", "\u041F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A", "\u0412\u0442\u043E\u0440\u043D\u0438\u043A", "\u0421\u0440\u0435\u0434\u0430", "\u0427\u0435\u0442\u0432\u0435\u0440\u0433", "\u041F\u044F\u0442\u043D\u0438\u0446\u0430", "\u0421\u0443\u0431\u0431\u043E\u0442\u0430"],
          shortDays: ["\u0412\u0441", "\u041F\u043D", "\u0412\u0442", "\u0421\u0440", "\u0427\u0442", "\u041F\u0442", "\u0421\u0431"],
          months: ["\u042F\u043D\u0432\u0430\u0440\u044C", "\u0424\u0435\u0432\u0440\u0430\u043B\u044C", "\u041C\u0430\u0440\u0442", "\u0410\u043F\u0440\u0435\u043B\u044C", "\u041C\u0430\u0439", "\u0418\u044E\u043D\u044C", "\u0418\u044E\u043B\u044C", "\u0410\u0432\u0433\u0443\u0441\u0442", "\u0421\u0435\u043D\u0442\u044F\u0431\u0440\u044C", "\u041E\u043A\u0442\u044F\u0431\u0440\u044C", "\u041D\u043E\u044F\u0431\u0440\u044C", "\u0414\u0435\u043A\u0430\u0431\u0440\u044C"],
          shortMonths: ["\u044F\u043D\u0432", "\u0444\u0435\u0432", "\u043C\u0430\u0440", "\u0430\u043F\u0440", "\u043C\u0430\u0439", "\u0438\u044E\u043D", "\u0438\u044E\u043B", "\u0430\u0432\u0433", "\u0441\u0435\u043D", "\u043E\u043A\u0442", "\u043D\u043E\u044F", "\u0434\u0435\u043A"],
          AM: "AM",
          PM: "PM",
          am: "am",
          pm: "pm",
          formats: {
            c: "%a %d %b %Y %X",
            D: "%d.%m.%y",
            F: "%Y-%m-%d",
            R: "%H:%M",
            r: "%I:%M:%S %p",
            T: "%H:%M:%S",
            v: "%e-%b-%Y",
            X: "%T",
            x: "%D"
          }
        },
        tr_TR: {
          days: ["Pazar", "Pazartesi", "Sal\u0131", "\xC7ar\u015Famba", "Per\u015Fembe", "Cuma", "Cumartesi"],
          shortDays: ["Paz", "Pzt", "Sal", "\xC7r\u015F", "Pr\u015F", "Cum", "Cts"],
          months: ["Ocak", "\u015Eubat", "Mart", "Nisan", "May\u0131s", "Haziran", "Temmuz", "A\u011Fustos", "Eyl\xFCl", "Ekim", "Kas\u0131m", "Aral\u0131k"],
          shortMonths: ["Oca", "\u015Eub", "Mar", "Nis", "May", "Haz", "Tem", "A\u011Fu", "Eyl", "Eki", "Kas", "Ara"],
          AM: "\xD6\xD6",
          PM: "\xD6S",
          am: "\xD6\xD6",
          pm: "\xD6S",
          formats: {
            c: "%a %d %b %Y %X %Z",
            D: "%d-%m-%Y",
            F: "%Y-%m-%d",
            R: "%H:%M",
            r: "%I:%M:%S %p",
            T: "%H:%M:%S",
            v: "%e-%b-%Y",
            X: "%T",
            x: "%D"
          }
        },
        zh_CN: {
          days: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"],
          shortDays: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
          months: ["\u4E00\u6708\u4EFD", "\u4E8C\u6708\u4EFD", "\u4E09\u6708\u4EFD", "\u56DB\u6708\u4EFD", "\u4E94\u6708\u4EFD", "\u516D\u6708\u4EFD", "\u4E03\u6708\u4EFD", "\u516B\u6708\u4EFD", "\u4E5D\u6708\u4EFD", "\u5341\u6708\u4EFD", "\u5341\u4E00\u6708\u4EFD", "\u5341\u4E8C\u6708\u4EFD"],
          shortMonths: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"],
          AM: "\u4E0A\u5348",
          PM: "\u4E0B\u5348",
          am: "\u4E0A\u5348",
          pm: "\u4E0B\u5348",
          formats: {
            c: "%a %d %b %Y %X %Z",
            D: "%d/%m/%y",
            F: "%Y-%m-%d",
            R: "%H:%M",
            r: "%I:%M:%S %p",
            T: "%H:%M:%S",
            v: "%e-%b-%Y",
            X: "%r",
            x: "%D"
          }
        }
      };
      var DefaultLocale = Locales["en_US"], defaultStrftime = new Strftime(DefaultLocale, 0, false), isCommonJS = typeof module2 !== "undefined", namespace;
      if (isCommonJS) {
        namespace = module2.exports = defaultStrftime;
      } else {
        namespace = function() {
          return this || (1, eval)("this");
        }();
        namespace.strftime = defaultStrftime;
      }
      if (typeof Date.now !== "function") {
        Date.now = function() {
          return +new Date();
        };
      }
      function Strftime(locale2, customTimezoneOffset, useUtcTimezone) {
        var _locale = locale2 || DefaultLocale, _customTimezoneOffset = customTimezoneOffset || 0, _useUtcBasedDate = useUtcTimezone || false, _cachedDateTimestamp = 0, _cachedDate;
        function _strftime(format2, date) {
          var timestamp;
          if (!date) {
            var currentTimestamp = Date.now();
            if (currentTimestamp > _cachedDateTimestamp) {
              _cachedDateTimestamp = currentTimestamp;
              _cachedDate = new Date(_cachedDateTimestamp);
              timestamp = _cachedDateTimestamp;
              if (_useUtcBasedDate) {
                _cachedDate = new Date(_cachedDateTimestamp + getTimestampToUtcOffsetFor(_cachedDate) + _customTimezoneOffset);
              }
            } else {
              timestamp = _cachedDateTimestamp;
            }
            date = _cachedDate;
          } else {
            timestamp = date.getTime();
            if (_useUtcBasedDate) {
              var utcOffset = getTimestampToUtcOffsetFor(date);
              date = new Date(timestamp + utcOffset + _customTimezoneOffset);
              if (getTimestampToUtcOffsetFor(date) !== utcOffset) {
                var newUTCOffset = getTimestampToUtcOffsetFor(date);
                date = new Date(timestamp + newUTCOffset + _customTimezoneOffset);
              }
            }
          }
          return _processFormat(format2, date, _locale, timestamp);
        }
        function _processFormat(format2, date, locale3, timestamp) {
          var resultString = "", padding = null, isInScope = false, length = format2.length, extendedTZ = false;
          for (var i = 0; i < length; i++) {
            var currentCharCode = format2.charCodeAt(i);
            if (isInScope === true) {
              if (currentCharCode === 45) {
                padding = "";
                continue;
              } else if (currentCharCode === 95) {
                padding = " ";
                continue;
              } else if (currentCharCode === 48) {
                padding = "0";
                continue;
              } else if (currentCharCode === 58) {
                if (extendedTZ) {
                  warn("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime");
                }
                extendedTZ = true;
                continue;
              }
              switch (currentCharCode) {
                case 37:
                  resultString += "%";
                  break;
                case 65:
                  resultString += locale3.days[date.getDay()];
                  break;
                case 66:
                  resultString += locale3.months[date.getMonth()];
                  break;
                case 67:
                  resultString += padTill2(Math.floor(date.getFullYear() / 100), padding);
                  break;
                case 68:
                  resultString += _processFormat(locale3.formats.D, date, locale3, timestamp);
                  break;
                case 70:
                  resultString += _processFormat(locale3.formats.F, date, locale3, timestamp);
                  break;
                case 72:
                  resultString += padTill2(date.getHours(), padding);
                  break;
                case 73:
                  resultString += padTill2(hours12(date.getHours()), padding);
                  break;
                case 76:
                  resultString += padTill3(Math.floor(timestamp % 1e3));
                  break;
                case 77:
                  resultString += padTill2(date.getMinutes(), padding);
                  break;
                case 80:
                  resultString += date.getHours() < 12 ? locale3.am : locale3.pm;
                  break;
                case 82:
                  resultString += _processFormat(locale3.formats.R, date, locale3, timestamp);
                  break;
                case 83:
                  resultString += padTill2(date.getSeconds(), padding);
                  break;
                case 84:
                  resultString += _processFormat(locale3.formats.T, date, locale3, timestamp);
                  break;
                case 85:
                  resultString += padTill2(weekNumber(date, "sunday"), padding);
                  break;
                case 87:
                  resultString += padTill2(weekNumber(date, "monday"), padding);
                  break;
                case 88:
                  resultString += _processFormat(locale3.formats.X, date, locale3, timestamp);
                  break;
                case 89:
                  resultString += date.getFullYear();
                  break;
                case 90:
                  if (_useUtcBasedDate && _customTimezoneOffset === 0) {
                    resultString += "GMT";
                  } else {
                    var tzString = date.toString().match(/\(([\w\s]+)\)/);
                    resultString += tzString && tzString[1] || "";
                  }
                  break;
                case 97:
                  resultString += locale3.shortDays[date.getDay()];
                  break;
                case 98:
                  resultString += locale3.shortMonths[date.getMonth()];
                  break;
                case 99:
                  resultString += _processFormat(locale3.formats.c, date, locale3, timestamp);
                  break;
                case 100:
                  resultString += padTill2(date.getDate(), padding);
                  break;
                case 101:
                  resultString += padTill2(date.getDate(), padding == null ? " " : padding);
                  break;
                case 104:
                  resultString += locale3.shortMonths[date.getMonth()];
                  break;
                case 106:
                  var y = new Date(date.getFullYear(), 0, 1);
                  var day = Math.ceil((date.getTime() - y.getTime()) / (1e3 * 60 * 60 * 24));
                  resultString += padTill3(day);
                  break;
                case 107:
                  resultString += padTill2(date.getHours(), padding == null ? " " : padding);
                  break;
                case 108:
                  resultString += padTill2(hours12(date.getHours()), padding == null ? " " : padding);
                  break;
                case 109:
                  resultString += padTill2(date.getMonth() + 1, padding);
                  break;
                case 110:
                  resultString += "\n";
                  break;
                case 111:
                  var day = date.getDate();
                  if (locale3.ordinalSuffixes) {
                    resultString += String(day) + (locale3.ordinalSuffixes[day - 1] || ordinal(day));
                  } else {
                    resultString += String(day) + ordinal(day);
                  }
                  break;
                case 112:
                  resultString += date.getHours() < 12 ? locale3.AM : locale3.PM;
                  break;
                case 114:
                  resultString += _processFormat(locale3.formats.r, date, locale3, timestamp);
                  break;
                case 115:
                  resultString += Math.floor(timestamp / 1e3);
                  break;
                case 116:
                  resultString += "	";
                  break;
                case 117:
                  var day = date.getDay();
                  resultString += day === 0 ? 7 : day;
                  break;
                case 118:
                  resultString += _processFormat(locale3.formats.v, date, locale3, timestamp);
                  break;
                case 119:
                  resultString += date.getDay();
                  break;
                case 120:
                  resultString += _processFormat(locale3.formats.x, date, locale3, timestamp);
                  break;
                case 121:
                  resultString += ("" + date.getFullYear()).slice(2);
                  break;
                case 122:
                  if (_useUtcBasedDate && _customTimezoneOffset === 0) {
                    resultString += extendedTZ ? "+00:00" : "+0000";
                  } else {
                    var off;
                    if (_customTimezoneOffset !== 0) {
                      off = _customTimezoneOffset / (60 * 1e3);
                    } else {
                      off = -date.getTimezoneOffset();
                    }
                    var sign = off < 0 ? "-" : "+";
                    var sep = extendedTZ ? ":" : "";
                    var hours = Math.floor(Math.abs(off / 60));
                    var mins = Math.abs(off % 60);
                    resultString += sign + padTill2(hours) + sep + padTill2(mins);
                  }
                  break;
                default:
                  if (isInScope) {
                    resultString += "%";
                  }
                  resultString += format2[i];
                  break;
              }
              padding = null;
              isInScope = false;
              continue;
            }
            if (currentCharCode === 37) {
              isInScope = true;
              continue;
            }
            resultString += format2[i];
          }
          return resultString;
        }
        var strftime = _strftime;
        strftime.localize = function(locale3) {
          return new Strftime(locale3 || _locale, _customTimezoneOffset, _useUtcBasedDate);
        };
        strftime.localizeByIdentifier = function(localeIdentifier) {
          var locale3 = Locales[localeIdentifier];
          if (!locale3) {
            warn('[WARNING] No locale found with identifier "' + localeIdentifier + '".');
            return strftime;
          }
          return strftime.localize(locale3);
        };
        strftime.timezone = function(timezone) {
          var customTimezoneOffset2 = _customTimezoneOffset;
          var useUtcBasedDate = _useUtcBasedDate;
          var timezoneType = typeof timezone;
          if (timezoneType === "number" || timezoneType === "string") {
            useUtcBasedDate = true;
            if (timezoneType === "string") {
              var sign = timezone[0] === "-" ? -1 : 1, hours = parseInt(timezone.slice(1, 3), 10), minutes = parseInt(timezone.slice(3, 5), 10);
              customTimezoneOffset2 = sign * (60 * hours + minutes) * 60 * 1e3;
            } else if (timezoneType === "number") {
              customTimezoneOffset2 = timezone * 60 * 1e3;
            }
          }
          return new Strftime(_locale, customTimezoneOffset2, useUtcBasedDate);
        };
        strftime.utc = function() {
          return new Strftime(_locale, _customTimezoneOffset, true);
        };
        return strftime;
      }
      function padTill2(numberToPad, paddingChar) {
        if (paddingChar === "" || numberToPad > 9) {
          return numberToPad;
        }
        if (paddingChar == null) {
          paddingChar = "0";
        }
        return paddingChar + numberToPad;
      }
      function padTill3(numberToPad) {
        if (numberToPad > 99) {
          return numberToPad;
        }
        if (numberToPad > 9) {
          return "0" + numberToPad;
        }
        return "00" + numberToPad;
      }
      function hours12(hour) {
        if (hour === 0) {
          return 12;
        } else if (hour > 12) {
          return hour - 12;
        }
        return hour;
      }
      function weekNumber(date, firstWeekday) {
        firstWeekday = firstWeekday || "sunday";
        var weekday = date.getDay();
        if (firstWeekday === "monday") {
          if (weekday === 0)
            weekday = 6;
          else
            weekday--;
        }
        var firstDayOfYearUtc = Date.UTC(date.getFullYear(), 0, 1), dateUtc = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()), yday = Math.floor((dateUtc - firstDayOfYearUtc) / 864e5), weekNum = (yday + 7 - weekday) / 7;
        return Math.floor(weekNum);
      }
      function ordinal(number) {
        var i = number % 10;
        var ii = number % 100;
        if (ii >= 11 && ii <= 13 || i === 0 || i >= 4) {
          return "th";
        }
        switch (i) {
          case 1:
            return "st";
          case 2:
            return "nd";
          case 3:
            return "rd";
        }
      }
      function getTimestampToUtcOffsetFor(date) {
        return (date.getTimezoneOffset() || 0) * 6e4;
      }
      function warn(message) {
        if (typeof console !== "undefined" && typeof console.warn == "function") {
          console.warn(message);
        }
      }
    })();
  }
});

// node_modules/bunyan-rotating-file-stream/lib/datestampedfileops.js
var require_datestampedfileops = __commonJS({
  "node_modules/bunyan-rotating-file-stream/lib/datestampedfileops.js"(exports2, module2) {
    var fs = require("fs");
    var async = require_async2();
    var path = require("path");
    var strftime = require_strftime();
    var _ = require_lodash();
    function DateStampedFileOps(logpath, totalFiles, totalSize, gzip) {
      var filenameTimestamp = new Date();
      var nonce = 0;
      var parsedPath = path.parse(logpath);
      var reopenedFilePath = null;
      function getFilesInLogDirectory(next) {
        fs.readdir(path.resolve(parsedPath.dir), function(err, files) {
          if (err)
            throw err;
          next(null, files);
        });
      }
      function removeN(originalName) {
        return originalName.replace(".%N", "").replace("_%N", "").replace("-%N", "").replace("%N", "");
      }
      function filterJustOurLogFiles(includeZipFiles) {
        return function(files, next) {
          var logfiles = _.filter(files, function(file) {
            var parsedFile = path.parse(path.resolve(path.join(parsedPath.dir, file)));
            var prefixes = [];
            var parts = parsedPath.name.split("%");
            prefixes.push(parts.slice(0, 1).join(""));
            if (parts.slice(1, 2).join("").slice(0, 1) === "N") {
              var altname = removeN(parsedPath.name);
              parts = altname.split("%");
              prefixes.push(parts.slice(0, 1).join(""));
            }
            if (includeZipFiles && parsedFile.ext === ".gz") {
              var splitname = parsedFile.name.split(".");
              parsedFile.ext = "." + splitname.slice(-1).join("");
              if (parsedFile.ext === ".") {
                parsedFile.ext === "";
              }
              parsedFile.name = splitname.slice(0, -1).join(".");
            }
            return _.some(prefixes, function(prefix) {
              return parsedFile.name.indexOf(prefix) === 0;
            }) && parsedFile.ext === parsedPath.ext;
          });
          next(null, logfiles);
        };
      }
      function statEachFile(logfiles, next) {
        async.map(logfiles, function(logfile, next2) {
          var fullpath = path.resolve(path.join(parsedPath.dir, logfile));
          fs.stat(fullpath, function(err, stat) {
            next2(err, {
              stat,
              path: fullpath
            });
          });
        }, function(err, stats) {
          next(err, stats);
        });
      }
      function filterUnstattedFiles(logstats, next) {
        filteredlogstats = logstats.filter((logstat) => logstat && logstat.stat && logstat.stat.mtime);
        next(null, filteredlogstats);
      }
      function sortFilesByModifiedTime(logstats, next) {
        async.sortBy(logstats, function(logstat, next2) {
          next2(null, -logstat?.stat?.mtime);
        }, next);
      }
      function deleteFilesAfterCountBreach(logstats, next) {
        var currentCount = 0;
        var toDelete = [];
        var toContinue = [];
        logstats.forEach(function(logstat) {
          currentCount += 1;
          if (totalFiles && currentCount > totalFiles) {
            toDelete.push(logstat);
          } else {
            toContinue.push(logstat);
          }
        });
        async.each(toDelete, function(logstat, next2) {
          fs.unlink(logstat.path, next2);
        }, function(err) {
          next(err, toContinue);
        });
      }
      function deleteFilesAfterSizeBreach(logstats, next) {
        var currentSize = 0;
        var toDelete = [];
        var toContinue = [];
        logstats.forEach(function(logstat) {
          currentSize += logstat.stat.size;
          if (totalSize && currentSize > totalSize) {
            toDelete.push(logstat);
          } else {
            toContinue.push(logstat);
          }
        });
        async.each(toDelete, function(logstat, next2) {
          fs.unlink(logstat.path, next2);
        }, function(err) {
          next(err, toContinue);
        });
      }
      function getSortedLogFiles(matchzippedfiles) {
        return function(next) {
          async.waterfall([
            getFilesInLogDirectory,
            filterJustOurLogFiles(matchzippedfiles),
            statEachFile,
            filterUnstattedFiles,
            sortFilesByModifiedTime
          ], function(err, logfiles) {
            next(err, logfiles);
          });
        };
      }
      function deleteFiles(next) {
        async.waterfall([
          getSortedLogFiles(true),
          deleteFilesAfterCountBreach,
          deleteFilesAfterSizeBreach
        ], function(err) {
          next(err);
        });
      }
      ;
      function moveIntermediateFiles(next) {
        process.nextTick(function() {
          next();
        });
      }
      ;
      function internalGetStreamFilepath(gzipped, nonce2) {
        var result;
        if (reopenedFilePath !== null) {
          result = path.parse(reopenedFilePath);
        } else {
          result = _.extend({}, parsedPath);
          if (nonce2 === 0) {
            result.name = removeN(result.name);
          } else if (result.name.indexOf("%N") >= 0) {
            result.name = result.name.replace("%N", String(nonce2));
          } else {
            result.name = result.name + "." + String(nonce2);
          }
          result.name = strftime(result.name, filenameTimestamp);
        }
        if (gzipped) {
          result.ext += ".gz";
        }
        result.base = result.name + result.ext;
        return path.resolve(path.format(result));
      }
      function getStreamFilepath(gzipped) {
        return internalGetStreamFilepath(gzipped, nonce);
      }
      function findUnusedFile(nonce2, next) {
        var filepath = internalGetStreamFilepath(false, nonce2);
        var filepathgz = internalGetStreamFilepath(true, nonce2);
        async.each([
          filepath,
          filepathgz
        ], function(potentialpath, pathresult) {
          fs.stat(potentialpath, function(err, stats) {
            if (err && err.code === "ENOENT") {
              pathresult();
            } else if (err) {
              pathresult(err);
            } else {
              pathresult("inuse");
            }
          });
        }, function(err) {
          if (err && err === "inuse") {
            findUnusedFile(nonce2 + 1, next);
          } else if (err) {
            next(err);
          } else {
            fs.open(filepath, "wx", function(err2, fd) {
              if (err2 && err2.code === "EEXIST") {
                findUnusedFile(nonce2 + 1, next);
              } else if (err2) {
                return next(err2);
              } else {
                fs.close(fd, function() {
                  next(null, filepath, nonce2);
                });
              }
            });
          }
        });
      }
      function createNewFile(next) {
        reopenedFilePath = null;
        findUnusedFile(0, function(err, filepath, foundnonce) {
          nonce = foundnonce || 0;
          next(err, filepath);
        });
      }
      function newStreamFilepath(triggerinfo, next) {
        filenameTimestamp = new Date(triggerinfo.date || Date.now());
        var startNewFile = !triggerinfo.hasOwnProperty("startNewFile") || triggerinfo.startNewFile;
        if (startNewFile) {
          createNewFile(next);
        } else {
          getSortedLogFiles(false)(function(err, logfiles) {
            if (err) {
              return next(err);
            }
            if (logfiles.length === 0) {
              return createNewFile(next);
            } else {
              reopenedFilePath = logfiles[0].path;
              next(null, reopenedFilePath);
            }
          });
        }
      }
      return {
        getStreamFilepath,
        newStreamFilepath,
        deleteFiles,
        moveIntermediateFiles
      };
    }
    DateStampedFileOps.isDateStamped = function(logpath) {
      var parsed = path.parse(logpath);
      var withoutN = parsed.name.replace("%N", "");
      return withoutN !== strftime(withoutN);
    };
    module2.exports = DateStampedFileOps;
  }
});

// node_modules/bunyan-rotating-file-stream/lib/filerotator.js
var require_filerotator = __commonJS({
  "node_modules/bunyan-rotating-file-stream/lib/filerotator.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var async = require_async2();
    var _ = require_lodash();
    var zlib = require("zlib");
    var EventEmitter2 = require("events").EventEmitter;
    var NumberedFileOps = require_numberedfileops();
    var DateStampedFileOps = require_datestampedfileops();
    function FileRotator(logpath, totalFiles, totalSize, gzip) {
      var base = new EventEmitter2();
      var stream;
      var streamPath;
      var fileops = null;
      if (DateStampedFileOps.isDateStamped(logpath)) {
        fileops = DateStampedFileOps(logpath, totalFiles, totalSize, gzip);
      } else {
        fileops = NumberedFileOps(logpath, totalFiles, totalSize, gzip);
      }
      function gzipCurrentFile(next) {
        if (!gzip) {
          return next();
        }
        var unzippedPath = fileops.getStreamFilepath(false);
        var zippedPath = fileops.getStreamFilepath(true);
        fs.createReadStream(unzippedPath).on("error", function(err) {
          base.emit("error", err);
          next();
        }).pipe(zlib.createGzip()).pipe(fs.createWriteStream(zippedPath)).on("close", function() {
          fs.unlink(unzippedPath, () => {
            base.emit("gzip_finish", zippedPath);
            next();
          });
        });
      }
      function streamErrorHandler(err) {
        base.emit("error", err);
      }
      ;
      function initialiseNewFile(triggerinfo) {
        return function(next) {
          triggerinfo = triggerinfo || {};
          fileops.newStreamFilepath(triggerinfo, function(err, filePath) {
            if (err) {
              return next(err);
            }
            stream = fs.createWriteStream(filePath, { flags: "a", encoding: "utf8" });
            streamPath = filePath;
            stream.on("error", streamErrorHandler);
            stream.once("open", function() {
              fs.stat(filePath, function(err2, stats) {
                if (err2) {
                  base.emit("error", err2);
                } else {
                  base.emit("newfile", {
                    stream,
                    logpath: streamPath,
                    stats
                  });
                }
                if (next) {
                  next();
                }
              });
            });
          });
        };
      }
      function shutdownCurrentStream(next) {
        base.emit("closefile");
        if (stream) {
          var streamCopy = stream;
          stream.end(function() {
            streamCopy.removeListener("error", streamErrorHandler);
            if (next) {
              next();
            }
          });
          stream = null;
        }
      }
      ;
      function rotate(triggerinfo, callback) {
        async.series([
          shutdownCurrentStream,
          gzipCurrentFile,
          fileops.moveIntermediateFiles,
          fileops.deleteFiles,
          initialiseNewFile(triggerinfo)
        ], function(err) {
          callback(err, stream, streamPath);
        });
      }
      var initialised = false;
      function initialise(startNewFile, callback) {
        if (!initialised) {
          initialised = true;
          async.series([
            fileops.deleteFiles,
            initialiseNewFile({ startNewFile })
          ], function(err) {
            callback(err, stream, streamPath);
          });
        } else {
          callback();
        }
      }
      return _.extend({}, {
        initialise,
        rotate,
        end: shutdownCurrentStream
      }, base);
    }
    module2.exports = FileRotator;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/internal/constants.js
var require_constants2 = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/internal/re.js"(exports2, module2) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants2();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug(index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
      options2[k] = true;
      return options2;
    }, {});
    module2.exports = parseOptions;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/parse.js"(exports2, module2) {
    var { MAX_LENGTH } = require_constants2();
    var { re, t } = require_re();
    var SemVer = require_semver();
    var parseOptions = require_parse_options();
    var parse = (version, options) => {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      const r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse = require_parse();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse = require_parse();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version, release, options, identifier) => {
      if (typeof options === "string") {
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(version, options).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse = require_parse();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v1 = parse(version1);
        const v2 = parse(version2);
        const hasPre = v1.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module2.exports = diff;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match2 = null;
      if (!options.rtl) {
        match2 = version.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match2 || match2.index + match2[0].length !== version.length)) {
          if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
            match2 = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match2 === null)
        return null;
      return parse(`${match2[2]}.${match2[3] || "0"}.${match2[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/classes/range.js"(exports2, module2) {
    var Range = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range;
        this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0)
            this.set = [first];
          else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        range = range.trim();
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range}`;
        const cached = cache.get(memoKey);
        if (cached)
          return cached;
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range, re[t.COMPARATORTRIM]);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
        const l = rangeList.length;
        const rangeMap = /* @__PURE__ */ new Map();
        for (const comp of rangeList) {
          if (isNullSet(comp))
            return [comp];
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has(""))
          rangeMap.delete("");
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceTilde(comp2, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceCaret(comp2, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((comp2) => {
        return replaceXRange(comp2, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<")
            pr = "-0";
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin)))
          minver = setMin;
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    };
    module2.exports = intersects;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let min = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!min)
            min = version;
        } else {
          if (prev) {
            set.push([min, prev]);
          }
          prev = null;
          min = null;
        }
      }
      if (min)
        set.push([min, null]);
      const ranges = [];
      for (const [min2, max] of set) {
        if (min2 === max)
          ranges.push(min2);
        else if (!max && min2 === v[0])
          ranges.push("*");
        else if (!max)
          ranges.push(`>=${min2}`);
        else if (min2 === v[0])
          ranges.push(`<=${max}`);
        else
          ranges.push(`${min2} - ${max}`);
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom)
        return true;
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub)
              continue OUTER;
          }
          if (sawNonNull)
            return false;
        }
      return true;
    };
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom)
        return true;
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY)
          return true;
        else if (options.includePrerelease)
          sub = [new Comparator(">=0.0.0-0")];
        else
          sub = [new Comparator(">=0.0.0")];
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease)
          return true;
        else
          dom = [new Comparator(">=0.0.0")];
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=")
          gt = higherGT(gt, c, options);
        else if (c.operator === "<" || c.operator === "<=")
          lt = lowerLT(lt, c, options);
        else
          eqSet.add(c.semver);
      }
      if (eqSet.size > 1)
        return null;
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0)
          return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
          return null;
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options))
          return null;
        if (lt && !satisfies(eq, String(lt), options))
          return null;
        for (const c of dom) {
          if (!satisfies(eq, String(c), options))
            return false;
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt)
              return false;
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
            return false;
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt)
              return false;
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
            return false;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0)
          return false;
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0)
        return false;
      if (lt && hasDomGT && !gt && gtltComp !== 0)
        return false;
      if (needDomGTPre || needDomLTPre)
        return false;
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/bunyan-rotating-file-stream/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/bunyan-rotating-file-stream/node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    module2.exports = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: require_constants2().SEMVER_SPEC_VERSION,
      SemVer: require_semver(),
      compareIdentifiers: require_identifiers().compareIdentifiers,
      rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
      parse: require_parse(),
      valid: require_valid(),
      clean: require_clean(),
      inc: require_inc(),
      diff: require_diff(),
      major: require_major(),
      minor: require_minor(),
      patch: require_patch(),
      prerelease: require_prerelease(),
      compare: require_compare(),
      rcompare: require_rcompare(),
      compareLoose: require_compare_loose(),
      compareBuild: require_compare_build(),
      sort: require_sort(),
      rsort: require_rsort(),
      gt: require_gt(),
      lt: require_lt(),
      eq: require_eq(),
      neq: require_neq(),
      gte: require_gte(),
      lte: require_lte(),
      cmp: require_cmp(),
      coerce: require_coerce(),
      Comparator: require_comparator(),
      Range: require_range(),
      satisfies: require_satisfies(),
      toComparators: require_to_comparators(),
      maxSatisfying: require_max_satisfying(),
      minSatisfying: require_min_satisfying(),
      minVersion: require_min_version(),
      validRange: require_valid2(),
      outside: require_outside(),
      gtr: require_gtr(),
      ltr: require_ltr(),
      intersects: require_intersects(),
      simplifyRange: require_simplify(),
      subset: require_subset()
    };
  }
});

// node_modules/bunyan-rotating-file-stream/lib/rotatingfilestream.js
var require_rotatingfilestream = __commonJS({
  "node_modules/bunyan-rotating-file-stream/lib/rotatingfilestream.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events").EventEmitter;
    var fs = require("fs");
    var iopath = require("path");
    var async = require_async2();
    var _ = require_lodash();
    var optionParser = require_optionParser();
    var LimitedQueue = require_limitedqueue();
    var FileRotator = require_filerotator();
    var semver = require_semver2();
    var nextTick = semver.gt(process.version, "5.0.0") ? setImmediate : function(next) {
      setTimeout(next, 0);
    };
    function RotatingFileStream2(options) {
      var base = new EventEmitter2();
      var gzip = Boolean(options.gzip);
      var totalSize = optionParser.parseSize(options.totalSize);
      var totalFiles = options.totalFiles;
      var path = options.path;
      var shared = options.shared;
      var rotator = FileRotator(path, totalFiles, totalSize, gzip);
      var stream = null;
      var streambytesWritten = 0;
      function safeCycles() {
        var seen = [];
        return function(key, val) {
          if (!val || typeof val !== "object") {
            return val;
          }
          if (seen.indexOf(val) !== -1) {
            return "[Circular]";
          }
          seen.push(val);
          return val;
        };
      }
      function nullJsonify(textlog) {
        return textlog;
      }
      function fastJsonify(rawlog) {
        return JSON.stringify(rawlog, safeCycles()) + "\n";
      }
      function fastUnsafeJsonify(rawlog) {
        return JSON.stringify(rawlog) + "\n";
      }
      function orderedJsonify(rawlog) {
        var log2 = {};
        var fo = options.fieldOrder;
        for (var sortIndex = 0; fo && sortIndex < fo.length; sortIndex += 1) {
          if (rawlog.hasOwnProperty(options.fieldOrder[sortIndex])) {
            log2[fo[sortIndex]] = rawlog[fo[sortIndex]];
          }
        }
        for (var k in rawlog) {
          log2[k] = rawlog[k];
        }
        return JSON.stringify(log2, safeCycles()) + "\n";
      }
      function chooseJsonify(log2) {
        if (typeof log2 === "string" && options.fieldOrder) {
          base.emit("error", 'Can only set fieldOrder with the stream set to "raw"');
        }
        if (typeof log2 === "string") {
          jsonify = nullJsonify;
        } else if (options.fieldOrder) {
          jsonify = orderedJsonify;
        } else if (options.noCyclesCheck) {
          jsonify = fastUnsafeJsonify;
        } else {
          jsonify = fastJsonify;
        }
        return jsonify(log2);
      }
      ;
      var jsonify = chooseJsonify;
      options.map = options.map || function(log2) {
        return log2;
      };
      function writer(logs, callback) {
        var written = -1;
        var bytesWritten = 0;
        for (var i = 0; stream && i < logs.length; i += 1) {
          var log2 = options.map(logs[i]);
          if (log2) {
            var str = jsonify(log2);
            var writeBuffer = new Buffer.from(str, "utf8");
            var emitinfo = {
              logSize: writeBuffer.length,
              logstr: str
            };
            base.emit("logwrite", emitinfo);
            bytesWritten += writeBuffer.length;
            if (stream) {
              try {
                stream.write(writeBuffer, function(err) {
                  if (err) {
                    base.emit("error", err);
                  }
                });
              } catch (err) {
                base.emit("error", err);
              }
              written = i;
            }
          }
        }
        for (var rollback = logs.length - 1; rollback > written; rollback -= 1) {
          writeQueue.unshift(logs[rollback]);
        }
        nextTick(callback);
        base.emit("perf-writebatch", bytesWritten, written + 1, writeQueue.length());
      }
      var writeQueue = LimitedQueue(writer);
      writeQueue.pause();
      writeQueue.on("losingdata", function() {
        base.emit("losingdata");
      });
      writeQueue.on("caughtup", function() {
        base.emit("caughtup");
      });
      rotator.on("error", function(err) {
        base.emit("error", err);
      });
      rotator.on("closefile", function() {
        writeQueue.pause();
        stream = null;
      });
      rotator.on("newfile", function(newfile) {
        stream = newfile.stream;
        streambytesWritten = 0;
        base.emit("newfile", newfile);
        writeQueue.resume();
      });
      rotator.on("gzip_finish", function(zippedPath) {
        base.emit("gzip_finish", zippedPath);
      });
      function initialise() {
        rotator.initialise(options.startNewFile, function(err) {
          if (err) {
            base.emit("error", err);
          }
        });
      }
      function rotateActual(triggerinfo) {
        var rotateStart = Date.now();
        rotateFunction = function() {
        };
        rotator.rotate(triggerinfo, function(err) {
          if (err) {
            base.emit("error", err);
          }
          rotateFunction = rotateActual;
          base.emit("perf-rotation", Date.now() - rotateStart);
        });
      }
      var rotateFunction = rotateActual;
      function rotate(triggerinfo) {
        rotateFunction(triggerinfo);
      }
      function write(s, callback) {
        var length = writeQueue.push(s, callback);
        base.emit("perf-queued", length);
      }
      function end(s) {
        writeQueue.pause();
        rotator.end(function() {
          base.emit("shutdown");
        });
      }
      ;
      function destroy(s) {
        writeQueue.pause();
        rotator.end();
        base.emit("shutdown");
      }
      ;
      function destroySoon(s) {
        writeQueue.pause();
        rotator.end();
        base.emit("shutdown");
      }
      ;
      function join(cb) {
        writeQueue.join(function() {
          rotator.end(function() {
            base.emit("shutdown");
            if (cb) {
              cb();
            }
          });
        });
      }
      return _.extend({}, {
        stream,
        initialise,
        rotate,
        write,
        end,
        destroy,
        destroySoon,
        join,
        shared
      }, base);
    }
    module2.exports = RotatingFileStream2;
  }
});

// node_modules/bunyan-rotating-file-stream/lib/nextrotationtime.js
var require_nextrotationtime = __commonJS({
  "node_modules/bunyan-rotating-file-stream/lib/nextrotationtime.js"(exports2, module2) {
    "use strict";
    var _DEBUG = false;
    var assert = require("assert");
    function nextRotTime(rotAt, periodScope, periodNum) {
      if (_DEBUG)
        console.log("-- _nextRotTime: %s%s", periodNum, periodScope);
      var d = new Date();
      if (_DEBUG)
        console.log("  now local: %s", d);
      if (_DEBUG)
        console.log("    now utc: %s", d.toISOString());
      var newRotAt;
      switch (periodScope) {
        case "ms":
          if (rotAt) {
            newRotAt = rotAt + periodNum;
          } else {
            newRotAt = Date.now() + periodNum;
          }
          break;
        case "h":
          if (rotAt) {
            newRotAt = rotAt + periodNum * 60 * 60 * 1e3;
          } else {
            newRotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours() + 1);
          }
          break;
        case "d":
          if (rotAt) {
            newRotAt = rotAt + periodNum * 24 * 60 * 60 * 1e3;
          } else {
            newRotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate() + 1);
          }
          break;
        case "w":
          if (rotAt) {
            newRotAt = rotAt + periodNum * 7 * 24 * 60 * 60 * 1e3;
          } else {
            newRotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate() + (7 - d.getUTCDay()));
          }
          break;
        case "m":
          if (rotAt) {
            newRotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth() + periodNum, 1);
          } else {
            newRotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth() + 1, 1);
          }
          break;
        case "y":
          if (rotAt) {
            newRotAt = Date.UTC(d.getUTCFullYear() + periodNum, 0, 1);
          } else {
            newRotAt = Date.UTC(d.getUTCFullYear() + 1, 0, 1);
          }
          break;
        default:
          assert.fail('invalid period scope: "' + periodScope + '"');
      }
      if (_DEBUG) {
        console.log("  **rotAt**: %s (utc: %s)", newRotAt, new Date(rotAt).toUTCString());
        var now = Date.now();
        console.log("        now: %s (%sms == %smin == %sh to go)", now, newRotAt - now, (newRotAt - now) / 1e3 / 60, (newRotAt - now) / 1e3 / 60 / 60);
      }
      return newRotAt;
    }
    module2.exports = nextRotTime;
  }
});

// node_modules/bunyan-rotating-file-stream/lib/setlongtimeout.js
var require_setlongtimeout = __commonJS({
  "node_modules/bunyan-rotating-file-stream/lib/setlongtimeout.js"(exports2, module2) {
    "use strict";
    function setLongTimeout(triggerTime, keepAlive, callback, maxTimeout) {
      var timeout = null;
      var TIMEOUT_MAX = maxTimeout || 2147483647;
      function doSleep() {
        var delay = triggerTime - Date.now();
        if (delay > TIMEOUT_MAX) {
          delay = TIMEOUT_MAX;
        }
        if (delay <= 0) {
          callback();
          return;
        }
        timeout = setTimeout(function() {
          timeout = null;
          if (triggerTime && triggerTime > Date.now()) {
            doSleep();
          } else {
            callback();
          }
        }, delay);
        if (!keepAlive && typeof timeout.unref === "function") {
          timeout.unref();
        }
      }
      function clear() {
        if (timeout) {
          clearTimeout(timeout);
        }
      }
      doSleep();
      return { clear };
    }
    module2.exports = setLongTimeout;
  }
});

// node_modules/bunyan-rotating-file-stream/lib/periodtrigger.js
var require_periodtrigger = __commonJS({
  "node_modules/bunyan-rotating-file-stream/lib/periodtrigger.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var EventEmitter2 = require("events").EventEmitter;
    var _ = require_lodash();
    var optionParser = require_optionParser();
    var nextRotTime = require_nextrotationtime();
    var setLongTimeout = require_setlongtimeout();
    function PeriodRotateTrigger(options) {
      var base = new EventEmitter2();
      var periodNum = 1;
      var periodScope = "d";
      var rotAt = null;
      var timeout = null;
      function setupNextRotation() {
        if (rotAt <= Date.now()) {
          rotAt = nextRotTime(rotAt, periodScope, periodNum);
        }
        timeout = setLongTimeout(rotAt, false, function() {
          timeout = null;
          base.emit("rotate", { date: rotAt });
        });
      }
      function shutdown() {
        if (timeout) {
          timeout.clear();
        }
        timeout = null;
      }
      function newFile() {
        if (timeout) {
          timeout.clear();
        }
        setupNextRotation();
      }
      function logWrite() {
      }
      var parsed = optionParser.parsePeriod(options.period);
      periodScope = parsed.periodScope;
      periodNum = parsed.periodNum;
      setupNextRotation();
      return _.extend({}, {
        newFile,
        logWrite,
        shutdown
      }, base);
    }
    module2.exports = PeriodRotateTrigger;
  }
});

// node_modules/bunyan-rotating-file-stream/lib/initialperiodtrigger.js
var require_initialperiodtrigger = __commonJS({
  "node_modules/bunyan-rotating-file-stream/lib/initialperiodtrigger.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var EventEmitter2 = require("events").EventEmitter;
    var _ = require_lodash();
    var fs = require("fs");
    var optionParser = require_optionParser();
    var nextRotTime = require_nextrotationtime();
    function InitialPeriodRotateTrigger(options) {
      var base = new EventEmitter2();
      var periodNum = 1;
      var periodScope = "d";
      var rotatingoldfiles = true;
      function shutdown() {
      }
      function checkIfRotationNeeded(birthtime, now) {
        var nextRot = birthtime;
        var lastRot = birthtime;
        while (nextRot < now) {
          lastRot = nextRot;
          nextRot = nextRotTime(lastRot, periodScope, periodNum);
        }
        return { needsRotation: lastRot != birthtime, rotateTo: lastRot };
      }
      function newFile(data) {
        if (rotatingoldfiles) {
          rotatingoldfiles = false;
          var rotation = checkIfRotationNeeded(data.stats.birthtime.getTime(), new Date().getTime());
          if (rotation.needsRotation) {
            base.emit("rotate", { date: rotation.rotateTo });
          }
        }
      }
      function logWrite() {
      }
      var parsed = optionParser.parsePeriod(options.period);
      periodScope = parsed.periodScope;
      periodNum = parsed.periodNum;
      return _.extend({}, {
        newFile,
        logWrite,
        shutdown,
        checkIfRotationNeeded
      }, base);
    }
    module2.exports = InitialPeriodRotateTrigger;
  }
});

// node_modules/bunyan-rotating-file-stream/lib/thresholdtrigger.js
var require_thresholdtrigger = __commonJS({
  "node_modules/bunyan-rotating-file-stream/lib/thresholdtrigger.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var EventEmitter2 = require("events").EventEmitter;
    var _ = require_lodash();
    var optionParser = require_optionParser();
    function ThresholdTrigger(options) {
      var base = new EventEmitter2();
      var threshold = 10485760;
      var bytesWritten = 0;
      function newFile(data) {
        bytesWritten = data.stats.size;
      }
      function logWrite(data) {
        if (bytesWritten > 0 && bytesWritten + data.logSize > threshold) {
          var date = null;
          try {
            var log2 = JSON.parse(data.logstr);
            date = log2.time;
          } catch (e) {
          }
          base.emit("rotate", { date });
        } else {
          bytesWritten += data.logSize;
        }
      }
      function shutdown() {
      }
      threshold = optionParser.parseSize(options.threshold);
      return _.extend({}, {
        newFile,
        logWrite,
        shutdown
      }, base);
    }
    module2.exports = ThresholdTrigger;
  }
});

// node_modules/bunyan-rotating-file-stream/lib/triggeradapter.js
var require_triggeradapter = __commonJS({
  "node_modules/bunyan-rotating-file-stream/lib/triggeradapter.js"(exports2, module2) {
    "use strict";
    function TriggerAdapter(trigger, rfs) {
      var onRotate = function(triggerinfo) {
        rfs.rotate(triggerinfo);
      };
      var onNewFile = function(data) {
        trigger.newFile(data);
      };
      var onLogWrite = function(data) {
        trigger.logWrite(data);
      };
      var onShutdown = function() {
        trigger.shutdown();
        trigger.removeListener("rotate", onRotate);
        rfs.removeListener("newfile", onNewFile);
        rfs.removeListener("logwrite", onLogWrite);
        rfs.removeListener("shutdown", onShutdown);
      };
      trigger.on("rotate", onRotate);
      rfs.on("newfile", onNewFile);
      rfs.on("logwrite", onLogWrite);
      rfs.on("shutdown", onShutdown);
      return { onShutdown };
    }
    module2.exports = TriggerAdapter;
  }
});

// node_modules/bunyan-rotating-file-stream/index.js
var require_bunyan_rotating_file_stream = __commonJS({
  "node_modules/bunyan-rotating-file-stream/index.js"(exports2, module2) {
    "use strict";
    var RotatingFileStream2 = require_rotatingfilestream();
    var PeriodTrigger = require_periodtrigger();
    var InitialPeriodTrigger = require_initialperiodtrigger();
    var ThresholdTrigger = require_thresholdtrigger();
    var TriggerAdapter = require_triggeradapter();
    var _ = require_lodash();
    var path = require("path");
    var existingFilesStreams = {};
    function RotatingFileStreamFactory(options) {
      var options_copy = _.extend({}, options);
      if (typeof options_copy.path !== "string") {
        throw new Error("Must provide a string for path");
      }
      options_copy.path = path.resolve(options_copy.path);
      var rfs = existingFilesStreams[options_copy.path];
      if (!rfs) {
        rfs = RotatingFileStream2(options_copy);
        existingFilesStreams[options_copy.path] = rfs;
        rfs.once("shutdown", function() {
          existingFilesStreams[options_copy.path] = null;
        });
        if (options_copy.period) {
          var periodTrigger = PeriodTrigger(options_copy);
          TriggerAdapter(periodTrigger, rfs);
        }
        if (options_copy.period && options_copy.rotateExisting) {
          var initialPeriodTrigger = InitialPeriodTrigger(options_copy);
          TriggerAdapter(initialPeriodTrigger, rfs);
        }
        if (options_copy.threshold) {
          var thresholdTrigger = ThresholdTrigger(options_copy);
          TriggerAdapter(thresholdTrigger, rfs);
        }
        rfs.initialise();
      } else if (options_copy.shared !== true || existingFilesStreams[options_copy.path].shared !== true) {
        throw new Error("You should not create multiple rotating file streams against the same file: " + options_copy.path);
      }
      return rfs;
    }
    module2.exports = RotatingFileStreamFactory;
  }
});

// node_modules/clone/clone.js
var require_clone = __commonJS({
  "node_modules/clone/clone.js"(exports2, module2) {
    var clone = function() {
      "use strict";
      function clone2(parent, circular, depth, prototype) {
        var filter;
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          filter = circular.filter;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 == 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex)
              child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index = allParents.indexOf(parent2);
            if (index != -1) {
              return allChildren[index];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          for (var i in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent2[i], depth2 - 1);
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c = function() {
        };
        c.prototype = parent;
        return new c();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      ;
      clone2.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      ;
      clone2.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      ;
      clone2.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      ;
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global)
          flags += "g";
        if (re.ignoreCase)
          flags += "i";
        if (re.multiline)
          flags += "m";
        return flags;
      }
      ;
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module2 === "object" && module2.exports) {
      module2.exports = clone;
    }
  }
});

// node_modules/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/defaults/index.js"(exports2, module2) {
    var clone = require_clone();
    module2.exports = function(options, defaults) {
      options = options || {};
      Object.keys(defaults).forEach(function(key) {
        if (typeof options[key] === "undefined") {
          options[key] = clone(defaults[key]);
        }
      });
      return options;
    };
  }
});

// node_modules/wcwidth/combining.js
var require_combining = __commonJS({
  "node_modules/wcwidth/combining.js"(exports2, module2) {
    module2.exports = [
      [768, 879],
      [1155, 1158],
      [1160, 1161],
      [1425, 1469],
      [1471, 1471],
      [1473, 1474],
      [1476, 1477],
      [1479, 1479],
      [1536, 1539],
      [1552, 1557],
      [1611, 1630],
      [1648, 1648],
      [1750, 1764],
      [1767, 1768],
      [1770, 1773],
      [1807, 1807],
      [1809, 1809],
      [1840, 1866],
      [1958, 1968],
      [2027, 2035],
      [2305, 2306],
      [2364, 2364],
      [2369, 2376],
      [2381, 2381],
      [2385, 2388],
      [2402, 2403],
      [2433, 2433],
      [2492, 2492],
      [2497, 2500],
      [2509, 2509],
      [2530, 2531],
      [2561, 2562],
      [2620, 2620],
      [2625, 2626],
      [2631, 2632],
      [2635, 2637],
      [2672, 2673],
      [2689, 2690],
      [2748, 2748],
      [2753, 2757],
      [2759, 2760],
      [2765, 2765],
      [2786, 2787],
      [2817, 2817],
      [2876, 2876],
      [2879, 2879],
      [2881, 2883],
      [2893, 2893],
      [2902, 2902],
      [2946, 2946],
      [3008, 3008],
      [3021, 3021],
      [3134, 3136],
      [3142, 3144],
      [3146, 3149],
      [3157, 3158],
      [3260, 3260],
      [3263, 3263],
      [3270, 3270],
      [3276, 3277],
      [3298, 3299],
      [3393, 3395],
      [3405, 3405],
      [3530, 3530],
      [3538, 3540],
      [3542, 3542],
      [3633, 3633],
      [3636, 3642],
      [3655, 3662],
      [3761, 3761],
      [3764, 3769],
      [3771, 3772],
      [3784, 3789],
      [3864, 3865],
      [3893, 3893],
      [3895, 3895],
      [3897, 3897],
      [3953, 3966],
      [3968, 3972],
      [3974, 3975],
      [3984, 3991],
      [3993, 4028],
      [4038, 4038],
      [4141, 4144],
      [4146, 4146],
      [4150, 4151],
      [4153, 4153],
      [4184, 4185],
      [4448, 4607],
      [4959, 4959],
      [5906, 5908],
      [5938, 5940],
      [5970, 5971],
      [6002, 6003],
      [6068, 6069],
      [6071, 6077],
      [6086, 6086],
      [6089, 6099],
      [6109, 6109],
      [6155, 6157],
      [6313, 6313],
      [6432, 6434],
      [6439, 6440],
      [6450, 6450],
      [6457, 6459],
      [6679, 6680],
      [6912, 6915],
      [6964, 6964],
      [6966, 6970],
      [6972, 6972],
      [6978, 6978],
      [7019, 7027],
      [7616, 7626],
      [7678, 7679],
      [8203, 8207],
      [8234, 8238],
      [8288, 8291],
      [8298, 8303],
      [8400, 8431],
      [12330, 12335],
      [12441, 12442],
      [43014, 43014],
      [43019, 43019],
      [43045, 43046],
      [64286, 64286],
      [65024, 65039],
      [65056, 65059],
      [65279, 65279],
      [65529, 65531],
      [68097, 68099],
      [68101, 68102],
      [68108, 68111],
      [68152, 68154],
      [68159, 68159],
      [119143, 119145],
      [119155, 119170],
      [119173, 119179],
      [119210, 119213],
      [119362, 119364],
      [917505, 917505],
      [917536, 917631],
      [917760, 917999]
    ];
  }
});

// node_modules/wcwidth/index.js
var require_wcwidth = __commonJS({
  "node_modules/wcwidth/index.js"(exports2, module2) {
    "use strict";
    var defaults = require_defaults();
    var combining = require_combining();
    var DEFAULTS = {
      nul: 0,
      control: 0
    };
    module2.exports = function wcwidth2(str) {
      return wcswidth(str, DEFAULTS);
    };
    module2.exports.config = function(opts) {
      opts = defaults(opts || {}, DEFAULTS);
      return function wcwidth2(str) {
        return wcswidth(str, opts);
      };
    };
    function wcswidth(str, opts) {
      if (typeof str !== "string")
        return wcwidth(str, opts);
      var s = 0;
      for (var i = 0; i < str.length; i++) {
        var n = wcwidth(str.charCodeAt(i), opts);
        if (n < 0)
          return -1;
        s += n;
      }
      return s;
    }
    function wcwidth(ucs, opts) {
      if (ucs === 0)
        return opts.nul;
      if (ucs < 32 || ucs >= 127 && ucs < 160)
        return opts.control;
      if (bisearch(ucs))
        return 0;
      return 1 + (ucs >= 4352 && (ucs <= 4447 || ucs == 9001 || ucs == 9002 || ucs >= 11904 && ucs <= 42191 && ucs != 12351 || ucs >= 44032 && ucs <= 55203 || ucs >= 63744 && ucs <= 64255 || ucs >= 65040 && ucs <= 65049 || ucs >= 65072 && ucs <= 65135 || ucs >= 65280 && ucs <= 65376 || ucs >= 65504 && ucs <= 65510 || ucs >= 131072 && ucs <= 196605 || ucs >= 196608 && ucs <= 262141));
    }
    function bisearch(ucs) {
      var min = 0;
      var max = combining.length - 1;
      var mid;
      if (ucs < combining[0][0] || ucs > combining[max][1])
        return false;
      while (max >= min) {
        mid = Math.floor((min + max) / 2);
        if (ucs > combining[mid][1])
          min = mid + 1;
        else if (ucs < combining[mid][0])
          max = mid - 1;
        else
          return true;
      }
      return false;
    }
  }
});

// node_modules/easy-table/table.js
var require_table = __commonJS({
  "node_modules/easy-table/table.js"(exports2, module2) {
    var wcwidth;
    try {
      wcwidth = require_wcwidth();
    } catch (e) {
    }
    module2.exports = Table;
    function Table() {
      this.rows = [];
      this.row = { __printers: {} };
    }
    Table.prototype.newRow = function() {
      this.rows.push(this.row);
      this.row = { __printers: {} };
      return this;
    };
    Table.prototype.cell = function(col, val, printer) {
      this.row[col] = val;
      this.row.__printers[col] = printer || string;
      return this;
    };
    Table.prototype.separator = "  ";
    function string(val) {
      return val === void 0 ? "" : "" + val;
    }
    function length(str) {
      var s = str.replace(/\u001b\[\d+m/g, "");
      return wcwidth == null ? s.length : wcwidth(s);
    }
    Table.string = string;
    Table.leftPadder = leftPadder;
    function leftPadder(ch) {
      return function(val, width) {
        var str = string(val);
        var len = length(str);
        var pad = width > len ? Array(width - len + 1).join(ch) : "";
        return pad + str;
      };
    }
    var padLeft = Table.padLeft = leftPadder(" ");
    Table.rightPadder = rightPadder;
    function rightPadder(ch) {
      return function padRight2(val, width) {
        var str = string(val);
        var len = length(str);
        var pad = width > len ? Array(width - len + 1).join(ch) : "";
        return str + pad;
      };
    }
    var padRight = rightPadder(" ");
    Table.number = function(digits) {
      return function(val, width) {
        if (val == null)
          return "";
        if (typeof val != "number")
          throw new Error("" + val + " is not a number");
        var str = digits == null ? val + "" : val.toFixed(digits);
        return padLeft(str, width);
      };
    };
    function each(row, fn) {
      for (var key in row) {
        if (key == "__printers")
          continue;
        fn(key, row[key]);
      }
    }
    Table.prototype.columns = function() {
      var cols = {};
      for (var i = 0; i < 2; i++) {
        this.rows.forEach(function(row) {
          var idx = 0;
          each(row, function(key) {
            idx = Math.max(idx, cols[key] || 0);
            cols[key] = idx;
            idx++;
          });
        });
      }
      return Object.keys(cols).sort(function(a, b) {
        return cols[a] - cols[b];
      });
    };
    Table.prototype.print = function() {
      var cols = this.columns();
      var separator = this.separator;
      var widths = {};
      var out = "";
      this.rows.forEach(function(row) {
        each(row, function(key, val) {
          var str = row.__printers[key].call(row, val);
          widths[key] = Math.max(length(str), widths[key] || 0);
        });
      });
      this.rows.forEach(function(row) {
        var line = "";
        cols.forEach(function(key) {
          var width = widths[key];
          var str = row.hasOwnProperty(key) ? "" + row.__printers[key].call(row, row[key], width) : "";
          line += padRight(str, width) + separator;
        });
        line = line.slice(0, -separator.length);
        out += line + "\n";
      });
      return out;
    };
    Table.prototype.toString = function() {
      var cols = this.columns();
      var out = new Table();
      out.separator = this.separator;
      cols.forEach(function(col) {
        out.cell(col, col);
      });
      out.newRow();
      out.pushDelimeter(cols);
      out.rows = out.rows.concat(this.rows);
      if (this.totals && this.rows.length) {
        out.pushDelimeter(cols);
        this.forEachTotal(out.cell.bind(out));
        out.newRow();
      }
      return out.print();
    };
    Table.prototype.pushDelimeter = function(cols) {
      cols = cols || this.columns();
      cols.forEach(function(col) {
        this.cell(col, void 0, leftPadder("-"));
      }, this);
      return this.newRow();
    };
    Table.prototype.forEachTotal = function(cb) {
      for (var key in this.totals) {
        var aggr = this.totals[key];
        var acc = aggr.init;
        var len = this.rows.length;
        this.rows.forEach(function(row, idx) {
          acc = aggr.reduce.call(row, acc, row[key], idx, len);
        });
        cb(key, acc, aggr.printer);
      }
    };
    Table.prototype.printTransposed = function(opts) {
      opts = opts || {};
      var out = new Table();
      out.separator = opts.separator || this.separator;
      this.columns().forEach(function(col) {
        out.cell(0, col, opts.namePrinter);
        this.rows.forEach(function(row, idx) {
          out.cell(idx + 1, row[col], row.__printers[col]);
        });
        out.newRow();
      }, this);
      return out.print();
    };
    Table.prototype.sort = function(cmp) {
      if (typeof cmp == "function") {
        this.rows.sort(cmp);
        return this;
      }
      var keys = Array.isArray(cmp) ? cmp : this.columns();
      var comparators = keys.map(function(key) {
        var order = "asc";
        var m = /(.*)\|\s*(asc|des)\s*$/.exec(key);
        if (m) {
          key = m[1];
          order = m[2];
        }
        return function(a, b) {
          return order == "asc" ? compare(a[key], b[key]) : compare(b[key], a[key]);
        };
      });
      return this.sort(function(a, b) {
        for (var i = 0; i < comparators.length; i++) {
          var order = comparators[i](a, b);
          if (order != 0)
            return order;
        }
        return 0;
      });
    };
    function compare(a, b) {
      if (a === b)
        return 0;
      if (a === void 0)
        return 1;
      if (b === void 0)
        return -1;
      if (a === null)
        return 1;
      if (b === null)
        return -1;
      if (a > b)
        return 1;
      if (a < b)
        return -1;
      return compare(String(a), String(b));
    }
    Table.prototype.total = function(col, opts) {
      opts = opts || {};
      this.totals = this.totals || {};
      this.totals[col] = {
        reduce: opts.reduce || Table.aggr.sum,
        printer: opts.printer || padLeft,
        init: opts.init == null ? 0 : opts.init
      };
      return this;
    };
    Table.aggr = {};
    Table.aggr.printer = function(prefix, printer) {
      printer = printer || string;
      return function(val, width) {
        return padLeft(prefix + printer(val), width);
      };
    };
    Table.aggr.sum = function(acc, val) {
      return acc + val;
    };
    Table.aggr.avg = function(acc, val, idx, len) {
      acc = acc + val;
      return idx + 1 == len ? acc / len : acc;
    };
    Table.print = function(obj, format2, cb) {
      var opts = format2 || {};
      format2 = typeof format2 == "function" ? format2 : function(obj2, cell2) {
        for (var key in obj2) {
          if (!obj2.hasOwnProperty(key))
            continue;
          var params = opts[key] || {};
          cell2(params.name || key, obj2[key], params.printer);
        }
      };
      var t = new Table();
      var cell = t.cell.bind(t);
      if (Array.isArray(obj)) {
        cb = cb || function(t2) {
          return t2.toString();
        };
        obj.forEach(function(item) {
          format2(item, cell);
          t.newRow();
        });
      } else {
        cb = cb || function(t2) {
          return t2.printTransposed({ separator: " : " });
        };
        format2(obj, cell);
        t.newRow();
      }
      return cb(t);
    };
    Table.log = function(obj, format2, cb) {
      console.log(Table.print(obj, format2, cb));
    };
    Table.prototype.log = function() {
      console.log(this.toString());
    };
  }
});

// node_modules/console.table/index.js
var require_console2 = __commonJS({
  "node_modules/console.table/index.js"(exports2, module2) {
    (function() {
      "use strict";
      function setupConsoleTable() {
        if (typeof console === "undefined") {
          throw new Error("Weird, console object is undefined");
        }
        if (typeof console.table === "function") {
          if (console.table === consoleTable) {
            return;
          }
        }
        function isType(t, x) {
          return typeof x === t;
        }
        var isString = isType.bind(null, "string");
        function isArrayOf(isTypeFn, a) {
          return Array.isArray(a) && a.every(isTypeFn);
        }
        var isArrayOfStrings = isArrayOf.bind(null, isString);
        var isArrayOfArrays = isArrayOf.bind(null, Array.isArray);
        var Table = require_table();
        function arrayToString(arr) {
          var t = new Table();
          arr.forEach(function(record) {
            if (typeof record === "string" || typeof record === "number") {
              t.cell("item", record);
            } else {
              Object.keys(record).forEach(function(property) {
                t.cell(property, record[property]);
              });
            }
            t.newRow();
          });
          return t.toString();
        }
        function printTableWithColumnTitles(titles, items, noConsole) {
          var t = new Table();
          items.forEach(function(item) {
            item.forEach(function(value, k) {
              t.cell(titles[k], value);
            });
            t.newRow();
          });
          var str = t.toString();
          return noConsole ? str : console.log(str);
        }
        function printTitleTable(title, arr) {
          var str = arrayToString(arr);
          var rowLength = str.indexOf("\n");
          if (rowLength > 0) {
            if (title.length > rowLength) {
              rowLength = title.length;
            }
            console.log(title);
            var sep = "-", k, line = "";
            for (k = 0; k < rowLength; k += 1) {
              line += sep;
            }
            console.log(line);
          }
          console.log(str);
        }
        function getTitleTable(title, arr) {
          var str = arrayToString(arr);
          var rowLength = str.indexOf("\n");
          var strToReturn = "";
          if (rowLength > 0) {
            if (title.length > rowLength) {
              rowLength = title.length;
            }
            strToReturn += title + "\n";
            var sep = "-", k, line = "";
            for (k = 0; k < rowLength; k += 1) {
              line += sep;
            }
            strToReturn += line + "\n";
          }
          return strToReturn + str;
        }
        function objectToArray(obj) {
          var keys = Object.keys(obj);
          return keys.map(function(key) {
            return {
              key,
              value: obj[key]
            };
          });
        }
        function objectToString(obj) {
          return arrayToString(objectToArray(obj));
        }
        function consoleTable() {
          var args = Array.prototype.slice.call(arguments);
          if (args.length === 2 && typeof args[0] === "string" && Array.isArray(args[1])) {
            return printTitleTable(args[0], args[1]);
          }
          if (args.length === 2 && isArrayOfStrings(args[0]) && isArrayOfArrays(args[1])) {
            return printTableWithColumnTitles(args[0], args[1]);
          }
          args.forEach(function(k) {
            if (typeof k === "string") {
              return console.log(k);
            } else if (Array.isArray(k)) {
              console.log(arrayToString(k));
            } else if (typeof k === "object") {
              console.log(objectToString(k));
            }
          });
        }
        module2.exports.getTable = function() {
          var args = Array.prototype.slice.call(arguments);
          var strToReturn = "";
          if (args.length === 2 && typeof args[0] === "string" && Array.isArray(args[1])) {
            return getTitleTable(args[0], args[1]);
          }
          if (args.length === 2 && isArrayOfStrings(args[0]) && isArrayOfArrays(args[1])) {
            return printTableWithColumnTitles(args[0], args[1], true);
          }
          args.forEach(function(k, i) {
            if (typeof k === "string") {
              strToReturn += k;
              if (i !== args.length - 1) {
                strToReturn += "\n";
              }
              return;
            } else if (Array.isArray(k)) {
              strToReturn += arrayToString(k) + "\n";
            } else if (typeof k === "object") {
              strToReturn += objectToString(k);
            }
          });
          return strToReturn;
        };
        console.table = consoleTable;
      }
      setupConsoleTable();
    })();
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    function log2(message) {
      console.log(`[dotenv][DEBUG] ${message}`);
    }
    var NEWLINE = "\n";
    var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
    var RE_NEWLINES = /\\n/g;
    var NEWLINES_MATCH = /\n|\r|\r\n/;
    function parse(src, options) {
      const debug = Boolean(options && options.debug);
      const obj = {};
      src.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
        const keyValueArr = line.match(RE_INI_KEY_VAL);
        if (keyValueArr != null) {
          const key = keyValueArr[1];
          let val = keyValueArr[2] || "";
          const end = val.length - 1;
          const isDoubleQuoted = val[0] === '"' && val[end] === '"';
          const isSingleQuoted = val[0] === "'" && val[end] === "'";
          if (isSingleQuoted || isDoubleQuoted) {
            val = val.substring(1, end);
            if (isDoubleQuoted) {
              val = val.replace(RE_NEWLINES, NEWLINE);
            }
          } else {
            val = val.trim();
          }
          obj[key] = val;
        } else if (debug) {
          log2(`did not match key and value when parsing line ${idx + 1}: ${line}`);
        }
      });
      return obj;
    }
    function config3(options) {
      let dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      let debug = false;
      if (options) {
        if (options.path != null) {
          dotenvPath = options.path;
        }
        if (options.encoding != null) {
          encoding = options.encoding;
        }
        if (options.debug != null) {
          debug = true;
        }
      }
      try {
        const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug });
        Object.keys(parsed).forEach(function(key) {
          if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
            process.env[key] = parsed[key];
          } else if (debug) {
            log2(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
          }
        });
        return { parsed };
      } catch (e) {
        return { error: e };
      }
    }
    module2.exports.config = config3;
    module2.exports.parse = parse;
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/axios/lib/utils.js"(exports2, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return toString.call(val) === "[object Array]";
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate2(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate: isDate2,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports2, module2) {
    "use strict";
    module2.exports = function enhanceError(error2, config3, code, request, response) {
      error2.config = config3;
      if (code) {
        error2.code = code;
      }
      error2.request = request;
      error2.response = response;
      error2.isAxiosError = true;
      error2.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error2;
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports2, module2) {
    "use strict";
    var enhanceError = require_enhanceError();
    module2.exports = function createError(message, config3, code, request, response) {
      var error2 = new Error(message);
      return enhanceError(error2, config3, code, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports2, module2) {
    "use strict";
    var createError = require_createError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match2 ? decodeURIComponent(match2[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports2, module2) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var defaults = require_defaults2();
    var Cancel = require_Cancel();
    module2.exports = function xhrAdapter(config3) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config3.data;
        var requestHeaders = config3.headers;
        var responseType = config3.responseType;
        var onCanceled;
        function done() {
          if (config3.cancelToken) {
            config3.cancelToken.unsubscribe(onCanceled);
          }
          if (config3.signal) {
            config3.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config3.auth) {
          var username = config3.auth.username || "";
          var password = config3.auth.password ? unescape(encodeURIComponent(config3.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config3.baseURL, config3.url);
        request.open(config3.method.toUpperCase(), buildURL(fullPath, config3.params, config3.paramsSerializer), true);
        request.timeout = config3.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config3,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config3, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config3, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config3.timeout ? "timeout of " + config3.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config3.transitional || defaults.transitional;
          if (config3.timeoutErrorMessage) {
            timeoutErrorMessage = config3.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config3, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config3.withCredentials || isURLSameOrigin(fullPath)) && config3.xsrfCookieName ? cookies.read(config3.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config3.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config3.withCredentials)) {
          request.withCredentials = !!config3.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config3.responseType;
        }
        if (typeof config3.onDownloadProgress === "function") {
          request.addEventListener("progress", config3.onDownloadProgress);
        }
        if (typeof config3.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config3.onUploadProgress);
        }
        if (config3.cancelToken || config3.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config3.cancelToken && config3.cancelToken.subscribe(onCanceled);
          if (config3.signal) {
            config3.signal.aborted ? onCanceled() : config3.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error2) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    var url = require("url");
    var URL = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug2();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
    var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
    var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
    var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (typeof data === "function") {
        callback = data;
        data = encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.substr(0, protocol.length - 1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      this._currentUrl = url.format(this._options);
      request._redirectable = this;
      for (var e = 0; e < events.length; e++) {
        request.on(events[e], eventHandlers[events[e]]);
      }
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error2) {
          if (request === self2._currentRequest) {
            if (error2) {
              self2.emit("error", error2);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (location && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {
        abortRequest(this._currentRequest);
        response.destroy();
        if (++this._redirectCount > this._options.maxRedirects) {
          this.emit("error", new TooManyRedirectsError());
          return;
        }
        if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
          this._options.method = "GET";
          this._requestBodyBuffers = [];
          removeMatchingHeaders(/^content-/i, this._options.headers);
        }
        var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
        var currentUrlParts = url.parse(this._currentUrl);
        var currentHost = currentHostHeader || currentUrlParts.host;
        var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
        var redirectUrl;
        try {
          redirectUrl = url.resolve(currentUrl, location);
        } catch (cause) {
          this.emit("error", new RedirectionError(cause));
          return;
        }
        debug("redirecting to", redirectUrl);
        this._isRedirect = true;
        var redirectUrlParts = url.parse(redirectUrl);
        Object.assign(this._options, redirectUrlParts);
        if (!(redirectUrlParts.host === currentHost || isSubdomainOf(redirectUrlParts.host, currentHost))) {
          removeMatchingHeaders(/^authorization$/i, this._options.headers);
        }
        if (typeof this._options.beforeRedirect === "function") {
          var responseDetails = { headers: response.headers };
          try {
            this._options.beforeRedirect.call(null, this._options, responseDetails);
          } catch (err) {
            this.emit("error", err);
            return;
          }
          this._sanitizeOptions(this._options);
        }
        try {
          this._performRequest();
        } catch (cause) {
          this.emit("error", new RedirectionError(cause));
        }
      } else {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
      }
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (typeof input === "string") {
            var urlStr = input;
            try {
              input = urlToOptions(new URL(urlStr));
            } catch (err) {
              input = url.parse(urlStr);
            }
          } else if (URL && input instanceof URL) {
            input = urlToOptions(input);
          } else {
            callback = options;
            options = input;
            input = { protocol };
          }
          if (typeof options === "function") {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header].toString().trim();
          delete headers[header];
        }
      }
      return lastValue;
    }
    function createErrorType(code, defaultMessage) {
      function CustomError(cause) {
        Error.captureStackTrace(this, this.constructor);
        if (!cause) {
          this.message = defaultMessage;
        } else {
          this.message = defaultMessage + ": " + cause.message;
          this.cause = cause;
        }
      }
      CustomError.prototype = new Error();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      CustomError.prototype.code = code;
      return CustomError;
    }
    function abortRequest(request) {
      for (var e = 0; e < events.length; e++) {
        request.removeListener(events[e], eventHandlers[events[e]]);
      }
      request.on("error", noop);
      request.abort();
    }
    function isSubdomainOf(subdomain, domain) {
      const dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports2, module2) {
    module2.exports = {
      "version": "0.24.0"
    };
  }
});

// node_modules/axios/lib/adapters/http.js
var require_http4 = __commonJS({
  "node_modules/axios/lib/adapters/http.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var settle = require_settle();
    var buildFullPath = require_buildFullPath();
    var buildURL = require_buildURL();
    var http = require("http");
    var https = require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = require("url");
    var zlib = require("zlib");
    var VERSION = require_data().version;
    var createError = require_createError();
    var enhanceError = require_enhanceError();
    var defaults = require_defaults2();
    var Cancel = require_Cancel();
    var isHttps = /https:?/;
    function setProxy(options, proxy, location) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.port = proxy.port;
      options.path = location;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module2.exports = function httpAdapter(config3) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var onCanceled;
        function done() {
          if (config3.cancelToken) {
            config3.cancelToken.unsubscribe(onCanceled);
          }
          if (config3.signal) {
            config3.signal.removeEventListener("abort", onCanceled);
          }
        }
        var resolve = function resolve2(value) {
          done();
          resolvePromise(value);
        };
        var reject = function reject2(value) {
          done();
          rejectPromise(value);
        };
        var data = config3.data;
        var headers = config3.headers;
        var headerNames = {};
        Object.keys(headers).forEach(function storeLowerName(name) {
          headerNames[name.toLowerCase()] = name;
        });
        if ("user-agent" in headerNames) {
          if (!headers[headerNames["user-agent"]]) {
            delete headers[headerNames["user-agent"]];
          }
        } else {
          headers["User-Agent"] = "axios/" + VERSION;
        }
        if (data && !utils.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(createError("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", config3));
          }
          if (!headerNames["content-length"]) {
            headers["Content-Length"] = data.length;
          }
        }
        var auth = void 0;
        if (config3.auth) {
          var username = config3.auth.username || "";
          var password = config3.auth.password || "";
          auth = username + ":" + password;
        }
        var fullPath = buildFullPath(config3.baseURL, config3.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || "http:";
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth && headerNames.authorization) {
          delete headers[headerNames.authorization];
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config3.httpsAgent : config3.httpAgent;
        var options = {
          path: buildURL(parsed.path, config3.params, config3.paramsSerializer).replace(/^\?/, ""),
          method: config3.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config3.httpAgent, https: config3.httpsAgent },
          auth
        };
        if (config3.socketPath) {
          options.socketPath = config3.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }
        var proxy = config3.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s) {
                return s.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config3.transport) {
          transport = config3.transport;
        } else if (config3.maxRedirects === 0) {
          transport = isHttpsProxy ? https : http;
        } else {
          if (config3.maxRedirects) {
            options.maxRedirects = config3.maxRedirects;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config3.maxBodyLength > -1) {
          options.maxBodyLength = config3.maxBodyLength;
        }
        if (config3.insecureHTTPParser) {
          options.insecureHTTPParser = config3.insecureHTTPParser;
        }
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted)
            return;
          var stream = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config3.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config: config3,
            request: lastRequest
          };
          if (config3.responseType === "stream") {
            response.data = stream;
            settle(resolve, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config3.maxContentLength > -1 && totalResponseBytes > config3.maxContentLength) {
                stream.destroy();
                reject(createError("maxContentLength size of " + config3.maxContentLength + " exceeded", config3, null, lastRequest));
              }
            });
            stream.on("error", function handleStreamError(err) {
              if (req.aborted)
                return;
              reject(enhanceError(err, config3, null, lastRequest));
            });
            stream.on("end", function handleStreamEnd() {
              var responseData = Buffer.concat(responseBuffer);
              if (config3.responseType !== "arraybuffer") {
                responseData = responseData.toString(config3.responseEncoding);
                if (!config3.responseEncoding || config3.responseEncoding === "utf8") {
                  responseData = utils.stripBOM(responseData);
                }
              }
              response.data = responseData;
              settle(resolve, reject, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS")
            return;
          reject(enhanceError(err, config3, null, req));
        });
        if (config3.timeout) {
          var timeout = parseInt(config3.timeout, 10);
          if (isNaN(timeout)) {
            reject(createError("error trying to parse `config.timeout` to int", config3, "ERR_PARSE_TIMEOUT", req));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            var transitional = config3.transitional || defaults.transitional;
            reject(createError("timeout of " + timeout + "ms exceeded", config3, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", req));
          });
        }
        if (config3.cancelToken || config3.signal) {
          onCanceled = function(cancel) {
            if (req.aborted)
              return;
            req.abort();
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
          };
          config3.cancelToken && config3.cancelToken.subscribe(onCanceled);
          if (config3.signal) {
            config3.signal.aborted ? onCanceled() : config3.signal.addEventListener("abort", onCanceled);
          }
        }
        if (utils.isStream(data)) {
          data.on("error", function handleStreamError(err) {
            reject(enhanceError(err, config3, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// node_modules/axios/lib/defaults.js
var require_defaults2 = __commonJS({
  "node_modules/axios/lib/defaults.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http4();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var defaults = require_defaults2();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults2();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config3) {
      if (config3.cancelToken) {
        config3.cancelToken.throwIfRequested();
      }
      if (config3.signal && config3.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module2.exports = function dispatchRequest(config3) {
      throwIfCancellationRequested(config3);
      config3.headers = config3.headers || {};
      config3.data = transformData.call(config3, config3.data, config3.headers, config3.transformRequest);
      config3.headers = utils.merge(config3.headers.common || {}, config3.headers[config3.method] || {}, config3.headers);
      utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
        delete config3.headers[method];
      });
      var adapter = config3.adapter || defaults.adapter;
      return adapter(config3).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config3);
        response.data = transformData.call(config3, response.data, response.headers, config3.transformResponse);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config3);
          if (reason && reason.response) {
            reason.response.data = transformData.call(config3, reason.response.data, reason.response.headers, config3.transformResponse);
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = function mergeConfig(config1, config22) {
      config22 = config22 || {};
      var config3 = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config22[prop])) {
          return getMergedValue(config1[prop], config22[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config22[prop])) {
          return getMergedValue(void 0, config22[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config22[prop])) {
          return getMergedValue(void 0, config22[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config22) {
          return getMergedValue(config1[prop], config22[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config22)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config3[prop] = configValue);
      });
      return config3;
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports2, module2) {
    "use strict";
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module2.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(config3) {
      if (typeof config3 === "string") {
        config3 = arguments[1] || {};
        config3.url = arguments[0];
      } else {
        config3 = config3 || {};
      }
      config3 = mergeConfig(this.defaults, config3);
      if (config3.method) {
        config3.method = config3.method.toLowerCase();
      } else if (this.defaults.method) {
        config3.method = this.defaults.method.toLowerCase();
      } else {
        config3.method = "get";
      }
      var transitional = config3.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config3) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config3);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config3;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error2) {
          onRejected(error2);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error2) {
        return Promise.reject(error2);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config3) {
      config3 = mergeConfig(this.defaults, config3);
      return buildURL(config3.url, config3.params, config3.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config3) {
        return this.request(mergeConfig(config3 || {}, {
          method,
          url,
          data: (config3 || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config3) {
        return this.request(mergeConfig(config3 || {}, {
          method,
          url,
          data
        }));
      };
    });
    module2.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAxiosError(payload) {
      return typeof payload === "object" && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults2();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios3 = createInstance(defaults);
    axios3.Axios = Axios;
    axios3.Cancel = require_Cancel();
    axios3.CancelToken = require_CancelToken();
    axios3.isCancel = require_isCancel();
    axios3.VERSION = require_data().version;
    axios3.all = function all(promises) {
      return Promise.all(promises);
    };
    axios3.spread = require_spread();
    axios3.isAxiosError = require_isAxiosError();
    module2.exports = axios3;
    module2.exports.default = axios3;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports2, module2) {
    module2.exports = require_axios();
  }
});

// node_modules/ws/wrapper.mjs
var import_stream = __toModule(require_stream());
var import_receiver = __toModule(require_receiver());
var import_sender = __toModule(require_sender());
var import_websocket = __toModule(require_websocket());
var import_websocket_server = __toModule(require_websocket_server());
var wrapper_default = import_websocket.default;

// logger/index.ts
var Sentry = __toModule(require_dist8());
var import_bunyan = __toModule(require_bunyan());
var import_bunyan_rotating_file_stream = __toModule(require_bunyan_rotating_file_stream());
var import_console = __toModule(require_console2());

// types.ts
var ExchangeIndex = /* @__PURE__ */ ((ExchangeIndex2) => {
  ExchangeIndex2[ExchangeIndex2["UniswapV2"] = 0] = "UniswapV2";
  ExchangeIndex2[ExchangeIndex2["Sushiswap"] = 1] = "Sushiswap";
  ExchangeIndex2[ExchangeIndex2["CryptoCom"] = 2] = "CryptoCom";
  return ExchangeIndex2;
})(ExchangeIndex || {});

// bot/src/eventEmitter/index.ts
var import_events = __toModule(require("events"));
var eventEmitter = new import_events.default();
var eventEmitter_default = eventEmitter;

// resources/thirdPartyContracts/mainnet/weth.json
var address = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";

// bot/src/tokens.ts
var WETH = {
  symbol: "WETH",
  address,
  decimals: 18
};

// node_modules/date-fns/esm/_lib/requiredArgs/index.js
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}

// node_modules/date-fns/esm/isDate/index.js
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// node_modules/date-fns/esm/toDate/index.js
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}

// node_modules/date-fns/esm/isValid/index.js
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}

// node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
var formatDistance_default = formatDistance;

// node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong_default = formatLong;

// node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
var formatRelative_default = formatRelative;

// node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js
function buildLocalizeFn(args) {
  return function(dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize_default = localize;

// node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/match/index.js
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match_default = match;

// node_modules/date-fns/esm/locale/en-US/index.js
var locale = {
  code: "en-US",
  formatDistance: formatDistance_default,
  formatLong: formatLong_default,
  formatRelative: formatRelative_default,
  localize: localize_default,
  match: match_default,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var en_US_default = locale;

// node_modules/date-fns/esm/_lib/toInteger/index.js
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

// node_modules/date-fns/esm/addMilliseconds/index.js
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

// node_modules/date-fns/esm/subMilliseconds/index.js
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

// node_modules/date-fns/esm/_lib/addLeadingZeros/index.js
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}

// node_modules/date-fns/esm/_lib/format/lightFormatters/index.js
var formatters = {
  y: function(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  M: function(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  d: function(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  a: function(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  h: function(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  H: function(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  m: function(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  s: function(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  S: function(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var lightFormatters_default = formatters;

// node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

// node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

// node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js
function startOfUTCWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js
function getUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js
function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, dirtyOptions);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCWeek/index.js
var MILLISECONDS_IN_WEEK2 = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
}

// node_modules/date-fns/esm/_lib/format/formatters/index.js
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters2 = {
  G: function(date, token, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  y: function(date, token, localize2) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return lightFormatters_default.y(date, token);
  },
  Y: function(date, token, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  R: function(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  u: function(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  Q: function(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  q: function(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  M: function(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters_default.M(date, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  L: function(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  w: function(date, token, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  I: function(date, token, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  d: function(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return lightFormatters_default.d(date, token);
  },
  D: function(date, token, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  E: function(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  e: function(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  c: function(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  i: function(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  a: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  b: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  B: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  h: function(date, token, localize2) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return lightFormatters_default.h(date, token);
  },
  H: function(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return lightFormatters_default.H(date, token);
  },
  K: function(date, token, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  k: function(date, token, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  m: function(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return lightFormatters_default.m(date, token);
  },
  s: function(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return lightFormatters_default.s(date, token);
  },
  S: function(date, token) {
    return lightFormatters_default.S(date, token);
  },
  X: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  x: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  O: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  z: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  t: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  T: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, delimiter) {
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
var formatters_default = formatters2;

// node_modules/date-fns/esm/_lib/format/longFormatters/index.js
function dateLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
}
function timeLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
}
function dateTimeLongFormatter(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
}
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters_default = longFormatters;

// node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

// node_modules/date-fns/esm/_lib/protectedTokens/index.js
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  }
}

// node_modules/date-fns/esm/format/index.js
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale2 = options.locale || en_US_default;
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters_default[firstCharacter];
      return longFormatter(substring, locale2.formatLong, formatterOptions);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters_default[firstCharacter];
    if (formatter) {
      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }
      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

// bot/src/utils/formatTimestamp.ts
var formatTimestamp = (timestamp) => format(timestamp, "d/M/yy HH:mm:ss");
var formatTimestamp_default = formatTimestamp;

// logger/config.ts
var import_dotenv = __toModule(require_main());

// utils/env.ts
var env = (name) => {
  const value = process.env[`${name}`];
  if (!value) {
    throw new Error(`Missing: process.env['${name}'].`);
  }
  return value;
};
var env_default = env;

// logger/config.ts
import_dotenv.default.config();
var config = {
  serverId: env_default("SERVER_ID"),
  environment: process.env.NODE_ENV || "development",
  isProd: process.env.NODE_ENV === "production",
  isDev: process.env.NODE_ENV === "development",
  slackChannelsWebhooks: {
    deals: env_default("SLACK_HOOK_URL_DEALS")
  },
  sentryDNS: env_default("SENTRY_DNS_URL")
};
var config_default = config;

// logger/sendSlackMessage.ts
var import_axios = __toModule(require_axios2());
var sendSlackMessage = async (message) => {
  const body = JSON.stringify(message);
  return import_axios.default.post(config_default.slackChannelsWebhooks.deals, body, {
    headers: {
      "Content-Type": "application/json"
    }
  });
};
var sendSlackMessage_default = sendSlackMessage;

// logger/index.ts
var bunyanLogger = import_bunyan.default.createLogger({
  name: "bot",
  serializers: import_bunyan.default.stdSerializers,
  src: true
});
if (config_default.isProd) {
  bunyanLogger.addStream({
    stream: new import_bunyan_rotating_file_stream.default({
      path: `/var/tmp/logs.log`,
      period: "1d",
      totalFiles: 3,
      rotateExisting: true
    })
  });
  Sentry.init({
    dsn: config_default.sentryDNS,
    environment: config_default.environment
  });
}
var log = (...args) => {
  if (config_default.environment !== "test") {
    bunyanLogger.info(...args);
  }
};
var error = (newError) => {
  bunyanLogger.error(newError);
  if (config_default.isProd) {
    Sentry.captureException(newError, {
      tags: {
        serverId: config_default.serverId
      }
    });
  }
};
var _convertToHumanReadableAmount = (amount, tokenDecimals) => {
  let sign = "";
  let amountString = amount.toString();
  if (amountString[0] === "-") {
    sign = "-";
    amountString = amountString.substring(1);
  }
  if (amountString.length < tokenDecimals + 1) {
    const zerosToAddCount = tokenDecimals + 1 - amountString.length;
    let zeros = "";
    for (let z = 0; z < zerosToAddCount; z++) {
      zeros += "0";
    }
    amountString = zeros + amountString;
  }
  const periodIndex = amountString.length - tokenDecimals;
  return sign + amountString.substring(0, periodIndex) + "." + amountString.substring(periodIndex);
};
var transaction = async ({
  trade,
  spreadsheet,
  transactionHash = "None"
}) => {
  const timestamp = formatTimestamp_default(trade.path[0].timestamp);
  const borrowedTokens = _convertToHumanReadableAmount(trade.path[0].fromTokenDecimalAmount, trade.path[0].fromToken.decimals);
  const boughtTokens = _convertToHumanReadableAmount(trade.path[0].toTokenDecimalAmount, trade.path[0].toToken.decimals);
  const revenues = _convertToHumanReadableAmount(trade.path[1].toTokenDecimalAmount, trade.path[1].toToken.decimals);
  const bestSellingExchangeName = ExchangeIndex[trade.path[0].exchangeIndex];
  const bestBuyingExchangeName = ExchangeIndex[trade.path[1].exchangeIndex];
  const gasCostETH = _convertToHumanReadableAmount(trade.totalGasCost, 18);
  const profitInTokens = _convertToHumanReadableAmount(trade.profitWethAmount, WETH.decimals);
  if (config_default.isProd) {
    const slackBlock = [
      {
        type: "section",
        fields: [
          {
            type: "mrkdwn",
            text: `*Transaction hash:*
${transactionHash}`
          },
          {
            type: "mrkdwn",
            text: `*Block number:*
${trade.blockNumber}`
          },
          {
            type: "mrkdwn",
            text: `*Timestamp:*
${timestamp}`
          },
          {
            type: "mrkdwn",
            text: `*${trade.path[0].fromToken.symbol} borrowed:*
${borrowedTokens}`
          },
          {
            type: "mrkdwn",
            text: `*Best selling exchange:*
${bestSellingExchangeName}`
          },
          {
            type: "mrkdwn",
            text: `*${trade.path[0].toToken.symbol} bought:*
${boughtTokens}`
          },
          {
            type: "mrkdwn",
            text: `*Best buying exchange:*
${bestBuyingExchangeName}`
          },
          {
            type: "mrkdwn",
            text: `*${trade.path[0].fromToken.symbol} bought back:*
${revenues}`
          },
          {
            type: "mrkdwn",
            text: `*Gas cost (in ETH):*
${gasCostETH}`
          },
          {
            type: "mrkdwn",
            text: `*Profit (in ${trade.path[0].fromToken.symbol}):*
${profitInTokens} (${trade.profitPercentage}%)`
          }
        ]
      },
      {
        type: "divider"
      }
    ];
    const worksheetRow = [
      timestamp,
      transactionHash,
      trade.blockNumber,
      +borrowedTokens,
      bestSellingExchangeName,
      trade.path[0].toToken.symbol,
      +boughtTokens,
      bestBuyingExchangeName,
      +revenues,
      +gasCostETH,
      +profitInTokens,
      `${trade.profitPercentage}%`
    ];
    const worksheet = spreadsheet.sheetsByIndex[0];
    const res = await Promise.allSettled([
      sendSlackMessage_default({
        text: "New transaction \u{1F60D}",
        blocks: slackBlock.flat()
      }),
      worksheet.addRows([worksheetRow])
    ]);
    res.forEach((result) => {
      if (result.status === "rejected") {
        eventEmitter_default.emit("error", result.reason);
      }
    });
  } else {
    const tableRow = {
      Timestamp: timestamp,
      "Block number": trade.blockNumber,
      [`${trade.path[0].fromToken.symbol} borrowed`]: borrowedTokens,
      "Best selling exchange": bestSellingExchangeName,
      [`${trade.path[0].toToken.symbol} bought`]: boughtTokens,
      "Best buying exchange": bestBuyingExchangeName,
      [`${trade.path[0].fromToken.symbol} bought back`]: revenues,
      "Gas cost (in ETH)": gasCostETH,
      [`Profit (in ${trade.path[0].fromToken.symbol})`]: profitInTokens,
      "Profit (%)": trade.profitPercentage + "%"
    };
    console.table([tableRow]);
  }
};
var logger_default = {
  log,
  error,
  transaction
};

// communicator/GasFeesWatcher.ts
var import_axios2 = __toModule(require_axios2());
var GasFeesWatcher = class {
  constructor(blocknativeApiKey, maxPriorityFeePerGasMultiplicator) {
    this.blocknativeApiKey = blocknativeApiKey;
    this.maxPriorityFeePerGasMultiplicator = maxPriorityFeePerGasMultiplicator;
  }
  start(callback, interval) {
    return __async(this, null, function* () {
      const fn = () => __async(this, null, function* () {
        try {
          const prices = yield this.getGasFees();
          callback(prices);
        } catch (error2) {
          logger_default.error(error2);
        }
      });
      yield fn();
      logger_default.log("Gas fees watcher started.");
      setInterval(fn, interval);
    });
  }
  convertGweiNumberToWei(gwei) {
    return Math.ceil(gwei * __pow(10, 9));
  }
  getGasFees() {
    return __async(this, null, function* () {
      const res = yield import_axios2.default.get("https://api.blocknative.com/gasprices/blockprices?confidenceLevels=99", {
        headers: {
          Authorization: this.blocknativeApiKey
        }
      });
      const pendingBlock = res.data.blockPrices[0];
      const baseFeePerGas = pendingBlock.baseFeePerGas;
      if (res.data.unit !== "gwei") {
        throw new Error(`blocknative have changed the unit of the gas fees their API returns. New unit: ${res.data.unit}. We are currently working with gwei,`);
      }
      const maxPriorityFeePerGasWei = this.convertGweiNumberToWei(pendingBlock.estimatedPrices[0].maxPriorityFeePerGas);
      const maxPriorityFeePerGas = Math.floor(maxPriorityFeePerGasWei * this.maxPriorityFeePerGasMultiplicator);
      const baseFeePerGasWei = this.convertGweiNumberToWei(baseFeePerGas);
      const maxFeePerGas = baseFeePerGasWei + maxPriorityFeePerGas;
      return {
        maxPriorityFeePerGas,
        maxFeePerGas
      };
    });
  }
};
var GasFeesWatcher_default = GasFeesWatcher;

// communicator/config.ts
var import_dotenv2 = __toModule(require_main());
import_dotenv2.default.config();
var config2 = {
  blocknativeApiKey: env_default("BLOCKNATIVE_API_KEY"),
  maxPriorityFeePerGasMultiplicator: +env_default("MAX_PRIORITY_FEE_PER_GAS_MULTIPLICATOR")
};
var config_default2 = config2;

// communicator/constant.ts
var PORT = 80;

// communicator/index.ts
var gasFees;
var gasFeesWatcher = new GasFeesWatcher_default(config_default2.blocknativeApiKey, config_default2.maxPriorityFeePerGasMultiplicator);
var wss = new import_websocket_server.default({ port: PORT });
wss.on("listening", () => {
  logger_default.log(`Communicator started and listening on port ${PORT}`);
  gasFeesWatcher.start((updatedGasFees) => {
    gasFees = updatedGasFees;
    wss.clients.forEach((client) => {
      if (client.readyState === wrapper_default.OPEN) {
        const message = {
          type: "gasFeesUpdate",
          data: updatedGasFees
        };
        client.send(JSON.stringify(message));
      }
    });
  }, 5500);
});
wss.on("connection", function connection(connectedClient) {
  logger_default.log("New client connected");
  if (gasFees) {
    const initialMessage = {
      type: "gasFeesUpdate",
      data: gasFees
    };
    connectedClient.send(JSON.stringify(initialMessage));
  }
  connectedClient.on("message", (data) => {
    const message = JSON.parse(data.toString());
    if (message.type === "stopMonitoringSignal") {
      logger_default.log(`Stop monitoring signal received and forwarded to other clients.`);
      wss.clients.forEach((client) => {
        if (client.readyState === wrapper_default.OPEN) {
          client.send(data);
        }
      });
    }
  });
});
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/**
 * stack-trace - Parses node.js stack traces
 *
 * This was originally forked to fix this issue:
 * https://github.com/felixge/node-stack-trace/issues/31
 *
 * Mar 19,2019 - #4fd379e
 *
 * https://github.com/felixge/node-stack-trace/
 * @license MIT
 */
