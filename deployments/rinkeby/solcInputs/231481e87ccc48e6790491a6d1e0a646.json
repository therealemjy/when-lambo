{
  "language": "Solidity",
  "sources": {
    "chainHandler/contracts/interfaces/IDyDxCallee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../libraries/DyDx.sol';\n\n// Interface used for a contract to be callable after receiving a flash loan\ninterface IDyDxCallee {\n  function callFunction(\n    address sender,\n    Account.Info memory accountInfo,\n    bytes memory data\n  ) external;\n}\n"
    },
    "chainHandler/contracts/libraries/DyDx.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary Types {\n  enum AssetDenomination {\n    Wei,\n    Par\n  }\n\n  enum AssetReference {\n    Delta,\n    Target\n  }\n\n  struct AssetAmount {\n    bool sign;\n    AssetDenomination denomination;\n    AssetReference ref;\n    uint256 value;\n  }\n}\n\nlibrary Account {\n  struct Info {\n    address owner;\n    uint256 number;\n  }\n}\n\nlibrary Actions {\n  enum ActionType {\n    Deposit,\n    Withdraw,\n    Transfer,\n    Buy,\n    Sell,\n    Trade,\n    Liquidate,\n    Vaporize,\n    Call\n  }\n\n  struct ActionArgs {\n    ActionType actionType;\n    uint256 accountId;\n    Types.AssetAmount amount;\n    uint256 primaryMarketId;\n    uint256 secondaryMarketId;\n    address otherAddress;\n    uint256 otherAccountId;\n    bytes data;\n  }\n}\n"
    },
    "chainHandler/contracts/Transactor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport './Owner.sol';\nimport './interfaces/IDyDxCallee.sol';\nimport './interfaces/IDyDxSoloMargin.sol';\nimport './interfaces/IUniswapV2Router.sol';\nimport './libraries/DyDx.sol';\n\nenum Exchange {\n  UniswapV2,\n  Sushiswap,\n  CryptoCom\n}\n\ncontract Transactor is Owner, IDyDxCallee {\n  IERC20 private weth;\n  IDyDxSoloMargin private dydxSoloMargin;\n  IUniswapV2Router private uniswapV2Router;\n  IUniswapV2Router private sushiswapRouter;\n  IUniswapV2Router private cryptoComRouter;\n\n  event SuccessfulTrade(\n    address tradedTokenAddress,\n    uint256 borrowedWethAmount,\n    Exchange sellingExchangeIndex,\n    uint256 tradedTokenAmountOut,\n    Exchange buyingExchangeIndex,\n    uint256 wethAmountOut\n  );\n\n  struct CallFunctionData {\n    uint256 borrowedWethAmount;\n    address tradedToken;\n    uint256 tradedTokenAmountOutMin;\n    uint256 wethAmountOutMin;\n    Exchange sellingExchangeIndex;\n    Exchange buyingExchangeIndex;\n    uint256 deadline;\n  }\n\n  constructor(\n    address _wethAddress,\n    address _dydxSoloMargin,\n    address _uniswapV2Router,\n    address _sushiswapRouter,\n    address _cryptoComRouter\n  ) {\n    weth = IERC20(_wethAddress);\n\n    // Initialize exchange contracts\n    dydxSoloMargin = IDyDxSoloMargin(_dydxSoloMargin);\n    uniswapV2Router = IUniswapV2Router(_uniswapV2Router);\n    // Note: we use the same interface for SushiswapRouter and CryptoComRouter because\n    // they are both forks of UniswapV2Router\n    sushiswapRouter = IUniswapV2Router(_sushiswapRouter);\n    cryptoComRouter = IUniswapV2Router(_cryptoComRouter);\n  }\n\n  function destruct(address payable _to) external owned {\n    // Transfer WETH left on the contract to the provided address\n    uint256 wethBalance = weth.balanceOf(address(this));\n    weth.transfer(_to, wethBalance);\n\n    selfdestruct(_to);\n  }\n\n  // Function to receive ethers when msg.data is empty\n  // solhint-disable-next-line no-empty-blocks\n  receive() external payable {}\n\n  // Fallback function to receive ethers when msg.data is not empty\n  fallback() external payable {}\n\n  function transferERC20(\n    address _token,\n    uint256 _amount,\n    address _to\n  ) external owned {\n    IERC20(_token).transfer(_to, _amount);\n  }\n\n  function transferETH(uint256 _amount, address payable _to) external owned {\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, ) = _to.call{value: _amount}('');\n    require(success, 'Transfer failed');\n  }\n\n  function getExchange(Exchange exchangeIndex) public view returns (IUniswapV2Router) {\n    // Define selling and buying exchanges based on passed sellingExchangeIndex and buyingExchangeIndex\n    // Note: we can use single variables that contain the selling and buying exchanges because\n    // currently all our exchanges share the same interface (UniswapV2Router). This logic will need to\n    // be updated once we support non-Uniswap like exchanges.\n    IUniswapV2Router exchange = uniswapV2Router;\n\n    if (exchangeIndex == Exchange.Sushiswap) {\n      exchange = sushiswapRouter;\n    } else if (exchangeIndex == Exchange.CryptoCom) {\n      exchange = cryptoComRouter;\n    }\n\n    return exchange;\n  }\n\n  function swap(\n    address fromToken,\n    uint256 fromTokenAmountIn,\n    Exchange exchangeIndex,\n    address toToken,\n    uint256 toTokenAmountOutMin,\n    uint256 deadline\n  ) internal returns (uint256 toTokenAmountOut) {\n    IUniswapV2Router exchange = getExchange(exchangeIndex);\n\n    // Allow the exchange to withdraw the amount of fromToken we want to exchange\n    IERC20(fromToken).approve(address(exchange), fromTokenAmountIn);\n\n    // Swap all the fromTokens to toTokens\n    address[] memory path = new address[](2);\n    path[0] = fromToken;\n    path[1] = toToken;\n\n    uint256 toTokenAmountReceived = exchange.swapExactTokensForTokens(\n      fromTokenAmountIn,\n      toTokenAmountOutMin,\n      path,\n      address(this),\n      deadline\n    )[1];\n\n    return toTokenAmountReceived;\n  }\n\n  function trade(\n    uint256 expectedBlockNumber,\n    uint256 _wethAmountToBorrow,\n    Exchange _sellingExchangeIndex,\n    address _tradedToken,\n    uint256 _tradedTokenAmountOutMin,\n    Exchange _buyingExchangeIndex,\n    uint256 _wethAmountOutMin,\n    // Although the deadline does not really apply in our case since our trade is\n    // only valid for one block, we still need to provide one to the exchanges\n    uint256 _deadline\n  ) external owned {\n    // Make sure trade does not execute if a new block was mined since the transaction has been sent\n    require(expectedBlockNumber == block.number, 'Trade expired');\n\n    /*\n      The first step is to initiate a flashloan with DyDx.\n\n      The flash loan functionality in DyDx is predicated by their \"operate\" function,\n      which takes a list of operations to execute, and defers validating the state of\n      things until it's done executing them.\n\n      We thus create three operations, a Withdraw (which loans us the funds), a Call\n      (which invokes the callFunction method on this contract), and a Deposit (which\n      repays the loan, plus the 2 wei fee), and pass them all to \"operate\".\n\n      Note that the Deposit operation will invoke the transferFrom to pay the loan\n      (or whatever amount it was initialized with) back to itself, there is no need\n      to pay it back explicitly.\n\n      At the moment, we only make flashloans in WETH.\n    */\n\n    // DyDx take a fee of 2 wei to execute the flashloan\n    uint256 wethAmountToRepay = _wethAmountToBorrow + 2;\n\n    // Give DyDx permission to withdraw amount to repay. This amount\n    // will only be withdrawn after we've executed our trade.\n    weth.approve(address(dydxSoloMargin), wethAmountToRepay);\n\n    Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\n\n    // Borrow funds\n    operations[0] = Actions.ActionArgs({\n      actionType: Actions.ActionType.Withdraw,\n      accountId: 0,\n      amount: Types.AssetAmount({\n        sign: false,\n        denomination: Types.AssetDenomination.Wei,\n        ref: Types.AssetReference.Delta,\n        value: _wethAmountToBorrow // Amount to borrow\n      }),\n      primaryMarketId: 0, // WETH\n      secondaryMarketId: 0,\n      otherAddress: address(this),\n      otherAccountId: 0,\n      data: ''\n    });\n\n    // Call callFunction to execute the rest of the trade\n    operations[1] = Actions.ActionArgs({\n      actionType: Actions.ActionType.Call,\n      accountId: 0,\n      amount: Types.AssetAmount({\n        sign: false,\n        denomination: Types.AssetDenomination.Wei,\n        ref: Types.AssetReference.Delta,\n        value: 0\n      }),\n      primaryMarketId: 0,\n      secondaryMarketId: 0,\n      otherAddress: address(this),\n      otherAccountId: 0,\n      data: abi.encode(\n        // These parameters will be passed to callFunction\n        CallFunctionData({\n          borrowedWethAmount: _wethAmountToBorrow,\n          tradedToken: _tradedToken,\n          tradedTokenAmountOutMin: _tradedTokenAmountOutMin,\n          wethAmountOutMin: _wethAmountOutMin,\n          sellingExchangeIndex: _sellingExchangeIndex,\n          buyingExchangeIndex: _buyingExchangeIndex,\n          deadline: _deadline\n        })\n      )\n    });\n\n    // Repay borrowed funds + fee\n    operations[2] = Actions.ActionArgs({\n      actionType: Actions.ActionType.Deposit,\n      accountId: 0,\n      amount: Types.AssetAmount({\n        sign: true,\n        denomination: Types.AssetDenomination.Wei,\n        ref: Types.AssetReference.Delta,\n        value: wethAmountToRepay\n      }),\n      primaryMarketId: 0, // Market ID of the WETH\n      secondaryMarketId: 0,\n      otherAddress: address(this),\n      otherAccountId: 0,\n      data: ''\n    });\n\n    Account.Info[] memory accountInfos = new Account.Info[](1);\n    accountInfos[0] = Account.Info({owner: address(this), number: 1});\n\n    dydxSoloMargin.operate(accountInfos, operations);\n  }\n\n  // Function called by DyDx after giving us the loan\n  // Note: the type of this function comes from DyDx, do not update it\n  // (even if a warning shows saying some of the parameters are unused)!\n  // Also, its name has to be callFunction.\n  function callFunction(\n    address sender,\n    Account.Info memory accountInfo,\n    bytes memory data\n  ) external override {\n    // Make sure the call comes from DyDx' solo margin contract\n    assert(msg.sender == address(dydxSoloMargin));\n\n    // Decode the passed variables from the data object\n    CallFunctionData memory tradeData = abi.decode(data, (CallFunctionData));\n\n    // Sell all the borrowed WETH for as much tradedToken as possible\n    uint256 tradedTokenAmountOut = swap(\n      address(weth), // fromToken\n      tradeData.borrowedWethAmount, // fromTokenAmountIn\n      tradeData.sellingExchangeIndex,\n      tradeData.tradedToken, // toToken\n      tradeData.tradedTokenAmountOutMin, // Minimum tradedToken amount out for this deal to be profitable\n      tradeData.deadline\n    );\n\n    // Sell all the tradedToken obtained for as much WETH as possible\n    uint256 wethAmountOut = swap(\n      tradeData.tradedToken,\n      tradedTokenAmountOut, // tradedToken amount received from selling the borrowed WETH\n      tradeData.buyingExchangeIndex,\n      address(weth),\n      tradeData.wethAmountOutMin, // Minimum WETH amount out for this deal to be profitable\n      tradeData.deadline\n    );\n\n    emit SuccessfulTrade(\n      tradeData.tradedToken,\n      tradeData.borrowedWethAmount,\n      tradeData.sellingExchangeIndex,\n      tradedTokenAmountOut,\n      tradeData.buyingExchangeIndex,\n      wethAmountOut\n    );\n\n    // After that DyDx will withdraw the amount of WETH we borrowed from them (+ 2 wei fee) and the\n    // profit (in WETH) will be left on the contract\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "chainHandler/contracts/Owner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Owner {\n  address public owner;\n\n  modifier owned() {\n    require(msg.sender == owner, 'Owner only');\n    _;\n  }\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  function setOwner(address _newOwner) public owned {\n    owner = _newOwner;\n  }\n}\n"
    },
    "chainHandler/contracts/interfaces/IDyDxSoloMargin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../libraries/DyDx.sol';\n\ninterface IDyDxSoloMargin {\n  function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;\n}\n"
    },
    "chainHandler/contracts/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IUniswapV2Router {\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}